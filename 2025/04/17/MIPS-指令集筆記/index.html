<!DOCTYPE html><html lang="zh-TW" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>MIPS 指令集筆記 | Hexo</title><meta name="author" content="Rabbir_Reaper"><meta name="copyright" content="Rabbir_Reaper"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="MIPS 指令集概述MIPS 指令集設計遵循 RISC 原則，每條指令的長度固定（32-bit），且指令種類精簡，主要分為以下幾類： 1. R 型（Register 型） 純寄存器運算（不涉及記憶體存取）  通常用於算術與邏輯運算  格式：   1opcode | rs | rt | rd | shamt | funct 1234531      26 25    21 20    16 15">
<meta property="og:type" content="article">
<meta property="og:title" content="MIPS 指令集筆記">
<meta property="og:url" content="https://rabbirreaper.github.io/2025/04/17/MIPS-%E6%8C%87%E4%BB%A4%E9%9B%86%E7%AD%86%E8%A8%98/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="MIPS 指令集概述MIPS 指令集設計遵循 RISC 原則，每條指令的長度固定（32-bit），且指令種類精簡，主要分為以下幾類： 1. R 型（Register 型） 純寄存器運算（不涉及記憶體存取）  通常用於算術與邏輯運算  格式：   1opcode | rs | rt | rd | shamt | funct 1234531      26 25    21 20    16 15">
<meta property="og:locale" content="zh_TW">
<meta property="og:image" content="https://rabbirreaper.github.io/img/butterfly-icon.png">
<meta property="article:published_time" content="2025-04-17T02:42:00.000Z">
<meta property="article:modified_time" content="2025-06-05T12:48:00.469Z">
<meta property="article:author" content="Rabbir_Reaper">
<meta property="article:tag" content="大學筆記">
<meta property="article:tag" content="組合語言">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://rabbirreaper.github.io/img/butterfly-icon.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "MIPS 指令集筆記",
  "url": "https://rabbirreaper.github.io/2025/04/17/MIPS-%E6%8C%87%E4%BB%A4%E9%9B%86%E7%AD%86%E8%A8%98/",
  "image": "https://rabbirreaper.github.io/img/butterfly-icon.png",
  "datePublished": "2025-04-17T02:42:00.000Z",
  "dateModified": "2025-06-05T12:48:00.469Z",
  "author": [
    {
      "@type": "Person",
      "name": "Rabbir_Reaper",
      "url": "https://rabbirreaper.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://rabbirreaper.github.io/2025/04/17/MIPS-%E6%8C%87%E4%BB%A4%E9%9B%86%E7%AD%86%E8%A8%98/index.html"><link rel="preconnect" href="//unpkg.com"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://unpkg.com/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '複製成功',
    error: '複製失敗',
    noSupport: '瀏覽器不支援'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '剛剛',
    min: '分鐘前',
    hour: '小時前',
    day: '天前',
    month: '個月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://unpkg.com/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '載入更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'MIPS 指令集筆記',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="stylesheet" href="https://unpkg.com/mermaid/dist/mermaid.min.css"><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/butterfly-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">82</div></a><a href="/tags/"><div class="headline">標籤</div><div class="length-num">33</div></a><a href="/categories/"><div class="headline">分類</div><div class="length-num">10</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-user"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Hexo</span></a><a class="nav-page-title" href="/"><span class="site-name">MIPS 指令集筆記</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首頁</span></span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-user"></i><span> About</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">MIPS 指令集筆記</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">發表於</span><time class="post-meta-date-created" datetime="2025-04-17T02:42:00.000Z" title="發表於 2025-04-17 10:42:00">2025-04-17</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新於</span><time class="post-meta-date-updated" datetime="2025-06-05T12:48:00.469Z" title="更新於 2025-06-05 20:48:00">2025-06-05</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">瀏覽量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="MIPS-指令集概述"><a href="#MIPS-指令集概述" class="headerlink" title="MIPS 指令集概述"></a>MIPS 指令集概述</h1><p>MIPS 指令集設計遵循 RISC 原則，每條指令的長度固定（32-bit），且指令種類精簡，主要分為以下幾類：</p>
<h2 id="1-R-型（Register-型）"><a href="#1-R-型（Register-型）" class="headerlink" title="1. R 型（Register 型）"></a>1. R 型（Register 型）</h2><ul>
<li><p>純寄存器運算（不涉及記憶體存取）</p>
</li>
<li><p>通常用於算術與邏輯運算</p>
</li>
<li><p>格式：</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">opcode | rs | rt | rd | shamt | funct</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">31      26 25    21 20    16 15    11 10     6 5        0</span><br><span class="line">+----------+--------+--------+--------+--------+----------+</span><br><span class="line">|  opcode  |   rs   |   rt   |   rd   | shamt  |  funct   |</span><br><span class="line">+----------+--------+--------+--------+--------+----------+</span><br><span class="line">    6位元     5位元    5位元    5位元    5位元     6位元</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>欄位</th>
<th>位元位置</th>
<th>位元數</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>opcode</td>
<td>31-26</td>
<td>6 位元</td>
<td>操作碼，R 型指令中<strong>都為 000000</strong></td>
</tr>
<tr>
<td>rs</td>
<td>25-21</td>
<td>5 位元</td>
<td>第一個來源寄存器</td>
</tr>
<tr>
<td>rt</td>
<td>20-16</td>
<td>5 位元</td>
<td>第二個來源寄存器（R 型）或目標寄存器（I 型）</td>
</tr>
<tr>
<td>rd</td>
<td>15-11</td>
<td>5 位元</td>
<td>目標寄存器（存放結果），僅用於 R 型指令</td>
</tr>
<tr>
<td>shamt</td>
<td>10-6</td>
<td>5 位元</td>
<td>移位量（用於 shift 指令），通常在非移位指令中為 00000</td>
</tr>
<tr>
<td>funct</td>
<td>5-0</td>
<td>6 位元</td>
<td>功能碼，決定 R 型指令中的具體運算類型</td>
</tr>
</tbody></table>
<ul>
<li>範例：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">add $t0, $t1, $t2  # $t0 = $t1 + $t2</span><br><span class="line">sub $s1, $s2, $s3  # $s1 = $s2 - $s3</span><br></pre></td></tr></table></figure>
<pre class="mermaid">flowchart TD
    %% 指令
    instruction["add $s0, $t0, $t1"]
    
    %% 指令部分
    op1["add"]
    rd1["$s0"]
    rs1["$t0"]
    rt1["$t1"]
    
    %% 指令格式欄位 (水平排列)
    subgraph format["指令格式欄位"]
        direction LR
        op["opcode
        000000"] --- rs["rs
        01000"] --- rt["rt
        01001"] --- rd["rd
        10000"] --- shamt["shamt
        00000"] --- funct["funct
        100000"]
    end
    
    %% 連結指令與各部分
    instruction --> op1
    instruction --> rd1
    instruction --> rs1
    instruction --> rt1
    
    %% 連結指令部分與相應欄位
    op1 -...-> funct
    rd1 -...-> rd
    rs1 -...-> rs
    rt1 -...-> rt</pre>
<h2 id="2-I-型（Immediate-型）"><a href="#2-I-型（Immediate-型）" class="headerlink" title="2. I 型（Immediate 型）"></a>2. I 型（Immediate 型）</h2><ul>
<li><p>來源或目標包含一個立即值（constant）</p>
</li>
<li><p>常用於記憶體存取、條件分支與數學運算</p>
</li>
<li><p>格式：</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">opcode | rs | rt | immediate</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">31      26 25    21 20    16 15                        0</span><br><span class="line">+----------+--------+--------+---------------------------+</span><br><span class="line">|  opcode  |   rs   |   rt   |        immediate          |</span><br><span class="line">+----------+--------+--------+---------------------------+</span><br><span class="line">    6位元     5位元    5位元             16位元</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>欄位</th>
<th>位元位置</th>
<th>位元數</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>opcode</td>
<td>31-26</td>
<td>6 位元</td>
<td>操作碼，R 型指令中為 000000</td>
</tr>
<tr>
<td>rs</td>
<td>25-21</td>
<td>5 位元</td>
<td>第一個來源寄存器</td>
</tr>
<tr>
<td>rt</td>
<td>20-16</td>
<td>5 位元</td>
<td>第二個來源寄存器（R 型）或目標寄存器（I 型）</td>
</tr>
<tr>
<td>immediate</td>
<td>15-0</td>
<td>16 位元</td>
<td>I 型指令中的立即值，用於常數或位移</td>
</tr>
</tbody></table>
<ul>
<li>範例：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">addi $t0, $t1, 10  # $t0 = $t1 + 10</span><br><span class="line">lw   $s1, 4($s2)   # $s1 = Memory[$s2 + 4]</span><br><span class="line">beq  $t0, $t1, LABEL # 若 $t0 == $t1 則跳轉到 LABEL</span><br></pre></td></tr></table></figure>
<h2 id="3-J-型（Jump-型）"><a href="#3-J-型（Jump-型）" class="headerlink" title="3. J 型（Jump 型）"></a>3. J 型（Jump 型）</h2><ul>
<li><p>用於跳轉（Jump）</p>
</li>
<li><p>格式：</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">opcode | address</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">31      26 25                                          0</span><br><span class="line">+----------+---------------------------------------------+</span><br><span class="line">|  opcode  |                  address                    |</span><br><span class="line">+----------+---------------------------------------------+</span><br><span class="line">    6位元                     26位元</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>欄位</th>
<th>位元位置</th>
<th>位元數</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>opcode</td>
<td>31-26</td>
<td>6 位元</td>
<td>操作碼，R 型指令中為 000000</td>
</tr>
<tr>
<td>address</td>
<td>25-0</td>
<td>26 位元</td>
<td>J 型指令中的跳轉目標地址</td>
</tr>
</tbody></table>
<ul>
<li>範例：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">j  MAIN   # 直接跳轉到 MAIN</span><br><span class="line">jal FUNC  # 跳轉到 FUNC 並存返回地址（$ra）</span><br></pre></td></tr></table></figure>

<h1 id="MIPS-指令分類"><a href="#MIPS-指令分類" class="headerlink" title="MIPS 指令分類"></a>MIPS 指令分類</h1><h2 id="1-算術與邏輯指令"><a href="#1-算術與邏輯指令" class="headerlink" title="1. 算術與邏輯指令"></a>1. 算術與邏輯指令</h2><p>您說得對，我的表格中確實缺少了一些 MIPS 指令，包括剛才我們討論的 NOR 指令。讓我補充一個更完整的算術與邏輯指令表格：</p>
<table>
<thead>
<tr>
<th>指令</th>
<th>語法</th>
<th>說明</th>
</tr>
</thead>
<tbody><tr>
<td>add</td>
<td><code>add $rd, $rs, $rt</code></td>
<td>加法（溢出檢查）：$rd &#x3D; $rs + $rt</td>
</tr>
<tr>
<td>sub</td>
<td><code>sub $rd, $rs, $rt</code></td>
<td>減法（溢出檢查）：$rd &#x3D; $rs - $rt</td>
</tr>
<tr>
<td>addi</td>
<td><code>addi $rt, $rs, imm</code></td>
<td>加法（帶立即數）：$rt &#x3D; $rs + imm</td>
</tr>
<tr>
<td>and</td>
<td><code>and $rd, $rs, $rt</code></td>
<td>按位 AND：$rd &#x3D; $rs &amp; $rt</td>
</tr>
<tr>
<td>or</td>
<td><code>or $rd, $rs, $rt</code></td>
<td>按位 OR：$rd &#x3D; $rs | $rt</td>
</tr>
<tr>
<td>xor</td>
<td><code>xor $rd, $rs, $rt</code></td>
<td>按位 XOR：$rd &#x3D; $rs ^ $rt</td>
</tr>
<tr>
<td>nor</td>
<td><code>nor $rd, $rs, $rt</code></td>
<td>按位 NOR：$rd &#x3D; ~($rs | $rt)</td>
</tr>
<tr>
<td>sll</td>
<td><code>sll $rd, $rt, shamt</code></td>
<td>左移：$rd &#x3D; $rt &lt;&lt; shamt</td>
</tr>
<tr>
<td>srl</td>
<td><code>srl $rd, $rt, shamt</code></td>
<td>邏輯右移：$rd &#x3D; $rt &gt;&gt; shamt</td>
</tr>
<tr>
<td>sra</td>
<td><code>sra $rd, $rt, shamt</code></td>
<td>算術右移：$rd &#x3D; $rt &gt;&gt; shamt（保留符號位）</td>
</tr>
<tr>
<td>sllv</td>
<td><code>sllv $rd, $rt, $rs</code></td>
<td>變量左移：$rd &#x3D; $rt &lt;&lt; $rs</td>
</tr>
<tr>
<td>srlv</td>
<td><code>srlv $rd, $rt, $rs</code></td>
<td>變量邏輯右移：$rd &#x3D; $rt &gt;&gt; $rs</td>
</tr>
<tr>
<td>srav</td>
<td><code>srav $rd, $rt, $rs</code></td>
<td>變量算術右移：$rd &#x3D; $rt &gt;&gt; $rs（保留符號位）</td>
</tr>
<tr>
<td>addu</td>
<td><code>addu $rd, $rs, $rt</code></td>
<td>無符號加法（不檢查溢出）：$rd &#x3D; $rs + $rt</td>
</tr>
<tr>
<td>subu</td>
<td><code>subu $rd, $rs, $rt</code></td>
<td>無符號減法（不檢查溢出）：$rd &#x3D; $rs - $rt</td>
</tr>
<tr>
<td>addiu</td>
<td><code>addiu $rt, $rs, imm</code></td>
<td>無符號加法（帶立即數）：$rt &#x3D; $rs + imm</td>
</tr>
<tr>
<td>andi</td>
<td><code>andi $rt, $rs, imm</code></td>
<td>按位 AND（帶立即數）：$rt &#x3D; $rs &amp; imm</td>
</tr>
<tr>
<td>ori</td>
<td><code>ori $rt, $rs, imm</code></td>
<td>按位 OR（帶立即數）：$rt &#x3D; $rs | imm</td>
</tr>
<tr>
<td>xori</td>
<td><code>xori $rt, $rs, imm</code></td>
<td>按位 XOR（帶立即數）：$rt &#x3D; $rs ^ imm</td>
</tr>
<tr>
<td>slt</td>
<td><code>slt $rd, $rs, $rt</code></td>
<td>小於則設置：$rd &#x3D; ($rs &lt; $rt) ? 1 : 0</td>
</tr>
<tr>
<td>slti</td>
<td><code>slti $rt, $rs, imm</code></td>
<td>小於立即數則設置：$rt &#x3D; ($rs &lt; imm) ? 1 : 0</td>
</tr>
<tr>
<td>sltu</td>
<td><code>sltu $rd, $rs, $rt</code></td>
<td>無符號小於則設置：$rd &#x3D; ($rs &lt; $rt) ? 1 : 0</td>
</tr>
<tr>
<td>sltiu</td>
<td><code>sltiu $rt, $rs, imm</code></td>
<td>無符號小於立即數則設置：$rt &#x3D; ($rs &lt; imm) ? 1 : 0</td>
</tr>
<tr>
<td>lui</td>
<td><code>lui $rt, imm</code></td>
<td>載入上立即數：$rt &#x3D; imm &lt;&lt; 16</td>
</tr>
<tr>
<td>mul (偽指令)</td>
<td><code>mul $s0, $t0, $t1</code></td>
<td>結果直接存在 $s0（32-bit 結果）</td>
</tr>
<tr>
<td>mult</td>
<td><code>mult $rs, $rt</code></td>
<td>有符號乘法：{Hi,Lo} &#x3D; $rs * $rt</td>
</tr>
<tr>
<td>multu</td>
<td><code>multu $rs, $rt</code></td>
<td>無符號乘法：{Hi,Lo} &#x3D; $rs * $rt</td>
</tr>
<tr>
<td>div</td>
<td><code>div $rs, $rt</code></td>
<td>有符號除法：Lo &#x3D; $rs &#x2F; $rt, Hi &#x3D; $rs % $rt</td>
</tr>
<tr>
<td>divu</td>
<td><code>divu $rs, $rt</code></td>
<td>無符號除法：Lo &#x3D; $rs &#x2F; $rt, Hi &#x3D; $rs % $rt</td>
</tr>
<tr>
<td>mfhi</td>
<td><code>mfhi $rd</code></td>
<td>從 Hi 寄存器取值：$rd &#x3D; Hi</td>
</tr>
<tr>
<td>mflo</td>
<td><code>mflo $rd</code></td>
<td>從 Lo 寄存器取值：$rd &#x3D; Lo</td>
</tr>
<tr>
<td>mthi</td>
<td><code>mthi $rs</code></td>
<td>設置 Hi 寄存器：Hi &#x3D; $rs</td>
</tr>
<tr>
<td>mtlo</td>
<td><code>mtlo $rs</code></td>
<td>設置 Lo 寄存器：Lo &#x3D; $rs</td>
</tr>
</tbody></table>
<h2 id="2-記憶體存取指令"><a href="#2-記憶體存取指令" class="headerlink" title="2. 記憶體存取指令"></a>2. 記憶體存取指令</h2><table>
<thead>
<tr>
<th>指令</th>
<th>語法</th>
<th>說明</th>
</tr>
</thead>
<tbody><tr>
<td>lw</td>
<td><code>lw $rt, offset($rs)</code></td>
<td>載入字（Load Word）：$rt &#x3D; Memory[$rs + offset]</td>
</tr>
<tr>
<td>sw</td>
<td><code>sw $rt, offset($rs)</code></td>
<td>儲存字（Store Word）：Memory[$rs + offset] &#x3D; $rt</td>
</tr>
<tr>
<td>lb</td>
<td><code>lb $rt, offset($rs)</code></td>
<td>載入位元組（Load Byte）：$rt &#x3D; Memory[$rs + offset]（帶符號擴展）</td>
</tr>
<tr>
<td>sb</td>
<td><code>sb $rt, offset($rs)</code></td>
<td>儲存位元組（Store Byte）：Memory[$rs + offset] &#x3D; $rt（低 8 位）</td>
</tr>
<tr>
<td>lbu</td>
<td><code>lbu $rt, offset($rs)</code></td>
<td>載入無符號位元組：$rt &#x3D; Memory[$rs + offset]（零擴展）</td>
</tr>
<tr>
<td>lh</td>
<td><code>lh $rt, offset($rs)</code></td>
<td>載入半字（Load Halfword）：$rt &#x3D; Memory[$rs + offset]（帶符號擴展）</td>
</tr>
<tr>
<td>sh</td>
<td><code>sh $rt, offset($rs)</code></td>
<td>儲存半字（Store Halfword）：Memory[$rs + offset] &#x3D; $rt（低 16 位）</td>
</tr>
<tr>
<td>lhu</td>
<td><code>lhu $rt, offset($rs)</code></td>
<td>載入無符號半字：$rt &#x3D; Memory[$rs + offset]（零擴展）</td>
</tr>
</tbody></table>
<h2 id="3-流程控制指令"><a href="#3-流程控制指令" class="headerlink" title="3. 流程控制指令"></a>3. 流程控制指令</h2><table>
<thead>
<tr>
<th>指令</th>
<th>語法</th>
<th>說明</th>
</tr>
</thead>
<tbody><tr>
<td>beq</td>
<td><code>beq $rs, $rt, label</code></td>
<td>若相等則跳轉：if ($rs &#x3D;&#x3D; $rt) PC &#x3D; label</td>
</tr>
<tr>
<td>bne</td>
<td><code>bne $rs, $rt, label</code></td>
<td>若不相等則跳轉：if ($rs !&#x3D; $rt) PC &#x3D; label</td>
</tr>
<tr>
<td>j</td>
<td><code>j label</code></td>
<td>無條件跳轉：PC &#x3D; label</td>
</tr>
<tr>
<td>jal</td>
<td><code>jal label</code></td>
<td>跳轉並儲存返回地址：$ra &#x3D; PC + 4; PC &#x3D; label</td>
</tr>
<tr>
<td>jr</td>
<td><code>jr $rs</code></td>
<td>返回寄存器：PC &#x3D; $rs（通常用於函數返回）</td>
</tr>
<tr>
<td>blez</td>
<td><code>blez $rs, label</code></td>
<td>若小於等於零則跳轉：if ($rs &lt;&#x3D; 0) PC &#x3D; label</td>
</tr>
<tr>
<td>bgtz</td>
<td><code>bgtz $rs, label</code></td>
<td>若大於零則跳轉：if ($rs &gt; 0) PC &#x3D; label</td>
</tr>
<tr>
<td>bltz</td>
<td><code>bltz $rs, label</code></td>
<td>若小於零則跳轉：if ($rs &lt; 0) PC &#x3D; label</td>
</tr>
<tr>
<td>bgez</td>
<td><code>bgez $rs, label</code></td>
<td>若大於等於零則跳轉：if ($rs &gt;&#x3D; 0) PC &#x3D; label</td>
</tr>
<tr>
<td>syscall</td>
<td><code>syscall</code></td>
<td>系統呼叫（根據 $v0 的值執行不同功能）</td>
</tr>
</tbody></table>
<h1 id="MIPS-註冊表（Registers）"><a href="#MIPS-註冊表（Registers）" class="headerlink" title="MIPS 註冊表（Registers）"></a>MIPS 註冊表（Registers）</h1><blockquote>
<p>MIPS 共有 32 個通用寄存器，通常以 $0~$31 表示，部分寄存器有特殊用途：</p>
</blockquote>
<table>
<thead>
<tr>
<th>編號</th>
<th>寄存器</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>$zero</td>
<td>$0</td>
<td>永遠為 0</td>
</tr>
<tr>
<td>$v0, $v1</td>
<td>$2, $3</td>
<td>函數返回值</td>
</tr>
<tr>
<td>$a0 - $a3</td>
<td>$4 - $7</td>
<td>函數參數</td>
</tr>
<tr>
<td>$t0 - $t9</td>
<td>$8 - $15, $24 - $25</td>
<td>臨時變數（不保留）</td>
</tr>
<tr>
<td>$s0 - $s7</td>
<td>$16 - $23</td>
<td>儲存變數（保留）</td>
</tr>
<tr>
<td>$sp</td>
<td>$29</td>
<td>堆疊指標（Stack Pointer）</td>
</tr>
<tr>
<td>$ra</td>
<td>$31</td>
<td>返回地址（Return Address）</td>
</tr>
</tbody></table>
<h1 id="C語言轉換成組合語言"><a href="#C語言轉換成組合語言" class="headerlink" title="C語言轉換成組合語言"></a>C語言轉換成組合語言</h1><h2 id="陣列的實現"><a href="#陣列的實現" class="headerlink" title="陣列的實現"></a>陣列的實現</h2><ul>
<li>C code:</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A[<span class="number">12</span>] = h + A[<span class="number">8</span>];</span><br></pre></td></tr></table></figure>
<blockquote>
<p>h in <code>$s2</code>,base address of A in <code>$s3</code></p>
</blockquote>
<ul>
<li>Compiled MIPS code:</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lw $t0, 32($s3)</span><br><span class="line">add $t0, $s2, $s0</span><br><span class="line">sw $t0, 48($s3)</span><br></pre></td></tr></table></figure>

<h2 id="copy-variable"><a href="#copy-variable" class="headerlink" title="copy variable"></a>copy variable</h2><ul>
<li>C code:</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = b;</span><br></pre></td></tr></table></figure>

<ul>
<li>Compiled MIPS code:</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add $t0, $s1, $zero</span><br></pre></td></tr></table></figure>

<h2 id="NOT-Operation"><a href="#NOT-Operation" class="headerlink" title="NOT Operation"></a>NOT Operation</h2><p>MIPS裡沒有<code>NOT</code>這個指令但可以特過<code>NOR</code>搭配<code>$zero</code>來達成功能</p>
<ul>
<li>C code:</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = ~b;</span><br></pre></td></tr></table></figure>
<blockquote>
<p> <code>~b = ~(b | 0)</code></p>
</blockquote>
<ul>
<li>Compiled MIPS code:</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nor $t0, $t1,$zero</span><br></pre></td></tr></table></figure>

<h2 id="if-else"><a href="#if-else" class="headerlink" title="if else"></a>if else</h2><h3 id="if-a-b"><a href="#if-a-b" class="headerlink" title="if(a &#x3D;&#x3D; b)"></a>if(a &#x3D;&#x3D; b)</h3><ul>
<li>C code:</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(a == b) f = g + h</span><br><span class="line"><span class="keyword">else</span> f = g - h</span><br><span class="line"><span class="comment">// f,g,h,a,b = $s0,$s1,$s2,$s3,$s4</span></span><br></pre></td></tr></table></figure>

<ul>
<li>Compiled MIPS code:</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">    bne $s3, $s4, Else</span><br><span class="line">    add $s0, $s1, $s2</span><br><span class="line">    j Exit</span><br><span class="line">Else:</span><br><span class="line">    sub $s0, $s1, $s2</span><br><span class="line">Exit: ...</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意這邊Else或是其他<code>Label</code>都是與指令同一行的</p>
</blockquote>
<h3 id="if-a-b-1"><a href="#if-a-b-1" class="headerlink" title="if(a !&#x3D; b)"></a>if(a !&#x3D; b)</h3><ul>
<li>C code:</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(a != b) f = g + h</span><br><span class="line"><span class="keyword">else</span> f = g - h</span><br><span class="line"><span class="comment">// f,g,h,a,b = $s0,$s1,$s2,$s3,$s4</span></span><br></pre></td></tr></table></figure>

<ul>
<li>Compiled MIPS code:</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">    beq $s3, $s4, Else</span><br><span class="line">    add $s0, $s1, $s2</span><br><span class="line">    j Exit</span><br><span class="line">Else:</span><br><span class="line">    sub $s0, $s1, $s2</span><br><span class="line">Exit: ...</span><br></pre></td></tr></table></figure>
<h3 id="if-a"><a href="#if-a" class="headerlink" title="if(a &lt;&#x3D; b)"></a>if(a &lt;&#x3D; b)</h3><ul>
<li>C code:</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(a &lt;= b) f = g + h</span><br><span class="line"><span class="keyword">else</span> f = g - h</span><br><span class="line"><span class="comment">// f,g,h,a,b = $s0,$s1,$s2,$s3,$s4</span></span><br></pre></td></tr></table></figure>

<ul>
<li>Compiled MIPS code:</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">    slt $t0, $s3, $s4</span><br><span class="line">    bne $t0, $zero, Then</span><br><span class="line">    beq $s3, $s4, Then</span><br><span class="line">    sub $s0, $s1, $s2</span><br><span class="line">    j Exit</span><br><span class="line">Then:</span><br><span class="line">    add $s0, $s1, $s2</span><br><span class="line">Exit:</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>a &lt;= b</code>反過來就是判斷<code>b &gt; a</code>&#x3D;&gt;<code>b &lt; a</code></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">    slt $t0, $s4, $s3    # $t0 = (b &lt; a) 檢查是否 b &lt; a</span><br><span class="line">    bne $t0, $zero, Else # 如果 b &lt; a，跳到 Else (即 a &gt; b)</span><br><span class="line">    add $s0, $s1, $s2    # 執行 f = g + h (當 a &lt;= b)</span><br><span class="line">    j Exit</span><br><span class="line">Else:</span><br><span class="line">    sub $s0, $s1, $s2    # 執行 f = g - h (當 a &gt; b)</span><br><span class="line">Exit:</span><br></pre></td></tr></table></figure>
<h3 id="if-a-b-2"><a href="#if-a-b-2" class="headerlink" title="if(a &gt; b)"></a>if(a &gt; b)</h3><ul>
<li>C code:</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(a &gt; b) f = g + h</span><br><span class="line"><span class="keyword">else</span> f = g - h</span><br><span class="line"><span class="comment">// f,g,h,a,b = $s0,$s1,$s2,$s3,$s4</span></span><br></pre></td></tr></table></figure>

<ul>
<li>Compiled MIPS code:</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">    slt $t0, $s4, $s3</span><br><span class="line">    bne $t0, $zero, Else</span><br><span class="line">    add $s0, $s1, $s2</span><br><span class="line">    j Exit</span><br><span class="line">Else:</span><br><span class="line">    sub $s0, $s1, $s2</span><br><span class="line">Exit: ...</span><br></pre></td></tr></table></figure>
<h2 id="while"><a href="#while" class="headerlink" title="while"></a>while</h2><ul>
<li>C code:</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (save[i] == k) i+= <span class="number">1</span>;</span><br><span class="line"><span class="comment">// i in $s3, k in $s5, address of save in $s6</span></span><br></pre></td></tr></table></figure>

<ul>
<li>Compiled MIPS code:</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Loop: </span><br><span class="line">    sll $t1, $s3, 2    # i * 4（因為每個 word = 4 bytes）</span><br><span class="line">    add $t1, $t1, $s6  # 計算 save[i] 的記憶體地址</span><br><span class="line">    1w $t0, 0($t1)     # 讀取 save[i] 的值</span><br><span class="line">    bne $t0, $s5, Exit # 如果 save[i] != k，跳出迴圈</span><br><span class="line">    addi $s3, $s3, 1   # i += 1</span><br><span class="line">    j Loop             # 迴圈繼續執行</span><br><span class="line">Exit: ...</span><br></pre></td></tr></table></figure>
<h2 id="function"><a href="#function" class="headerlink" title="function"></a>function</h2><ul>
<li>C code:</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">leaf_example</span> <span class="params">(<span class="type">int</span> g, h, i, j)</span>&#123; </span><br><span class="line">    <span class="type">int</span> f;</span><br><span class="line">    f = (g + h) - (i + j);</span><br><span class="line">    <span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Arguments g, ..., j in $a0, ..., $a3</span></span><br><span class="line"><span class="comment">// f in $s0 (hence, need to save $s0 on stack)</span></span><br><span class="line"><span class="comment">// Result in $v0</span></span><br></pre></td></tr></table></figure>

<ul>
<li>Compiled MIPS code:</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">leaf_example:</span><br><span class="line">    addi $sp, $sp, -4    # 堆疊指標減 4，為保存 $s0 創建空間</span><br><span class="line">    sw $s0, 0($sp)       # 將 $s0 的原始值保存到堆疊</span><br><span class="line">    add $t0, $a0, $a1    # 計算 $t0 = $a0 + $a1</span><br><span class="line">    add $t1, $a2, $a3    # 計算 $t1 = $a2 + $a3</span><br><span class="line">    sub $s0, $t0, $t1    # 計算 $s0 = $t0 - $t1 (這裡修改了 $s0)</span><br><span class="line">    add $v0, $s0, $zero  # 將結果放入 $v0 (返回值)</span><br><span class="line">    lw $s0, 0($sp)       # 恢復 $s0 的原始值</span><br><span class="line">    addi $sp, $sp, 4     # 恢復堆疊指標</span><br><span class="line">    jr $ra               # 返回呼叫者</span><br></pre></td></tr></table></figure>

<h2 id="遞迴-recursion"><a href="#遞迴-recursion" class="headerlink" title="遞迴(recursion)"></a>遞迴(recursion)</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fact</span> <span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> n * fact(n<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Argument n in $a0</span></span><br><span class="line"><span class="comment">// Result in $v0</span></span><br></pre></td></tr></table></figure>

<ul>
<li>Compiled MIPS code:</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">fact:</span><br><span class="line">    addi $sp, $sp, -8</span><br><span class="line">    sw $ra, 4($sp)</span><br><span class="line">    sw $a0, 0($sp)</span><br><span class="line">    slti $t0, $a0, 1</span><br><span class="line">    beq  $t0, $zero, L1</span><br><span class="line">    addi $v0, $zero, 1</span><br><span class="line">    addi $sp, $sp, 8</span><br><span class="line">    jr $ra</span><br><span class="line">L1: addi $a0, $a0, -1</span><br><span class="line">    jal fact</span><br><span class="line">    lw $a0, 0($sp)</span><br><span class="line">    lw $ra, 4($sp)</span><br><span class="line">    addi $sp, $sp, 8</span><br><span class="line">    mul &amp;v0 ,$a0 ,$v0</span><br><span class="line">    jr $ra</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">fact:</span><br><span class="line">    slti $t0, $a0, 1</span><br><span class="line">    bne  $t0, $zero, base_case</span><br><span class="line"></span><br><span class="line">    addi $sp, $sp, -8</span><br><span class="line">    sw $ra, 4($sp)</span><br><span class="line">    sw $a0, 0($sp)</span><br><span class="line">    addi $a0, $a0, -1</span><br><span class="line">    jal fact</span><br><span class="line">    lw $a0, 0($sp)</span><br><span class="line">    lw $ra, 4($sp)</span><br><span class="line">    addi $sp, $sp, 8</span><br><span class="line">    mul $v0, $a0, $v0</span><br><span class="line">    jr $ra</span><br><span class="line"></span><br><span class="line">base_case:</span><br><span class="line">    li $v0, 1</span><br><span class="line">    jr $ra</span><br></pre></td></tr></table></figure>

<h2 id="字串copy"><a href="#字串copy" class="headerlink" title="字串copy"></a>字串copy</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">strcpy</span><span class="params">(<span class="type">char</span> a[], <span class="type">char</span> y[])</span>&#123; </span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ((x[i]=y[i])!=<span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">        i += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Addresses of x, y in $a0, $a1</span></span><br><span class="line"><span class="comment">// i in $s0</span></span><br></pre></td></tr></table></figure>

<ul>
<li>Compiled MIPS code:</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">strcpy:</span><br><span class="line">    addi $sp, $sp, -4</span><br><span class="line">    sw $s0, 0($sp)</span><br><span class="line">    add $s0, $zero, $zero</span><br><span class="line">L1: add $t1, $s0, $a1  # 處理y[] a1</span><br><span class="line">    lbu $t2, 0($t1)</span><br><span class="line">    add $t3, $s0, $a0  # 處理x[] a0</span><br><span class="line">    sb $t2, 0($t3)</span><br><span class="line">    beq $t2 ,$zero, L2</span><br><span class="line">    addi $s0, $s0, 1</span><br><span class="line">    j L1</span><br><span class="line">L2: lw $s0, 0($sp)</span><br><span class="line">    addi $sp, $sp,4</span><br><span class="line">    jr $ra</span><br></pre></td></tr></table></figure>

<h1 id="組合語言撰寫相關觀念"><a href="#組合語言撰寫相關觀念" class="headerlink" title="組合語言撰寫相關觀念"></a>組合語言撰寫相關觀念</h1><h2 id="為什麼減少-lw-sw-是好的？"><a href="#為什麼減少-lw-sw-是好的？" class="headerlink" title="為什麼減少 lw&#x2F;sw 是好的？"></a>為什麼減少 lw&#x2F;sw 是好的？</h2><ol>
<li><strong>記憶體存取比暫存器慢非常多</strong><br>暫存器（如 $t0<del>$t9, $s0</del>$s7）是 CPU 內部的高速記憶體，存取速度是 幾個 cycle。</li>
</ol>
<p>而讀取記憶體（使用 lw&#x2F;sw）可能會：</p>
<p>觸發 cache read → 如果 hit，可能還 OK</p>
<p>如果 miss，要去 main memory，會慢上 上百倍</p>
<p>👉 所以 lw&#x2F;sw 會成為 performance bottleneck。</p>
<ol start="2">
<li><strong>lw&#x2F;sw 是記憶體與 CPU 的橋樑，有延遲風險</strong><br>在 MIPS 中是典型的 load&#x2F;store architecture，只有 lw &#x2F; sw 會與記憶體直接溝通</li>
</ol>
<p>這會牽涉到「load-use hazard」：</p>
<p>當你剛 lw 一個值，下一個指令馬上用這個值時，可能會 資料尚未準備好，pipeline stall</p>
<ol start="3">
<li><strong>指令空間寶貴，應善用暫存器重用</strong><br>寫得好看的 assembly，應該盡量利用暫存器儲存中間結果，避免不必要的載入與存回</li>
</ol>
<h2 id="為什麼沒有subi"><a href="#為什麼沒有subi" class="headerlink" title="為什麼沒有subi"></a>為什麼沒有subi</h2><p>因為<code>addi</code>可以加負值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">addi $s3, $s3, -4</span><br></pre></td></tr></table></figure>

<h2 id="符號擴展-Sign-Extension"><a href="#符號擴展-Sign-Extension" class="headerlink" title="符號擴展(Sign Extension)"></a>符號擴展(Sign Extension)</h2><blockquote>
<p>符號擴展是將一個較小位元寬度的數值轉換為較大位元寬度時，保留其數值（包括正負號）的一種技術。方法是：將原始數值的最高位（符號位）複製到所有新增的高位中。</p>
</blockquote>
<ol>
<li><strong>addi 指令中的立即值擴展</strong><br>在 <code>addi $rt, $rs, imm</code> 指令中，立即值 imm 是一個 16 位元的數值，但 MIPS 處理器內部運算是在 32 位元上進行的。</li>
</ol>
<p>例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">addi $t0, $t1, 5   # 立即值 5 (0000 0000 0000 0101) 擴展為 (0000 0000 0000 0000 0000 0000 0000 0101)</span><br><span class="line">addi $t0, $t1, -5  # 立即值 -5 (1111 1111 1111 1011) 擴展為 (1111 1111 1111 1111 1111 1111 1111 1011)</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>lb 和 lh 指令中的載入值擴展</strong><br>當使用 <code>lb $rt, offset($rs)</code> 或 <code>lh $rt, offset($rs)</code> 指令從記憶體載入較小的資料時：</li>
</ol>
<p><strong>lb（載入位元組）：</strong></p>
<ul>
<li>從記憶體載入 8 位元（1 個位元組）</li>
<li>取這 8 位元的最高位（第 7 位）</li>
<li>將這個位元複製到高 24 位（位置 8-31）</li>
<li>最終在 $rt 寄存器中存儲一個 32 位元值</li>
</ul>
<p><strong>lh（載入半字）：</strong></p>
<ul>
<li>從記憶體載入 16 位元（2 個位元組）</li>
<li>取這 16 位元的最高位（第 15 位）</li>
<li>將這個位元複製到高 16 位（位置 16-31）</li>
<li>最終在 $rt 寄存器中存儲一個 32 位元值</li>
</ul>
<ol start="3">
<li><strong>beq 和 bne 指令中的位移量擴展</strong><br>在 <code>beq $rs, $rt, label</code> 或 <code>bne $rs, $rt, label</code> 指令中，位移（displacement）也需要符號擴展：<br><strong>擴展過程：</strong></li>
</ol>
<ul>
<li>指令中的 label 被編譯為一個 16 位元的相對位移量</li>
<li>這個位移量表示從**當前位置（PC+4）**跳轉到目標位置需要移動的距離（以字為單位）</li>
<li>這個 16 位元位移量也需要符號擴展為 32 位元，然後左移 2 位（乘以 4）得到位元組位移量</li>
<li>最後加到 PC+4 上得到跳轉目標地址</li>
</ul>
<ol start="4">
<li><strong>對比無符號擴展</strong><blockquote>
<p>無符號擴展（用於 lbu 和 lhu 等指令）則完全不同，它總是用 0 填充高位，而不是複製符號位。</p>
</blockquote>
</li>
</ol>
<blockquote>
<p>因為<code>unsigned</code>所以不用特別處理是要補0還是補1，所以零擴展並不是沒有擴展，而是不用特別判斷都補零。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 載入無符號位元組，假設記憶體值為 250 (1111 1010)</span><br><span class="line">lbu $t0, 0($t1)    # $t0 = 0000 0000 0000 0000 0000 0000 1111 1010 (而不是 1111...1010)</span><br><span class="line">符號擴展確保了有符號數在擴展位寬後仍然保持原始的數值，這對於 MIPS 指令集的正確功能至關重要。</span><br></pre></td></tr></table></figure>

<h2 id="容易搞混的rs-rt-rd"><a href="#容易搞混的rs-rt-rd" class="headerlink" title="容易搞混的rs rt rd"></a>容易搞混的rs rt rd</h2><p>指令類型 | 範例 | rs | rt | rd&#x2F;immediate<br>R-type | add rd, rs, rt | ✔️ | ✔️ | ✔️（rd）<br>I-type | lw rt, offset(rs) | ✔️ | ✔️ | ✔️（immediate）</p>
<h2 id="j-Loop"><a href="#j-Loop" class="headerlink" title="j Loop"></a>j Loop</h2><p>Loop 跳到的位址要除4</p>
<h2 id="bne-t0-t1-2"><a href="#bne-t0-t1-2" class="headerlink" title="bne $t0, $t1, 2"></a>bne $t0, $t1, 2</h2><p>跳到的位址是當前的下個指令與目標記憶體位址<code>後減前/4</code></p>
<h2 id="乘法器實作"><a href="#乘法器實作" class="headerlink" title="乘法器實作"></a>乘法器實作</h2><h3 id="基本的寫法"><a href="#基本的寫法" class="headerlink" title="基本的寫法"></a><strong>基本的寫法</strong></h3><pre class="mermaid">flowchart TD
    A[開始] --> B[初始化乘積P=0]
    B --> C[初始化計數器i=0]
    C --> D{計數器i<32?}
    D -->|是| E{乘數M的最低位=1?}
    D -->|否| K[結束]
    E -->|是| F[乘積P=P+被乘數]
    E -->|否| G[跳過加法]
    F --> G
    G --> H[被乘數左移1位]
    H --> I[乘數右移1位]
    I --> J[計數器i=i+1]
    J --> D</pre>
<h3 id="優化過的寫法"><a href="#優化過的寫法" class="headerlink" title="優化過的寫法"></a><strong>優化過的寫法</strong></h3><pre class="mermaid">flowchart TD
    A[開始] --> B[初始化乘積P=0]
    B --> C[初始化計數器i=0]
    C --> D1[步驟1: 檢查乘數最低位]
    D1 --> E{乘數M的最低位=1?}
    E -->|是| F[積P左側加上被乘數]
    E -->|否| G[跳過加法]
    F --> G
    G --> H[步驟2: 檢查積的最後一位]
    H --> I{積P最後一位=0?}
    I -->|是| J[跳到步驟3]
    I -->|否| K[步驟2a: 相加值覆蓋積前32位元]
    K --> J
    J --> L[步驟3: 積右移1位元]
    L --> M[步驟4: 檢查次數]
    M --> N{計數器i=32?}
    N -->|是| O[結束]
    N -->|否| P[計數器i=i+1]
    P --> D1</pre>
<p><strong>範例：</strong></p>
<p>假設我們有：</p>
<ul>
<li>被乘數 &#x3D; 11 (二進制 1011)</li>
<li>乘數 M &#x3D; 7 (二進制 0111)</li>
<li>乘積 P 初始為 0</li>
</ul>
<p>為了更清楚地顯示，我們將P表示為64位（實際上不需要這麼多位），分為兩部分：高32位和低32位。</p>
<h4 id="初始狀態"><a href="#初始狀態" class="headerlink" title="初始狀態"></a>初始狀態</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">P = [00000000 00000000 00000000 00000000] [00000000 00000000 00000000 00000111]</span><br><span class="line">    |---------- 高32位 (左側) ----------| |---------- 低32位 (右側) ----------|</span><br><span class="line">M = 00000000 00000000 00000000 00000111 (7)</span><br></pre></td></tr></table></figure>

<h4 id="第1次迭代"><a href="#第1次迭代" class="headerlink" title="第1次迭代"></a>第1次迭代</h4><ol>
<li><p><strong>檢查M的最低位</strong>：M最低位 &#x3D; 1</p>
</li>
<li><p><strong>積P左側加上被乘數</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">被乘數 = 00000000 00000000 00000000 00001011 (11)</span><br><span class="line">P的高32位 = 00000000 00000000 00000000 00000000</span><br><span class="line">加法結果 = 00000000 00000000 00000000 00001011</span><br></pre></td></tr></table></figure>

<p>所以P變成：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">P = [00000000 00000000 00000000 00001011] [00000000 00000000 00000000 00000000]</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>檢查P的最後一位</strong>：P的最後一位（最右邊）&#x3D; 0，等於0</p>
</li>
<li><p><strong>P右移1位</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">右移前：P = [00000000 00000000 00000000 00001011] [00000000 00000000 00000000 00000111]</span><br><span class="line">右移後：P = [00000000 00000000 00000000 00000101] [10000000 00000000 00000000 00000011]</span><br><span class="line">                                            ↑ </span><br><span class="line">                                    注意這個1從高位移到了低位</span><br></pre></td></tr></table></figure>
</li>
<li><p>計數器 i &#x3D; 1</p>
</li>
</ol>
<h4 id="第2次迭代"><a href="#第2次迭代" class="headerlink" title="第2次迭代"></a>第2次迭代</h4><ol>
<li><p><strong>檢查M的最低位</strong>：M最低位 &#x3D; 1（我們假設M也在右移，現在檢查的是原來的第二位）</p>
</li>
<li><p><strong>積P左側加上被乘數</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">被乘數 = 00000000 00000000 00000000 00001011 (11)</span><br><span class="line">P的高32位 = 00000000 00000000 00000000 00000101</span><br><span class="line">加法結果 = 00000000 00000000 00000000 00010000</span><br></pre></td></tr></table></figure>

<p>所以P變成：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">P = [00000000 00000000 00000000 00010000] [10000000 00000000 00000000 00000001]</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>檢查P的最後一位</strong>：P的最後一位 &#x3D; 0，等於0</p>
</li>
<li><p><strong>P右移1位</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">右移前：P = [00000000 00000000 00000000 00010000] [10000000 00000000 00000000 00000001]</span><br><span class="line">右移後：P = [00000000 00000000 00000000 00001000] [01000000 00000000 00000000 00000000]</span><br></pre></td></tr></table></figure>
</li>
<li><p>計數器 i &#x3D; 2</p>
</li>
</ol>
<h4 id="第3次迭代"><a href="#第3次迭代" class="headerlink" title="第3次迭代"></a>第3次迭代</h4><ol>
<li><p><strong>檢查M的最低位</strong>：M最低位 &#x3D; 1（檢查原來的第三位）</p>
</li>
<li><p><strong>積P左側加上被乘數</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">被乘數 = 00000000 00000000 00000000 00001011 (11)</span><br><span class="line">P的高32位 = 00000000 00000000 00000000 00001000</span><br><span class="line">加法結果 = 00000000 00000000 00000000 00010011</span><br></pre></td></tr></table></figure>

<p>所以P變成：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">P = [00000000 00000000 00000000 00010011] [01000000 00000000 00000000 00000000]</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>檢查P的最後一位</strong>：P的最後一位 &#x3D; 0，等於0</p>
</li>
<li><p><strong>P右移1位</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">右移前：P = [00000000 00000000 00000000 00010011] [01000000 00000000 00000000 00000000]</span><br><span class="line">右移後：P = [00000000 00000000 00000000 00001001] [10100000 00000000 00000000 00000000]</span><br></pre></td></tr></table></figure>
</li>
<li><p>計數器 i &#x3D; 3</p>
</li>
</ol>
<h4 id="第4次迭代"><a href="#第4次迭代" class="headerlink" title="第4次迭代"></a>第4次迭代</h4><ol>
<li><p><strong>檢查M的最低位</strong>：M最低位 &#x3D; 0（檢查原來的第四位，其值為0）</p>
</li>
<li><p><strong>跳過加法步驟</strong></p>
</li>
<li><p><strong>檢查P的最後一位</strong>：P的最後一位 &#x3D; 0，等於0</p>
</li>
<li><p><strong>P右移1位</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">右移前：P = [00000000 00000000 00000000 00001001] [10100000 00000000 00000000 00000000]</span><br><span class="line">右移後：P = [00000000 00000000 00000000 00000100] [11010000 00000000 00000000 00000000]</span><br></pre></td></tr></table></figure>
</li>
<li><p>計數器 i &#x3D; 4</p>
</li>
</ol>
<p>我們可以提前停止，因為已經處理完乘數的所有有效位（對於7來說只需要3位）。</p>
<h4 id="最終結果"><a href="#最終結果" class="headerlink" title="最終結果"></a>最終結果</h4><p>將P的高32位和低32位合併（截取相關部分）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">P = 00000000 00000000 00000000 00000100 11010000 00000000 00000000 00000000</span><br></pre></td></tr></table></figure>

<p>將其轉換為十進制，得到 01001101 &#x3D; 64 + 8 + 4 + 1 &#x3D; 77，這確實是11 * 7的結果。</p>
<p>在這個算法中，”P左側加上被乘數”指的是將被乘數加到P的高32位部分。這樣做是因為在優化的乘法算法中，P的高位部分存儲當前的部分乘積，而低位部分用於移位操作。每次右移操作後，結果的一部分會從高位移入低位，最終形成完整的乘積。<br>3. <strong>兩種乘法實現的主要差異</strong><br>兩種乘法實現的主要差異<br>基本長乘法（第一張圖）：</p>
<ul>
<li>接模擬手工長乘法算法</li>
<li>每次檢查乘數的一位，若為1則加上被乘數</li>
<li>被乘數左移，乘數右移</li>
<li>簡單直觀，但效率較低</li>
</ul>
<p>優化後的乘法（第二張圖）：</p>
<ul>
<li>增加了檢查積最後一位的步驟</li>
<li>根據積的最後一位決定是否執行特殊處理（步驟2a）</li>
<li>積右移而不是乘數右移</li>
<li>更複雜但效率更高</li>
</ul>
<h3 id="指令差異對比"><a href="#指令差異對比" class="headerlink" title="指令差異對比"></a><strong>指令差異對比</strong></h3><table>
<thead>
<tr>
<th>步驟</th>
<th>基本長乘法</th>
<th>優化後的乘法</th>
</tr>
</thead>
<tbody><tr>
<td>檢查位</td>
<td>檢查乘數最低位</td>
<td>檢查乘數最低位 + 檢查積最後一位</td>
</tr>
<tr>
<td>加法操作</td>
<td>當乘數位為1時，將被乘數加到乘積</td>
<td>當乘數位為1時，將被乘數加到積的左側</td>
</tr>
<tr>
<td>移位操作</td>
<td>被乘數左移、乘數右移</td>
<td>積右移1位元</td>
</tr>
<tr>
<td>特殊處理</td>
<td>無</td>
<td>積最後一位不為0時，相加值覆蓋積前32位元</td>
</tr>
</tbody></table>
<h3 id="MIPS實現上的主要差異"><a href="#MIPS實現上的主要差異" class="headerlink" title="MIPS實現上的主要差異"></a>MIPS實現上的主要差異</h3><ol>
<li><strong>寄存器使用</strong>：</li>
</ol>
<ul>
<li>基本長乘法：需要分別保存被乘數、乘數和乘積</li>
<li>優化後乘法：使用P和M兩個寄存器同時處理乘積和乘數</li>
</ul>
<ol start="2">
<li><strong>指令序列</strong>：</li>
</ol>
<ul>
<li><p>基本長乘法：</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">andi $t3, $t1, 1    # 檢查乘數最低位</span><br><span class="line">beq $t3, $zero, shift  # 如果是0，跳過加法</span><br><span class="line">add $v0, $v0, $t0   # 加上被乘數</span><br><span class="line">sll $t0, $t0, 1     # 被乘數左移</span><br><span class="line">srl $t1, $t1, 1     # 乘數右移</span><br></pre></td></tr></table></figure>
</li>
<li><p>優化後乘法：</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">andi $t3, $t1, 1    # 檢查乘數最低位</span><br><span class="line">beq $t3, $zero, check_product  # 如果是0，跳過加法</span><br><span class="line">addu $t4, $v0, $t0  # 積左側加上被乘數</span><br><span class="line"></span><br><span class="line">check_product:</span><br><span class="line">andi $t5, $v0, 1    # 檢查積最後一位</span><br><span class="line">beq $t5, $zero, shift  # 如果是0，直接移位</span><br><span class="line"># 步驟2a: 相加值覆蓋積前32位元的實現</span><br><span class="line"></span><br><span class="line">shift:</span><br><span class="line">srl $v0, $v0, 1     # 積右移</span><br></pre></td></tr></table></figure></li>
</ul>
<p>這張圖解釋了MIPS處理器中乘法運算的積暫存器架構和相關指令。</p>
<p>在MIPS乘法實現中，為了處理32位元整數相乘產生的64位元結果，系統使用了兩個32位元暫存器來存儲完整的乘積：</p>
<h2 id="除法器"><a href="#除法器" class="headerlink" title="除法器"></a>除法器</h2><h3 id="架構組件說明"><a href="#架構組件說明" class="headerlink" title="架構組件說明"></a>架構組件說明</h3><ul>
<li>32位元<code>ALU</code>：執行減法和加法運算</li>
<li>64位元餘<code>Remainder</code>：儲存中間計算結果，前32位元存放部分餘數，後32位元存放被除數&#x2F;商</li>
<li>32位元<code>divisor</code>：儲存除數</li>
</ul>
<h3 id="演算法步驟詳解"><a href="#演算法步驟詳解" class="headerlink" title="演算法步驟詳解"></a>演算法步驟詳解</h3><h4 id="步驟0：初始配置"><a href="#步驟0：初始配置" class="headerlink" title="步驟0：初始配置"></a>步驟0：初始配置</h4><p>範例:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">13 / 3 = 4 ... 1</span><br></pre></td></tr></table></figure>
<p>除數 : 3<br>被除數 : 13</p>
<ul>
<li>Divisor : 0011</li>
<li>Remaindor : 0000 1101</li>
</ul>
<h4 id="步驟1：餘數左移1位元"><a href="#步驟1：餘數左移1位元" class="headerlink" title="步驟1：餘數左移1位元"></a>步驟1：餘數左移1位元</h4><ul>
<li>Remaindor : [0000 1101] -&gt; [0001 1010]</li>
<li>0001 - 0011 &#x3D; -2 &lt; 0 : 商位元是<code>0</code></li>
</ul>
<h4 id="步驟2：餘數左移1位元"><a href="#步驟2：餘數左移1位元" class="headerlink" title="步驟2：餘數左移1位元"></a>步驟2：餘數左移1位元</h4><ul>
<li>Remaindor : [0001 1010] -&gt; [0011 0100]</li>
<li>0011 - 0011 &#x3D; 0 &#x3D; 0 : 商位元是<code>1</code></li>
</ul>
<h4 id="步驟3：更新商位元"><a href="#步驟3：更新商位元" class="headerlink" title="步驟3：更新商位元"></a>步驟3：更新商位元</h4><ul>
<li>[0011 0100] -&gt; [0000 0101]</li>
</ul>
<h4 id="步驟4：餘數左移1位元"><a href="#步驟4：餘數左移1位元" class="headerlink" title="步驟4：餘數左移1位元"></a>步驟4：餘數左移1位元</h4><ul>
<li>Remaindor : [0000 0101] -&gt; [0000 1010]</li>
<li>0000 - 0011 &#x3D; -3 &lt; 0 : 商位元是<code>0</code></li>
</ul>
<h4 id="步驟5：餘數左移1位元"><a href="#步驟5：餘數左移1位元" class="headerlink" title="步驟5：餘數左移1位元"></a>步驟5：餘數左移1位元</h4><ul>
<li>Remaindor : [0000 1010] -&gt; [0001 0100]</li>
<li>0001 - 0011 &#x3D; -2 &lt; 0 : 商位元是<code>0</code></li>
</ul>
<h4 id="結果"><a href="#結果" class="headerlink" title="結果"></a>結果</h4><ul>
<li>總共左移4位元</li>
<li>0100 &#x3D;&gt; 代表商為<code>4</code></li>
<li>0001 &#x3D;&gt; 代表餘數為<code>1</code></li>
</ul>
<h3 id="關鍵觀念"><a href="#關鍵觀念" class="headerlink" title="關鍵觀念"></a>關鍵觀念</h3><ol>
<li><p>左移操作：每次左移1位元相當於將被除數的下一位元帶入計算</p>
</li>
<li><p>減法判斷：用部分餘數減去除數，判斷是否夠減</p>
</li>
<li><p>商的形成：夠減時商的對應位元為1，不夠減時為0</p>
</li>
<li><p>非回復式：不夠減時不需要恢復，直接進行下一步</p>
</li>
</ol>
<h2 id="積暫存器結構"><a href="#積暫存器結構" class="headerlink" title="積暫存器結構"></a>積暫存器結構</h2><ul>
<li><strong>HI暫存器</strong>：用於存儲乘積的最高有效32位（most-significant 32 bits）</li>
<li><strong>LO暫存器</strong>：用於存儲乘積的最低有效32位（least-significant 32-bits）</li>
</ul>
<p>這種設計允許MIPS處理器處理兩個32位數相乘產生的完整64位結果，避免了溢位問題。</p>
<h3 id="相關指令"><a href="#相關指令" class="headerlink" title="相關指令"></a>相關指令</h3><p>圖中列出了幾個與乘法相關的指令：</p>
<ol>
<li><p><strong>mult rs, rt &#x2F; multu rs, rt</strong></p>
<ul>
<li>這些指令執行有符號乘法(mult)或無符號乘法(multu)</li>
<li>將寄存器rs和rt中的值相乘</li>
<li>64位元乘積自動分配到HI&#x2F;LO暫存器中</li>
</ul>
</li>
<li><p><strong>mfhi rd &#x2F; mflo rd</strong></p>
<ul>
<li>mfhi (Move From HI)：將HI暫存器的值移動到目標寄存器rd中</li>
<li>mflo (Move From LO)：將LO暫存器的值移動到目標寄存器rd中</li>
<li>這些指令用於讀取乘法結果</li>
<li>可以通過檢查HI的值來判斷乘積是否超過32位（如果HI不為0，則表示溢位）</li>
</ul>
</li>
<li><p><strong>mul rd, rs, rt</strong></p>
<ul>
<li>這是一個偽指令，執行乘法並只保留結果的低32位</li>
<li>將結果直接存入rd寄存器，忽略高32位</li>
<li>相當於執行mult後再執行mflo</li>
</ul>
</li>
</ol>
<h3 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h3><p>這種架構的使用流程通常是：</p>
<ol>
<li>執行mult&#x2F;multu指令進行乘法運算</li>
<li>系統自動將64位結果分別存入HI和LO暫存器</li>
<li>程式可以根據需要使用mfhi和mflo指令來讀取完整結果</li>
<li>如果只需要低32位結果，可以直接使用mul指令或僅讀取LO暫存器</li>
</ol>
<p>這種設計使MIPS處理器能夠有效處理32位整數乘法，同時保留完整的64位結果，為程式員提供了處理大數乘法的靈活性。</p>
<h1 id=""><a href="#" class="headerlink" title=""></a></h1></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://rabbirreaper.github.io">Rabbir_Reaper</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章連結: </span><span class="post-copyright-info"><a href="https://rabbirreaper.github.io/2025/04/17/MIPS-%E6%8C%87%E4%BB%A4%E9%9B%86%E7%AD%86%E8%A8%98/">https://rabbirreaper.github.io/2025/04/17/MIPS-%E6%8C%87%E4%BB%A4%E9%9B%86%E7%AD%86%E8%A8%98/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版權聲明: </span><span class="post-copyright-info">本部落格所有文章除特別聲明外，均採用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 授權協議。轉載請註明來源 <a href="https://rabbirreaper.github.io" target="_blank">Hexo</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%A4%A7%E5%AD%B8%E7%AD%86%E8%A8%98/">大學筆記</a><a class="post-meta__tags" href="/tags/%E7%B5%84%E5%90%88%E8%AA%9E%E8%A8%80/">組合語言</a></div><div class="post-share"><div class="social-share" data-image="/img/butterfly-icon.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://unpkg.com/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://unpkg.com/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related  no-desc" href="/2025/04/28/Vue-%E6%B8%AC%E8%A9%A6%E7%AD%86%E8%A8%98/" title="Vue 測試筆記"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">Vue 測試筆記</div></div></div></a><a class="pagination-related  no-desc" href="/2025/04/15/PHP-%E7%AD%86%E8%A8%98/" title="PHP 筆記"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">PHP 筆記</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相關推薦</span></div><div class="relatedPosts-list"><a class="pagination-related no-desc" href="/2025/04/15/PHP-%E7%AD%86%E8%A8%98/" title="PHP 筆記"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-04-15</div><div class="info-item-2">PHP 筆記</div></div></div></a><a class="pagination-related no-desc" href="/2025/03/17/%E7%B5%84%E5%90%88%E8%AA%9E%E8%A8%80%E8%AA%B2%E7%A8%8B%E4%BD%9C%E6%A5%AD%E7%AD%86%E8%A8%98/" title="組合語言課程作業筆記"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-03-17</div><div class="info-item-2">組合語言課程作業筆記</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/butterfly-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Rabbir_Reaper</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">82</div></a><a href="/tags/"><div class="headline">標籤</div><div class="length-num">33</div></a><a href="/categories/"><div class="headline">分類</div><div class="length-num">10</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目錄</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#MIPS-%E6%8C%87%E4%BB%A4%E9%9B%86%E6%A6%82%E8%BF%B0"><span class="toc-number">1.</span> <span class="toc-text">MIPS 指令集概述</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-R-%E5%9E%8B%EF%BC%88Register-%E5%9E%8B%EF%BC%89"><span class="toc-number">1.1.</span> <span class="toc-text">1. R 型（Register 型）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-I-%E5%9E%8B%EF%BC%88Immediate-%E5%9E%8B%EF%BC%89"><span class="toc-number">1.2.</span> <span class="toc-text">2. I 型（Immediate 型）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-J-%E5%9E%8B%EF%BC%88Jump-%E5%9E%8B%EF%BC%89"><span class="toc-number">1.3.</span> <span class="toc-text">3. J 型（Jump 型）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#MIPS-%E6%8C%87%E4%BB%A4%E5%88%86%E9%A1%9E"><span class="toc-number">2.</span> <span class="toc-text">MIPS 指令分類</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E7%AE%97%E8%A1%93%E8%88%87%E9%82%8F%E8%BC%AF%E6%8C%87%E4%BB%A4"><span class="toc-number">2.1.</span> <span class="toc-text">1. 算術與邏輯指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E8%A8%98%E6%86%B6%E9%AB%94%E5%AD%98%E5%8F%96%E6%8C%87%E4%BB%A4"><span class="toc-number">2.2.</span> <span class="toc-text">2. 記憶體存取指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E6%8C%87%E4%BB%A4"><span class="toc-number">2.3.</span> <span class="toc-text">3. 流程控制指令</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#MIPS-%E8%A8%BB%E5%86%8A%E8%A1%A8%EF%BC%88Registers%EF%BC%89"><span class="toc-number">3.</span> <span class="toc-text">MIPS 註冊表（Registers）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#C%E8%AA%9E%E8%A8%80%E8%BD%89%E6%8F%9B%E6%88%90%E7%B5%84%E5%90%88%E8%AA%9E%E8%A8%80"><span class="toc-number">4.</span> <span class="toc-text">C語言轉換成組合語言</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%99%A3%E5%88%97%E7%9A%84%E5%AF%A6%E7%8F%BE"><span class="toc-number">4.1.</span> <span class="toc-text">陣列的實現</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#copy-variable"><span class="toc-number">4.2.</span> <span class="toc-text">copy variable</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#NOT-Operation"><span class="toc-number">4.3.</span> <span class="toc-text">NOT Operation</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#if-else"><span class="toc-number">4.4.</span> <span class="toc-text">if else</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#if-a-b"><span class="toc-number">4.4.1.</span> <span class="toc-text">if(a &#x3D;&#x3D; b)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#if-a-b-1"><span class="toc-number">4.4.2.</span> <span class="toc-text">if(a !&#x3D; b)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#if-a"><span class="toc-number">4.4.3.</span> <span class="toc-text">if(a &lt;&#x3D; b)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#if-a-b-2"><span class="toc-number">4.4.4.</span> <span class="toc-text">if(a &gt; b)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#while"><span class="toc-number">4.5.</span> <span class="toc-text">while</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#function"><span class="toc-number">4.6.</span> <span class="toc-text">function</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%81%9E%E8%BF%B4-recursion"><span class="toc-number">4.7.</span> <span class="toc-text">遞迴(recursion)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E4%B8%B2copy"><span class="toc-number">4.8.</span> <span class="toc-text">字串copy</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%B5%84%E5%90%88%E8%AA%9E%E8%A8%80%E6%92%B0%E5%AF%AB%E7%9B%B8%E9%97%9C%E8%A7%80%E5%BF%B5"><span class="toc-number">5.</span> <span class="toc-text">組合語言撰寫相關觀念</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%82%BA%E4%BB%80%E9%BA%BC%E6%B8%9B%E5%B0%91-lw-sw-%E6%98%AF%E5%A5%BD%E7%9A%84%EF%BC%9F"><span class="toc-number">5.1.</span> <span class="toc-text">為什麼減少 lw&#x2F;sw 是好的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%82%BA%E4%BB%80%E9%BA%BC%E6%B2%92%E6%9C%89subi"><span class="toc-number">5.2.</span> <span class="toc-text">為什麼沒有subi</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%A6%E8%99%9F%E6%93%B4%E5%B1%95-Sign-Extension"><span class="toc-number">5.3.</span> <span class="toc-text">符號擴展(Sign Extension)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%B9%E6%98%93%E6%90%9E%E6%B7%B7%E7%9A%84rs-rt-rd"><span class="toc-number">5.4.</span> <span class="toc-text">容易搞混的rs rt rd</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#j-Loop"><span class="toc-number">5.5.</span> <span class="toc-text">j Loop</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#bne-t0-t1-2"><span class="toc-number">5.6.</span> <span class="toc-text">bne $t0, $t1, 2</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B9%98%E6%B3%95%E5%99%A8%E5%AF%A6%E4%BD%9C"><span class="toc-number">5.7.</span> <span class="toc-text">乘法器實作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%9A%84%E5%AF%AB%E6%B3%95"><span class="toc-number">5.7.1.</span> <span class="toc-text">基本的寫法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%84%AA%E5%8C%96%E9%81%8E%E7%9A%84%E5%AF%AB%E6%B3%95"><span class="toc-number">5.7.2.</span> <span class="toc-text">優化過的寫法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E7%8B%80%E6%85%8B"><span class="toc-number">5.7.2.1.</span> <span class="toc-text">初始狀態</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC1%E6%AC%A1%E8%BF%AD%E4%BB%A3"><span class="toc-number">5.7.2.2.</span> <span class="toc-text">第1次迭代</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC2%E6%AC%A1%E8%BF%AD%E4%BB%A3"><span class="toc-number">5.7.2.3.</span> <span class="toc-text">第2次迭代</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC3%E6%AC%A1%E8%BF%AD%E4%BB%A3"><span class="toc-number">5.7.2.4.</span> <span class="toc-text">第3次迭代</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC4%E6%AC%A1%E8%BF%AD%E4%BB%A3"><span class="toc-number">5.7.2.5.</span> <span class="toc-text">第4次迭代</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E7%B5%82%E7%B5%90%E6%9E%9C"><span class="toc-number">5.7.2.6.</span> <span class="toc-text">最終結果</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E5%B7%AE%E7%95%B0%E5%B0%8D%E6%AF%94"><span class="toc-number">5.7.3.</span> <span class="toc-text">指令差異對比</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MIPS%E5%AF%A6%E7%8F%BE%E4%B8%8A%E7%9A%84%E4%B8%BB%E8%A6%81%E5%B7%AE%E7%95%B0"><span class="toc-number">5.7.4.</span> <span class="toc-text">MIPS實現上的主要差異</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%99%A4%E6%B3%95%E5%99%A8"><span class="toc-number">5.8.</span> <span class="toc-text">除法器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%B6%E6%A7%8B%E7%B5%84%E4%BB%B6%E8%AA%AA%E6%98%8E"><span class="toc-number">5.8.1.</span> <span class="toc-text">架構組件說明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BC%94%E7%AE%97%E6%B3%95%E6%AD%A5%E9%A9%9F%E8%A9%B3%E8%A7%A3"><span class="toc-number">5.8.2.</span> <span class="toc-text">演算法步驟詳解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%A5%E9%A9%9F0%EF%BC%9A%E5%88%9D%E5%A7%8B%E9%85%8D%E7%BD%AE"><span class="toc-number">5.8.2.1.</span> <span class="toc-text">步驟0：初始配置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%A5%E9%A9%9F1%EF%BC%9A%E9%A4%98%E6%95%B8%E5%B7%A6%E7%A7%BB1%E4%BD%8D%E5%85%83"><span class="toc-number">5.8.2.2.</span> <span class="toc-text">步驟1：餘數左移1位元</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%A5%E9%A9%9F2%EF%BC%9A%E9%A4%98%E6%95%B8%E5%B7%A6%E7%A7%BB1%E4%BD%8D%E5%85%83"><span class="toc-number">5.8.2.3.</span> <span class="toc-text">步驟2：餘數左移1位元</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%A5%E9%A9%9F3%EF%BC%9A%E6%9B%B4%E6%96%B0%E5%95%86%E4%BD%8D%E5%85%83"><span class="toc-number">5.8.2.4.</span> <span class="toc-text">步驟3：更新商位元</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%A5%E9%A9%9F4%EF%BC%9A%E9%A4%98%E6%95%B8%E5%B7%A6%E7%A7%BB1%E4%BD%8D%E5%85%83"><span class="toc-number">5.8.2.5.</span> <span class="toc-text">步驟4：餘數左移1位元</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%A5%E9%A9%9F5%EF%BC%9A%E9%A4%98%E6%95%B8%E5%B7%A6%E7%A7%BB1%E4%BD%8D%E5%85%83"><span class="toc-number">5.8.2.6.</span> <span class="toc-text">步驟5：餘數左移1位元</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B5%90%E6%9E%9C"><span class="toc-number">5.8.2.7.</span> <span class="toc-text">結果</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%9C%E9%8D%B5%E8%A7%80%E5%BF%B5"><span class="toc-number">5.8.3.</span> <span class="toc-text">關鍵觀念</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A9%8D%E6%9A%AB%E5%AD%98%E5%99%A8%E7%B5%90%E6%A7%8B"><span class="toc-number">5.9.</span> <span class="toc-text">積暫存器結構</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B8%E9%97%9C%E6%8C%87%E4%BB%A4"><span class="toc-number">5.9.1.</span> <span class="toc-text">相關指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F"><span class="toc-number">5.9.2.</span> <span class="toc-text">使用方式</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">6.</span> <span class="toc-text"></span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/10/31/251031/" title="251031">251031</a><time datetime="2025-10-30T23:49:20.000Z" title="發表於 2025-10-31 07:49:20">2025-10-31</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/10/29/Hono%E8%AA%9E%E6%B3%95%E7%AD%86%E8%A8%98/" title="Hono 語法筆記 (未完成)">Hono 語法筆記 (未完成)</a><time datetime="2025-10-29T05:31:19.000Z" title="發表於 2025-10-29 13:31:19">2025-10-29</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/24/%E8%B3%87%E6%96%99%E7%B5%90%E6%A7%8B-%E8%A8%88%E7%AE%97%E6%99%82%E9%96%93%E8%A4%87%E9%9B%9C%E5%BA%A6/" title="資料結構-計算時間複雜度 (未完成)">資料結構-計算時間複雜度 (未完成)</a><time datetime="2025-09-24T05:31:00.000Z" title="發表於 2025-09-24 13:31:00">2025-09-24</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/06/18/%E9%AB%98%E7%AD%89%E6%BC%94%E7%AE%97%E6%B3%95%E6%9C%9F%E6%9C%AB%E4%BD%9C%E6%A5%AD/" title="高等演算法期末作業">高等演算法期末作業</a><time datetime="2025-06-18T15:54:10.000Z" title="發表於 2025-06-18 23:54:10">2025-06-18</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/05/23/EEG%E5%88%86%E6%9E%90%E7%AD%86%E8%A8%98/" title="EEG分析筆記">EEG分析筆記</a><time datetime="2025-05-22T22:53:06.000Z" title="發表於 2025-05-23 06:53:06">2025-05-23</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;2019 - 2025 By Rabbir_Reaper</span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="閱讀模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日夜模式切換"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="單欄和雙欄切換"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="設定"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目錄"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到頂端"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = `%%{init:{ 'theme':'${theme}'}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://unpkg.com/mermaid/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script></div><script src="https://unpkg.com/mermaid/dist/mermaid.min.js"></script><script async data-pjax src="https://unpkg.com/busuanzi@2.3.0/bsz.pure.mini.js"></script></div></body></html>