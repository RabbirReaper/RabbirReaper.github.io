<!DOCTYPE html><html lang="zh-TW" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>組合語言課程作業筆記 | Hexo</title><meta name="author" content="Rabbir_Reaper"><meta name="copyright" content="Rabbir_Reaper"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="作業2025&#x2F;03&#x2F;11 作業3.9.1 簡答題 (Short Answer Questions)(1). What does a debugger do?翻譯：除錯器的功能是什麼？   解題過程除錯器（Debugger）是一種軟體工具，可幫助程式設計師檢查記憶體和暫存器內容、逐步執行程式，以及設置中斷點，以便在特定位置暫停程式執行，以便檢查狀態和錯誤。   答案A debu">
<meta property="og:type" content="article">
<meta property="og:title" content="組合語言課程作業筆記">
<meta property="og:url" content="https://rabbirreaper.github.io/2025/03/17/%E7%B5%84%E5%90%88%E8%AA%9E%E8%A8%80%E8%AA%B2%E7%A8%8B%E4%BD%9C%E6%A5%AD%E7%AD%86%E8%A8%98/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="作業2025&#x2F;03&#x2F;11 作業3.9.1 簡答題 (Short Answer Questions)(1). What does a debugger do?翻譯：除錯器的功能是什麼？   解題過程除錯器（Debugger）是一種軟體工具，可幫助程式設計師檢查記憶體和暫存器內容、逐步執行程式，以及設置中斷點，以便在特定位置暫停程式執行，以便檢查狀態和錯誤。   答案A debu">
<meta property="og:locale" content="zh_TW">
<meta property="og:image" content="https://rabbirreaper.github.io/img/butterfly-icon.png">
<meta property="article:published_time" content="2025-03-17T13:06:26.000Z">
<meta property="article:modified_time" content="2025-06-09T18:39:01.279Z">
<meta property="article:author" content="Rabbir_Reaper">
<meta property="article:tag" content="大學筆記">
<meta property="article:tag" content="沒用的東西">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://rabbirreaper.github.io/img/butterfly-icon.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "組合語言課程作業筆記",
  "url": "https://rabbirreaper.github.io/2025/03/17/%E7%B5%84%E5%90%88%E8%AA%9E%E8%A8%80%E8%AA%B2%E7%A8%8B%E4%BD%9C%E6%A5%AD%E7%AD%86%E8%A8%98/",
  "image": "https://rabbirreaper.github.io/img/butterfly-icon.png",
  "datePublished": "2025-03-17T13:06:26.000Z",
  "dateModified": "2025-06-09T18:39:01.279Z",
  "author": [
    {
      "@type": "Person",
      "name": "Rabbir_Reaper",
      "url": "https://rabbirreaper.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://rabbirreaper.github.io/2025/03/17/%E7%B5%84%E5%90%88%E8%AA%9E%E8%A8%80%E8%AA%B2%E7%A8%8B%E4%BD%9C%E6%A5%AD%E7%AD%86%E8%A8%98/index.html"><link rel="preconnect" href="//unpkg.com"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://unpkg.com/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '複製成功',
    error: '複製失敗',
    noSupport: '瀏覽器不支援'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '剛剛',
    min: '分鐘前',
    hour: '小時前',
    day: '天前',
    month: '個月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://unpkg.com/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '載入更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '組合語言課程作業筆記',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="stylesheet" href="https://unpkg.com/mermaid/dist/mermaid.min.css"><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/butterfly-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">82</div></a><a href="/tags/"><div class="headline">標籤</div><div class="length-num">33</div></a><a href="/categories/"><div class="headline">分類</div><div class="length-num">10</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-user"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Hexo</span></a><a class="nav-page-title" href="/"><span class="site-name">組合語言課程作業筆記</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首頁</span></span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-user"></i><span> About</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">組合語言課程作業筆記</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">發表於</span><time class="post-meta-date-created" datetime="2025-03-17T13:06:26.000Z" title="發表於 2025-03-17 21:06:26">2025-03-17</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新於</span><time class="post-meta-date-updated" datetime="2025-06-09T18:39:01.279Z" title="更新於 2025-06-10 02:39:01">2025-06-10</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">瀏覽量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><hr>
<h1 id="作業"><a href="#作業" class="headerlink" title="作業"></a>作業</h1><h2 id="2025-03-11-作業"><a href="#2025-03-11-作業" class="headerlink" title="2025&#x2F;03&#x2F;11 作業"></a>2025&#x2F;03&#x2F;11 作業</h2><h3 id="3-9-1-簡答題-Short-Answer-Questions"><a href="#3-9-1-簡答題-Short-Answer-Questions" class="headerlink" title="3.9.1 簡答題 (Short Answer Questions)"></a><strong>3.9.1 簡答題 (Short Answer Questions)</strong></h3><h4 id="1-What-does-a-debugger-do"><a href="#1-What-does-a-debugger-do" class="headerlink" title="(1). What does a debugger do?"></a><strong>(1). What does a debugger do?</strong></h4><p><strong>翻譯：除錯器的功能是什麼？</strong>  </p>
<p><strong>解題過程</strong><br>除錯器（Debugger）是一種軟體工具，可幫助程式設計師檢查記憶體和暫存器內容、逐步執行程式，以及設置中斷點，以便在特定位置暫停程式執行，以便檢查狀態和錯誤。  </p>
<p><strong>答案</strong><br>A debugger allows the programmer to check memory and register contents, run programs in single-step mode, and insert breakpoints. All this helps programmers to debug their programs efficiently.</p>
<hr>
<h4 id="3-What-role-does-linker-and-loader-play-in-file-operation"><a href="#3-What-role-does-linker-and-loader-play-in-file-operation" class="headerlink" title="(3). What role does linker and loader play in file operation?"></a><strong>(3). What role does linker and loader play in file operation?</strong></h4><p><strong>翻譯：連結器和載入器在檔案運作中扮演什麼角色？</strong>  </p>
<p><strong>解題過程</strong>  </p>
<ul>
<li><strong>連結器 (Linker)</strong>：負責將多個目標文件（如程式碼與函式庫）連結在一起，形成一個完整的可執行文件。  </li>
<li><strong>載入器 (Loader)</strong>：將連結後的程式載入到記憶體，決定程式碼和數據應該放置在哪個位置，以便執行。</li>
</ul>
<p><strong>答案</strong>  </p>
<ol>
<li>The linker links multiple files together (including library files) before execution.  </li>
<li>The loader loads the program into RAM, determining where the code should be stored before execution.</li>
</ol>
<hr>
<h4 id="5-What-is-the-benefit-of-using-labels-in-assembly-languages"><a href="#5-What-is-the-benefit-of-using-labels-in-assembly-languages" class="headerlink" title="(5). What is the benefit of using labels in assembly languages?"></a><strong>(5). What is the benefit of using labels in assembly languages?</strong></h4><p><strong>翻譯：在組合語言中，使用標籤有什麼好處？</strong>  </p>
<p><strong>解題過程</strong><br>標籤（Label）可以用來取代記憶體位址，使程式碼更容易閱讀和維護。例如，直接使用數字位址會使程式碼難以理解，而標籤則可以讓程式更具可讀性。  </p>
<p><strong>答案</strong><br>Addresses are numbers and difficult to manage and track. Replacing addresses and constants with labels makes programs easier to track and understand.</p>
<hr>
<h4 id="7-What-is-the-difference-between-a-directive-and-an-instruction"><a href="#7-What-is-the-difference-between-a-directive-and-an-instruction" class="headerlink" title="(7). What is the difference between a directive and an instruction?"></a><strong>(7). What is the difference between a directive and an instruction?</strong></h4><p><strong>翻譯：指令 (Instruction) 和指引 (Directive) 的差別是什麼？</strong>  </p>
<p><strong>解題過程</strong>  </p>
<ul>
<li><strong>指令 (Instruction)</strong>：可執行的命令，例如 MOV、ADD 等，會被轉換成機器碼。  </li>
<li><strong>指引 (Directive)</strong>：不會被翻譯成機器碼，而是用來幫助組譯器，例如 <code>DUP</code>、<code>LABEL</code> 等。</li>
</ul>
<p><strong>答案</strong><br>A directive is a non-executable statement, while an instruction is an executable statement. A directive provides help for the assembler, while an instruction generates machine code.</p>
<hr>
<h4 id="8-Show-an-example-of-a-block-comment"><a href="#8-Show-an-example-of-a-block-comment" class="headerlink" title="(8). Show an example of a block comment."></a><strong>(8). Show an example of a block comment.</strong></h4><p><strong>翻譯：請顯示一個區塊註解的範例。</strong>  </p>
<p><strong>解題過程</strong><br>在組合語言中，可以使用 <code>COMMENT</code> 指令來撰寫區塊註解。  </p>
<p><strong>答案</strong>  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">COMMENT !</span><br><span class="line">this is the first comment line</span><br><span class="line">this is the second comment line</span><br><span class="line">!</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="13-Name-the-four-basic-parts-of-an-assembly-language-instruction"><a href="#13-Name-the-four-basic-parts-of-an-assembly-language-instruction" class="headerlink" title="(13). Name the four basic parts of an assembly language instruction."></a><strong>(13). Name the four basic parts of an assembly language instruction.</strong></h4><p><strong>翻譯：請列出組合語言指令的四個基本部分。</strong>  </p>
<p><strong>解題過程</strong><br>組合語言指令通常由四個部分組成：  </p>
<ol>
<li><strong>標籤 (Label)</strong> - 可選擇性的標記，用於表示某個記憶體位址。  </li>
<li><strong>助記符 (Mnemonic)</strong> - 表示指令，如 <code>MOV</code>、<code>ADD</code> 等。  </li>
<li><strong>操作數 (Operand)</strong> - 指定運算對象，如暫存器或記憶體位置。  </li>
<li><strong>註解 (Comment)</strong> - 說明程式碼的用途，提高可讀性。</li>
</ol>
<p><strong>答案</strong><br>Label, mnemonic, operand(s), comment.</p>
<hr>
<h4 id="14-True-False-MOV-is-an-example-of-an-instruction-mnemonic"><a href="#14-True-False-MOV-is-an-example-of-an-instruction-mnemonic" class="headerlink" title="(14). (True&#x2F;False) MOV is an example of an instruction mnemonic."></a><strong>(14). (True&#x2F;False) MOV is an example of an instruction mnemonic.</strong></h4><p><strong>翻譯：(是&#x2F;否) MOV 是指令助記符的範例。</strong>  </p>
<p><strong>答案</strong><br><strong>True</strong>  </p>
<hr>
<h4 id="18-Write-a-program-that-copies-the-integer-12-to-AL-the-lowercase-letter-‘m’-to-BL-and-the-character-‘-’-to-CL-Then-move-them-to-AH-BH-and-CH-respectively"><a href="#18-Write-a-program-that-copies-the-integer-12-to-AL-the-lowercase-letter-‘m’-to-BL-and-the-character-‘-’-to-CL-Then-move-them-to-AH-BH-and-CH-respectively" class="headerlink" title="(18). Write a program that copies the integer 12 to AL, the lowercase letter ‘m’ to BL, and the character ‘$’ to CL. Then, move them to AH, BH, and CH respectively."></a><strong>(18). Write a program that copies the integer 12 to AL, the lowercase letter ‘m’ to BL, and the character ‘$’ to CL. Then, move them to AH, BH, and CH respectively.</strong></h4><p><strong>翻譯：撰寫一個程式，將數值 12 存入 AL，將字母 ‘m’ 存入 BL，將 ‘$’ 存入 CL，然後分別移動到 AH、BH 和 CH。</strong>  </p>
<p><strong>答案</strong>  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">.MODEL TINY</span><br><span class="line">.CODE</span><br><span class="line">.STARTUP</span><br><span class="line">MOV AL, 12     ; copies the decimal value 12 to AL</span><br><span class="line">MOV BL, &#x27;m&#x27;    ; copies the ASCII code of &#x27;m&#x27; to BL</span><br><span class="line">MOV CL, &#x27;$&#x27;    ; copies the ASCII code of &#x27;$&#x27; to CL</span><br><span class="line">MOV AH, AL     ; moves value in AL to AH</span><br><span class="line">MOV BH, BL     ; moves value in BL to BH</span><br><span class="line">MOV CH, CL     ; moves value in CL to CH</span><br><span class="line">.EXIT</span><br><span class="line">END</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="21-How-is-a-source-file-different-from-a-listing-file"><a href="#21-How-is-a-source-file-different-from-a-listing-file" class="headerlink" title="(21). How is a source file different from a listing file?"></a><strong>(21). How is a source file different from a listing file?</strong></h4><p><strong>翻譯：原始碼文件 (source file) 和列表文件 (listing file) 有什麼不同？</strong>  </p>
<p><strong>解題過程</strong>  </p>
<ul>
<li><strong>原始碼文件 (Source File)</strong>：包含組合語言的程式碼，由程式設計師編寫，並作為組譯器 (assembler) 的輸入。  </li>
<li><strong>列表文件 (Listing File)</strong>：由組譯器產生，除了原始碼外，還包含記憶體位址、機器碼和錯誤資訊，幫助開發者理解程式如何被組譯。</li>
</ul>
<p><strong>答案</strong><br>A source file is given as input to the assembler. A listing file contains additional text that will not be assembled. It is generated by the assembler and provides information such as memory addresses and error messages.</p>
<hr>
<h3 id="3-9-2-算法工作台-Algorithm-Workbench"><a href="#3-9-2-算法工作台-Algorithm-Workbench" class="headerlink" title="3.9.2 算法工作台 (Algorithm Workbench)"></a><strong>3.9.2 算法工作台 (Algorithm Workbench)</strong></h3><h4 id="1-Define-four-symbolic-constants-that-represent-integer-25-in-decimal-binary-octal-and-hexadecimal-formats"><a href="#1-Define-four-symbolic-constants-that-represent-integer-25-in-decimal-binary-octal-and-hexadecimal-formats" class="headerlink" title="(1). Define four symbolic constants that represent integer 25 in decimal, binary, octal, and hexadecimal formats."></a><strong>(1). Define four symbolic constants that represent integer 25 in decimal, binary, octal, and hexadecimal formats.</strong></h4><p><strong>翻譯：定義四個符號常數，分別表示數值 25 的十進位、二進位、八進位和十六進位格式。</strong>  </p>
<p><strong>答案</strong>  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">one   EQU 25      ; decimal</span><br><span class="line">two   EQU 11001b  ; binary</span><br><span class="line">three EQU 31o     ; octal</span><br><span class="line">four  EQU 19h     ; hexadecimal</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="3-Create-a-data-definition-for-a-doubleword-that-stores-it-in-memory-in-big-endian-format"><a href="#3-Create-a-data-definition-for-a-doubleword-that-stores-it-in-memory-in-big-endian-format" class="headerlink" title="(3). Create a data definition for a doubleword that stores it in memory in big endian format."></a><strong>(3). Create a data definition for a doubleword that stores it in memory in big endian format.</strong></h4><p><strong>翻譯：建立一個數據定義，使用 big endian 格式儲存一個雙字 (doubleword)。</strong>  </p>
<p><strong>答案</strong>  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.DATA</span><br><span class="line">myVal LABEL DWORD</span><br><span class="line">BYTE 04h, 03h, 02h, 01h  ; big endian storage</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="5-Write-a-program-that-contains-two-instructions-1-add-the-number-5-to-the-EAX-register-and-2-add-5-to-the-EDX-register-Generate-a-listing-file-and-examine-the-machine-code-generated-by-the-assembler-What-differences-if-any-did-you-find-between-the-two-instructions"><a href="#5-Write-a-program-that-contains-two-instructions-1-add-the-number-5-to-the-EAX-register-and-2-add-5-to-the-EDX-register-Generate-a-listing-file-and-examine-the-machine-code-generated-by-the-assembler-What-differences-if-any-did-you-find-between-the-two-instructions" class="headerlink" title="(5). Write a program that contains two instructions: (1) add the number 5 to the EAX register, and (2) add 5 to the EDX register. Generate a listing file and examine the machine code generated by the assembler. What differences, if any, did you find between the two instructions?"></a><strong>(5). Write a program that contains two instructions: (1) add the number 5 to the EAX register, and (2) add 5 to the EDX register. Generate a listing file and examine the machine code generated by the assembler. What differences, if any, did you find between the two instructions?</strong></h4><p><strong>翻譯：撰寫一個程式，執行以下兩條指令：(1) 將數值 5 加到 EAX 暫存器，(2) 將 5 加到 EDX 暫存器。生成組譯列表文件，並比較這兩條指令的機器碼有何不同。</strong>  </p>
<p><strong>答案</strong>  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ADD EAX, 5</span><br><span class="line">ADD EDX, 5</span><br></pre></td></tr></table></figure>
<p><strong>分析</strong>：<br>這兩條指令的機器碼會有不同的操作碼，因為它們針對不同的暫存器。</p>
<hr>
<h4 id="7-Declare-an-array-of-120-uninitialized-unsigned-doubleword-values"><a href="#7-Declare-an-array-of-120-uninitialized-unsigned-doubleword-values" class="headerlink" title="(7). Declare an array of 120 uninitialized unsigned doubleword values."></a><strong>(7). Declare an array of 120 uninitialized unsigned doubleword values.</strong></h4><p><strong>翻譯：宣告一個包含 120 個未初始化的無符號雙字 (doubleword) 陣列。</strong>  </p>
<p><strong>答案</strong>  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myArray DWORD 120 DUP(?)</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="8-Declare-an-array-of-byte-and-initialize-it-to-the-first-5-letters-of-the-alphabet"><a href="#8-Declare-an-array-of-byte-and-initialize-it-to-the-first-5-letters-of-the-alphabet" class="headerlink" title="(8). Declare an array of byte and initialize it to the first 5 letters of the alphabet."></a><strong>(8). Declare an array of byte and initialize it to the first 5 letters of the alphabet.</strong></h4><p><strong>翻譯：宣告一個位元組陣列，並初始化為前五個英文字母。</strong>  </p>
<p><strong>答案</strong>  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">firstFive BYTE &quot;ABCDE&quot;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="10-Declare-a-32-bit-signed-integer-variable-and-initialize-it-with-the-smallest-possible-negative-decimal-value-Hint-Refer-to-integer-ranges-in-Chapter-1"><a href="#10-Declare-a-32-bit-signed-integer-variable-and-initialize-it-with-the-smallest-possible-negative-decimal-value-Hint-Refer-to-integer-ranges-in-Chapter-1" class="headerlink" title="(10). Declare a 32-bit signed integer variable and initialize it with the smallest possible negative decimal value. (Hint: Refer to integer ranges in Chapter 1.)"></a><strong>(10). Declare a 32-bit signed integer variable and initialize it with the smallest possible negative decimal value. (Hint: Refer to integer ranges in Chapter 1.)</strong></h4><p><strong>翻譯：宣告一個 32 位元的有符號整數變數，並初始化為最小的負數值。（提示：參考第 1 章的整數範圍。）</strong>  </p>
<p><strong>解題過程</strong><br>32 位元的有符號整數範圍為 -2,147,483,648 到 2,147,483,647。最小值在十六進位表示為 <code>80000000h</code>。  </p>
<p><strong>答案</strong>  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">smallVal SDWORD 80000000h  ; -2,147,483,648</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="12-Declare-a-string-variable-containing-the-name-of-your-favorite-color-Initialize-it-as-a-null-terminated-string"><a href="#12-Declare-a-string-variable-containing-the-name-of-your-favorite-color-Initialize-it-as-a-null-terminated-string" class="headerlink" title="(12). Declare a string variable containing the name of your favorite color. Initialize it as a null-terminated string."></a><strong>(12). Declare a string variable containing the name of your favorite color. Initialize it as a null-terminated string.</strong></h4><p><strong>翻譯：宣告一個包含你最喜歡顏色名稱的字串變數，並初始化為以 <code>null</code> 結尾的字串。</strong>  </p>
<p><strong>解題過程</strong><br>組合語言中的字串必須手動加上 <code>0</code> (null 字元) 來標示結束，以符合 C 語言風格的字串終止標準。  </p>
<p><strong>答案</strong>  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">favColor BYTE &quot;blue&quot;, 0  ; 字串 &quot;blue&quot;，以 null 結尾</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="14-True-False-MOV-is-an-example-of-an-instruction-mnemonic-1"><a href="#14-True-False-MOV-is-an-example-of-an-instruction-mnemonic-1" class="headerlink" title="(14). (True&#x2F;False) MOV is an example of an instruction mnemonic."></a><strong>(14). (True&#x2F;False) MOV is an example of an instruction mnemonic.</strong></h4><p><strong>翻譯：(是&#x2F;否) MOV 是指令助記符的範例。</strong>  </p>
<p><strong>答案</strong><br><strong>True</strong></p>
<hr>
<h2 id="2025-03-18-作業"><a href="#2025-03-18-作業" class="headerlink" title="2025&#x2F;03&#x2F;18 作業"></a>2025&#x2F;03&#x2F;18 作業</h2><p>以下是 <strong>4.9.1</strong> 和 <strong>4.9.2</strong> 的詳細解答。</p>
<hr>
<h2 id="4-9-1-簡答題-Short-Answer-Questions"><a href="#4-9-1-簡答題-Short-Answer-Questions" class="headerlink" title="4.9.1 簡答題 (Short Answer Questions)"></a><strong>4.9.1 簡答題 (Short Answer Questions)</strong></h2><h3 id="1-What-will-be-the-value-in-EDX-after-each-of-the-lines-marked-a-and-b-execute"><a href="#1-What-will-be-the-value-in-EDX-after-each-of-the-lines-marked-a-and-b-execute" class="headerlink" title="(1). What will be the value in EDX after each of the lines marked (a) and (b) execute?"></a><strong>(1). What will be the value in EDX after each of the lines marked (a) and (b) execute?</strong></h3><p><strong>翻譯：執行 (a) 和 (b) 標記的指令後，EDX 會儲存什麼值？</strong>  </p>
<p><strong>解題過程</strong>  </p>
<ul>
<li><code>movsx</code>（有號數擴展）會將來源數值的符號位擴展到目標暫存器。  </li>
<li><code>one WORD 8002h</code> 代表的是 <code>8002h</code>，以 16-bit 來看，這是 <code>-32766</code>（負數因為最高位元為 1）。  </li>
<li><code>two WORD 4321h</code> 是 <code>17185</code>，因為最高位元為 0，所以是正數。  </li>
<li><code>movsx edx, one</code> 會擴展 <code>8002h</code> 到 <code>EDX</code>，所以值會變成 <code>FFFF8002h</code>（因為 <code>8002h</code> 被解釋為負數）。  </li>
<li><code>movsx edx, two</code> 會擴展 <code>4321h</code> 到 <code>EDX</code>，所以值會變成 <code>00004321h</code>。</li>
</ul>
<p><strong>答案</strong><br>(a) <code>FFFF8002h</code><br>(b) <code>00004321h</code>  </p>
<hr>
<h3 id="3-What-will-be-the-value-in-EAX-after-the-following-lines-execute"><a href="#3-What-will-be-the-value-in-EAX-after-the-following-lines-execute" class="headerlink" title="(3). What will be the value in EAX after the following lines execute?"></a><strong>(3). What will be the value in EAX after the following lines execute?</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov eax,30020000h</span><br><span class="line">dec ax</span><br></pre></td></tr></table></figure>
<p><strong>翻譯：執行上述指令後，EAX 會儲存什麼值？</strong>  </p>
<p><strong>解題過程</strong>  </p>
<ul>
<li><code>mov eax, 30020000h</code>，這會把 <code>EAX</code> 設為 <code>30020000h</code>。  </li>
<li><code>dec ax</code> 會讓 <code>AX</code> 減 1，即 <code>0000h - 1 = FFFFh</code>，但 <code>EAX</code> 其他部分不變。</li>
</ul>
<p><strong>答案</strong><br><code>3002FFFFh</code>  </p>
<hr>
<h3 id="5-What-will-be-the-value-of-the-Parity-flag-after-the-following-lines-execute"><a href="#5-What-will-be-the-value-of-the-Parity-flag-after-the-following-lines-execute" class="headerlink" title="(5). What will be the value of the Parity flag after the following lines execute?"></a><strong>(5). What will be the value of the Parity flag after the following lines execute?</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov al,1</span><br><span class="line">add al,3</span><br></pre></td></tr></table></figure>
<p><strong>翻譯：執行上述指令後，奇偶旗標 (Parity Flag, PF) 會是什麼值？</strong>  </p>
<p><strong>解題過程</strong>  </p>
<ul>
<li><code>mov al, 1</code>，AL 變成 <code>00000001b</code>  </li>
<li><code>add al, 3</code>，AL 變成 <code>00000001b + 00000011b = 00000100b</code>（4）  </li>
<li><code>00000100b</code> 中的 1 個數是 1（奇數個），所以 PF &#x3D; 0（奇數個 1 時 PF &#x3D; 0）。</li>
</ul>
<p><strong>答案</strong><br>Parity Flag &#x3D; <code>0</code>  </p>
<hr>
<h3 id="7-Explain-how-the-Overflow-flag-helps-or-does-not-help-you-to-determine-whether-the-final-value-in-AL-falls-within-a-valid-signed-range"><a href="#7-Explain-how-the-Overflow-flag-helps-or-does-not-help-you-to-determine-whether-the-final-value-in-AL-falls-within-a-valid-signed-range" class="headerlink" title="(7). Explain how the Overflow flag helps, or does not help you, to determine whether the final value in AL falls within a valid signed range."></a><strong>(7). Explain how the Overflow flag helps, or does not help you, to determine whether the final value in AL falls within a valid signed range.</strong></h3><p><strong>翻譯：解釋 Overflow 旗標如何（或無法）幫助判斷 AL 的最終值是否落在有效的有符號範圍內。</strong>  </p>
<p><strong>解題過程</strong>  </p>
<ul>
<li><strong>Overflow 旗標 (OF)</strong> 會在「有符號數計算時，結果超出範圍」時被設定。  </li>
<li>例如 <code>mov al, -1</code>（AL &#x3D; <code>0xFF</code>），然後 <code>add al, 130</code>（0x82），得到 <code>0xFF + 0x82 = 0x81</code>。  </li>
<li><code>0x81</code> 是 <code>-127</code>，並未超出有符號範圍（-128~127），所以 Overflow Flag 沒有被設置。  </li>
<li>但若加法導致數值超出 -128~127，Overflow Flag 就會被設置，警告我們結果超出範圍。</li>
</ul>
<p><strong>答案</strong><br>The Overflow flag helps determine if a signed operation produces a result outside the valid signed range (-128 to 127 for bytes).  </p>
<hr>
<h3 id="9-What-value-will-RAX-contain-after-the-following-instructions-execute"><a href="#9-What-value-will-RAX-contain-after-the-following-instructions-execute" class="headerlink" title="(9). What value will RAX contain after the following instructions execute?"></a><strong>(9). What value will RAX contain after the following instructions execute?</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.data</span><br><span class="line">dwordVal DWORD 84326732h</span><br><span class="line">.code</span><br><span class="line">mov rax,0FFFFFFFF00000000h</span><br><span class="line">mov rax,dwordVal</span><br></pre></td></tr></table></figure>
<p><strong>翻譯：執行上述指令後，RAX 會儲存什麼值？</strong>  </p>
<p><strong>解題過程</strong>  </p>
<ul>
<li><code>mov rax, 0FFFFFFFF00000000h</code> 會把 <code>RAX</code> 設為 <code>FFFFFFFF00000000h</code>。  </li>
<li><code>mov rax, dwordVal</code> 會將 <code>dwordVal</code> 的 32 位元 (<code>84326732h</code>) 複製到 <code>RAX</code>，但不會影響高 32 位。  </li>
<li>因此，<code>RAX</code> 變成 <code>0000000084326732h</code>。</li>
</ul>
<p><strong>答案</strong><br><code>0000000084326732h</code>  </p>
<hr>
<h3 id="11-What-will-EAX-contain-after-the-following-instructions-execute"><a href="#11-What-will-EAX-contain-after-the-following-instructions-execute" class="headerlink" title="(11). What will EAX contain after the following instructions execute?"></a><strong>(11). What will EAX contain after the following instructions execute?</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.data</span><br><span class="line">dVal DWORD ?</span><br><span class="line">.code</span><br><span class="line">mov dVal,12345678h</span><br><span class="line">mov ax,WORD PTR dVal+2</span><br><span class="line">add ax,3</span><br><span class="line">mov WORD PTR dVal,ax</span><br><span class="line">mov eax,dVal</span><br></pre></td></tr></table></figure>
<p><strong>翻譯：執行上述指令後，EAX 會儲存什麼值？</strong>  </p>
<p><strong>解題過程</strong>  </p>
<ul>
<li><code>mov dVal, 12345678h</code> → <code>dVal = 12345678h</code>  </li>
<li><code>mov ax, WORD PTR dVal+2</code> → 取得高 16 位 (<code>1234h</code>)，AX &#x3D; <code>5678h</code>。  </li>
<li><code>add ax, 3</code> → <code>5678h + 3 = 567Bh</code>。  </li>
<li><code>mov WORD PTR dVal, ax</code> → 修改 <code>dVal</code> 的低 16 位，使 <code>dVal = 567B5678h</code>。  </li>
<li><code>mov eax, dVal</code> → <code>EAX = 567B5678h</code>。</li>
</ul>
<p><strong>答案</strong><br><code>EAX = 567B5678h</code>  </p>
<hr>
<h2 id="4-9-2-算法工作台-Algorithm-Workbench"><a href="#4-9-2-算法工作台-Algorithm-Workbench" class="headerlink" title="4.9.2 算法工作台 (Algorithm Workbench)"></a><strong>4.9.2 算法工作台 (Algorithm Workbench)</strong></h2><h3 id="1-Write-a-sequence-of-MOV-instructions-that-will-exchange-the-upper-and-lower-words-in-a-doubleword-variable-named-three"><a href="#1-Write-a-sequence-of-MOV-instructions-that-will-exchange-the-upper-and-lower-words-in-a-doubleword-variable-named-three" class="headerlink" title="(1). Write a sequence of MOV instructions that will exchange the upper and lower words in a doubleword variable named three."></a><strong>(1). Write a sequence of MOV instructions that will exchange the upper and lower words in a doubleword variable named three.</strong></h3><p><strong>翻譯：撰寫一組 <code>MOV</code> 指令，交換 doubleword 變數 <code>three</code> 的高低 16 位元。</strong>  </p>
<p><strong>答案</strong>  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov ax, WORD PTR three</span><br><span class="line">mov dx, WORD PTR three+2</span><br><span class="line">mov WORD PTR three, dx</span><br><span class="line">mov WORD PTR three+2, ax</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="3-Show-how-you-could-use-the-Parity-flag-combined-with-an-arithmetic-instruction-to-determine-if-a-message-byte-has-even-or-odd-parity"><a href="#3-Show-how-you-could-use-the-Parity-flag-combined-with-an-arithmetic-instruction-to-determine-if-a-message-byte-has-even-or-odd-parity" class="headerlink" title="(3). Show how you could use the Parity flag combined with an arithmetic instruction to determine if a message byte has even or odd parity."></a><strong>(3). Show how you could use the Parity flag combined with an arithmetic instruction to determine if a message byte has even or odd parity.</strong></h3><p><strong>翻譯：使用奇偶旗標 (Parity Flag) 和算術指令，判斷 AL 是否為偶數或奇數奇偶校驗。</strong>  </p>
<p><strong>答案</strong>  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xor al, 1  ; 計算奇偶校驗</span><br><span class="line">jpe even_parity  ; 如果 PF = 1，則為偶數</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="5-Write-a-sequence-of-two-instructions-that-use-addition-to-set-the-Zero-and-Carry-flags-at-the-same-time"><a href="#5-Write-a-sequence-of-two-instructions-that-use-addition-to-set-the-Zero-and-Carry-flags-at-the-same-time" class="headerlink" title="(5). Write a sequence of two instructions that use addition to set the Zero and Carry flags at the same time."></a><strong>(5). Write a sequence of two instructions that use addition to set the Zero and Carry flags at the same time.</strong></h3><p><strong>翻譯：撰寫兩條指令，使用加法同時設置 Zero 和 Carry 旗標。</strong>  </p>
<p><strong>答案</strong>  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov al, 0FFh</span><br><span class="line">add al, 1  ; 溢出，CF=1，結果變 0，ZF=1</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="7-Implement-the-following-arithmetic-expression-in-assembly-language"><a href="#7-Implement-the-following-arithmetic-expression-in-assembly-language" class="headerlink" title="(7). Implement the following arithmetic expression in assembly language:"></a><strong>(7). Implement the following arithmetic expression in assembly language:</strong></h3><p><strong>EAX &#x3D; –val2 + 7 – val3 + val1</strong><br><strong>Assume that val1, val2, and val3 are 32-bit integer variables.</strong>  </p>
<p><strong>翻譯：用組合語言實作以下算術運算式：</strong><br><strong>EAX &#x3D; -val2 + 7 - val3 + val1</strong><br><strong>假設 val1、val2 和 val3 是 32 位元整數變數。</strong>  </p>
<p><strong>解題過程</strong>  </p>
<ol>
<li><code>-val2</code> 需要使用 <code>NEG</code> 指令來取反。  </li>
<li><code>+7</code> 可以用 <code>ADD</code> 指令直接加上。  </li>
<li><code>-val3</code> 也需要 <code>NEG</code> 來取反，然後再加上它的值。  </li>
<li>最後加上 <code>val1</code>，得到結果存入 <code>EAX</code>。</li>
</ol>
<p><strong>答案</strong>  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mov eax, val2   ; 把 val2 存入 EAX</span><br><span class="line">neg eax         ; 取反變成 -val2</span><br><span class="line">add eax, 7      ; 加 7</span><br><span class="line">mov ebx, val3   ; 把 val3 存入 EBX</span><br><span class="line">neg ebx         ; 取反變成 -val3</span><br><span class="line">add eax, ebx    ; 加上 -val3</span><br><span class="line">add eax, val1   ; 加上 val1</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="12-Insert-a-directive-in-the-given-data-that-aligns-myBytes-to-an-even-numbered-address"><a href="#12-Insert-a-directive-in-the-given-data-that-aligns-myBytes-to-an-even-numbered-address" class="headerlink" title="(12). Insert a directive in the given data that aligns myBytes to an even-numbered address."></a><strong>(12). Insert a directive in the given data that aligns <code>myBytes</code> to an even-numbered address.</strong></h3><p><strong>翻譯：在 <code>myBytes</code> 的資料區段插入指令，使其對齊到偶數地址。</strong>  </p>
<p><strong>答案</strong>  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALIGN 2</span><br><span class="line">myBytes BYTE 10h, 20h, 30h, 40h</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="13-What-will-be-the-value-of-EAX-after-each-of-the-following-instructions-execute"><a href="#13-What-will-be-the-value-of-EAX-after-each-of-the-following-instructions-execute" class="headerlink" title="(13). What will be the value of EAX after each of the following instructions execute?"></a><strong>(13). What will be the value of EAX after each of the following instructions execute?</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mov eax, TYPE myBytes        ; a.</span><br><span class="line">mov eax, LENGTHOF myBytes    ; b.</span><br><span class="line">mov eax, SIZEOF myBytes      ; c.</span><br><span class="line">mov eax, TYPE myWords        ; d.</span><br><span class="line">mov eax, LENGTHOF myWords    ; e.</span><br><span class="line">mov eax, SIZEOF myWords      ; f.</span><br><span class="line">mov eax, SIZEOF myString     ; g.</span><br></pre></td></tr></table></figure>

<p><strong>翻譯：執行以下指令後，EAX 的值是多少？</strong>  </p>
<p><strong>解題過程</strong>  </p>
<ul>
<li><code>TYPE</code> 回傳變數的資料型態大小（單個元素的大小）。  </li>
<li><code>LENGTHOF</code> 回傳變數的元素數量。  </li>
<li><code>SIZEOF</code> 回傳變數的總大小（<code>TYPE * LENGTHOF</code>）。</li>
</ul>
<p><strong>答案</strong>  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a. EAX = 1  ; BYTE 變數，每個元素大小為 1</span><br><span class="line">b. EAX = 4  ; myBytes 有 4 個 BYTE</span><br><span class="line">c. EAX = 4  ; SIZEOF = TYPE * LENGTHOF = 1 * 4</span><br><span class="line">d. EAX = 2  ; WORD 變數，每個元素大小為 2</span><br><span class="line">e. EAX = 4  ; myWords 有 4 個 WORD</span><br><span class="line">f. EAX = 8  ; SIZEOF = TYPE * LENGTHOF = 2 * 4</span><br><span class="line">g. EAX = 6  ; &quot;ABCDE&quot; + null 字元 `0`</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="14-Write-a-single-instruction-that-moves-the-first-two-bytes-in-myBytes-to-the-DX-register-The-resulting-value-will-be-2010h"><a href="#14-Write-a-single-instruction-that-moves-the-first-two-bytes-in-myBytes-to-the-DX-register-The-resulting-value-will-be-2010h" class="headerlink" title="(14). Write a single instruction that moves the first two bytes in myBytes to the DX register. The resulting value will be 2010h."></a><strong>(14). Write a single instruction that moves the first two bytes in <code>myBytes</code> to the DX register. The resulting value will be <code>2010h</code>.</strong></h3><p><strong>翻譯：寫一條指令，將 <code>myBytes</code> 的前兩個 BYTE 複製到 DX，結果應為 <code>2010h</code>。</strong>  </p>
<p><strong>答案</strong>  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov dx, WORD PTR myBytes</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="15-Write-an-instruction-that-moves-the-second-byte-in-myWords-to-the-AL-register"><a href="#15-Write-an-instruction-that-moves-the-second-byte-in-myWords-to-the-AL-register" class="headerlink" title="(15). Write an instruction that moves the second byte in myWords to the AL register."></a><strong>(15). Write an instruction that moves the second byte in <code>myWords</code> to the AL register.</strong></h3><p><strong>翻譯：寫一條指令，將 <code>myWords</code> 的第二個 BYTE 複製到 AL。</strong>  </p>
<p><strong>答案</strong>  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov al, BYTE PTR myWords+1</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="16-Write-an-instruction-that-moves-all-four-bytes-in-myBytes-to-the-EAX-register"><a href="#16-Write-an-instruction-that-moves-all-four-bytes-in-myBytes-to-the-EAX-register" class="headerlink" title="(16). Write an instruction that moves all four bytes in myBytes to the EAX register."></a><strong>(16). Write an instruction that moves all four bytes in <code>myBytes</code> to the EAX register.</strong></h3><p><strong>翻譯：寫一條指令，將 <code>myBytes</code> 的四個 BYTE 全部複製到 EAX。</strong>  </p>
<p><strong>答案</strong>  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov eax, DWORD PTR myBytes</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="17-Insert-a-LABEL-directive-in-the-given-data-that-permits-myWords-to-be-moved-directly-to-a-32-bit-register"><a href="#17-Insert-a-LABEL-directive-in-the-given-data-that-permits-myWords-to-be-moved-directly-to-a-32-bit-register" class="headerlink" title="(17). Insert a LABEL directive in the given data that permits myWords to be moved directly to a 32-bit register."></a><strong>(17). Insert a LABEL directive in the given data that permits <code>myWords</code> to be moved directly to a 32-bit register.</strong></h3><p><strong>翻譯：在 <code>myWords</code> 資料區段插入 LABEL 指令，讓它可以直接移動到 32 位元暫存器。</strong>  </p>
<p><strong>答案</strong>  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">myWordsLabel LABEL DWORD</span><br><span class="line">myWords WORD 3 DUP(?), 2000h</span><br></pre></td></tr></table></figure>
<p>這樣 <code>mov eax, myWordsLabel</code> 就能直接把 32-bit 整數存入 <code>EAX</code>。</p>
<hr>
<h3 id="18-Insert-a-LABEL-directive-in-the-given-data-that-permits-myBytes-to-be-moved-directly-to-a-16-bit-register"><a href="#18-Insert-a-LABEL-directive-in-the-given-data-that-permits-myBytes-to-be-moved-directly-to-a-16-bit-register" class="headerlink" title="(18). Insert a LABEL directive in the given data that permits myBytes to be moved directly to a 16-bit register."></a><strong>(18). Insert a LABEL directive in the given data that permits <code>myBytes</code> to be moved directly to a 16-bit register.</strong></h3><p><strong>翻譯：在 <code>myBytes</code> 資料區段插入 LABEL 指令，讓它可以直接移動到 16 位元暫存器。</strong>  </p>
<p><strong>答案</strong>  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">myBytesLabel LABEL WORD</span><br><span class="line">myBytes BYTE 10h, 20h, 30h, 40h</span><br></pre></td></tr></table></figure>
<p>這樣 <code>mov ax, myBytesLabel</code> 就能把 <code>myBytes</code> 的前 2 個 BYTE 存入 <code>AX</code>。</p>
<hr>
<h2 id="5-8-1-簡答題-Short-Answer"><a href="#5-8-1-簡答題-Short-Answer" class="headerlink" title="5.8.1 簡答題 (Short Answer)"></a><strong>5.8.1 簡答題 (Short Answer)</strong></h2><h3 id="2-Which-instruction-pushes-the-32-bit-EFLAGS-register-on-the-stack"><a href="#2-Which-instruction-pushes-the-32-bit-EFLAGS-register-on-the-stack" class="headerlink" title="(2). Which instruction pushes the 32-bit EFLAGS register on the stack?"></a><strong>(2). Which instruction pushes the 32-bit EFLAGS register on the stack?</strong></h3><p><strong>翻譯：哪個指令將32位元的EFLAGS暫存器壓入堆疊？</strong>  </p>
<p><strong>答案</strong><br><code>PUSHFD</code> 指令會將32位元的EFLAGS暫存器壓入堆疊。</p>
<hr>
<h3 id="4-Challenge-Another-assembler-called-NASM-permits-the-PUSH-instruction-to-list-multiple-specific-registers-Why-might-this-approach-be-better-than-the-PUSHAD-instruction-in-MASM"><a href="#4-Challenge-Another-assembler-called-NASM-permits-the-PUSH-instruction-to-list-multiple-specific-registers-Why-might-this-approach-be-better-than-the-PUSHAD-instruction-in-MASM" class="headerlink" title="(4). Challenge: Another assembler (called NASM) permits the PUSH instruction to list multiple specific registers. Why might this approach be better than the PUSHAD instruction in MASM?"></a><strong>(4). Challenge: Another assembler (called NASM) permits the PUSH instruction to list multiple specific registers. Why might this approach be better than the PUSHAD instruction in MASM?</strong></h3><p><strong>翻譯：挑戰：另一個組譯器(稱為NASM)允許PUSH指令列出多個特定暫存器。為什麼這種方式可能比MASM中的PUSHAD指令更好？</strong>  </p>
<p><strong>解題思考</strong>  </p>
<ul>
<li>PUSHAD指令會壓入所有八個32位元通用暫存器，無論是否需要它們</li>
<li>NASM允許PUSH指令選擇性地只壓入需要的暫存器</li>
<li>這提供了更精細的控制，能節省堆疊空間和處理時間</li>
</ul>
<p><strong>答案</strong><br>這種方法更好是因為它可以讓程式設計師只壓入實際需要保存的暫存器，而不是全部八個。這能節省堆疊空間和處理時間，特別是當只需要保存少數暫存器時。也讓程式碼更清晰地表達了哪些暫存器正在被保存。</p>
<hr>
<h3 id="6-True-False-The-RET-instruction-pops-the-top-of-the-stack-into-the-instruction-pointer"><a href="#6-True-False-The-RET-instruction-pops-the-top-of-the-stack-into-the-instruction-pointer" class="headerlink" title="(6). (True&#x2F;False): The RET instruction pops the top of the stack into the instruction pointer."></a><strong>(6). (True&#x2F;False): The RET instruction pops the top of the stack into the instruction pointer.</strong></h3><p><strong>翻譯：(判斷題)：RET指令將堆疊頂端值彈出到指令指標(instruction pointer)中。</strong>  </p>
<p><strong>答案</strong><br>True (正確)。RET指令會將堆疊頂端的值彈出，並載入到指令指標(EIP&#x2F;RIP)中，使程式執行跳轉到該地址。</p>
<hr>
<h3 id="8-True-False-In-protected-mode-each-procedure-call-uses-a-minimum-of-4-bytes-of-stack-space"><a href="#8-True-False-In-protected-mode-each-procedure-call-uses-a-minimum-of-4-bytes-of-stack-space" class="headerlink" title="(8). (True&#x2F;False): In protected mode, each procedure call uses a minimum of 4 bytes of stack space."></a><strong>(8). (True&#x2F;False): In protected mode, each procedure call uses a minimum of 4 bytes of stack space.</strong></h3><p><strong>翻譯：(判斷題)：在保護模式下，每個程序呼叫至少使用4位元組的堆疊空間。</strong>  </p>
<p><strong>答案</strong><br>True (正確)。在保護模式下，CALL指令會將32位元的返回地址(4位元組)壓入堆疊，因此每個程序呼叫至少需要4位元組的堆疊空間。</p>
<hr>
<h3 id="10-True-False-The-ArraySum-procedure-Section-5-2-5-receives-a-pointer-to-any-array-of-doublewords"><a href="#10-True-False-The-ArraySum-procedure-Section-5-2-5-receives-a-pointer-to-any-array-of-doublewords" class="headerlink" title="(10). (True&#x2F;False): The ArraySum procedure (Section 5.2.5) receives a pointer to any array of doublewords."></a><strong>(10). (True&#x2F;False): The ArraySum procedure (Section 5.2.5) receives a pointer to any array of doublewords.</strong></h3><p><strong>翻譯：(判斷題)：ArraySum程序(第5.2.5節)接收一個指向雙字元陣列的指標。</strong>  </p>
<p><strong>答案</strong><br>True (正確)。ArraySum程序接收一個指向雙字元(doubleword)陣列的指標，並對陣列中的元素進行總和計算。</p>
<hr>
<h3 id="12-True-False-The-USES-operator-only-generates-PUSH-instructions-so-you-must-code-POP-instructions-yourself"><a href="#12-True-False-The-USES-operator-only-generates-PUSH-instructions-so-you-must-code-POP-instructions-yourself" class="headerlink" title="(12). (True&#x2F;False): The USES operator only generates PUSH instructions, so you must code POP instructions yourself."></a><strong>(12). (True&#x2F;False): The USES operator only generates PUSH instructions, so you must code POP instructions yourself.</strong></h3><p><strong>翻譯：(判斷題)：USES運算符僅生成PUSH指令，因此你必須自己編寫POP指令。</strong>  </p>
<p><strong>答案</strong><br>False (錯誤)。USES運算符會生成配對的PUSH和POP指令。它在程序開始時自動生成PUSH指令，並在RET指令之前自動生成對應的POP指令，以確保所有暫存器都被正確地恢復。</p>
<hr>
<h3 id="14-Which-statement-s-in-the-ArraySum-procedure-Section-5-2-5-would-have-to-be-modified-so-it-could-accumulate-an-array-of-16-bit-words-Create-such-a-version-of-ArraySum-and-test-it"><a href="#14-Which-statement-s-in-the-ArraySum-procedure-Section-5-2-5-would-have-to-be-modified-so-it-could-accumulate-an-array-of-16-bit-words-Create-such-a-version-of-ArraySum-and-test-it" class="headerlink" title="(14). Which statement(s) in the ArraySum procedure (Section 5.2.5) would have to be modified so it could accumulate an array of 16-bit words? Create such a version of ArraySum and test it."></a><strong>(14). Which statement(s) in the ArraySum procedure (Section 5.2.5) would have to be modified so it could accumulate an array of 16-bit words? Create such a version of ArraySum and test it.</strong></h3><p><strong>翻譯：ArraySum程序(第5.2.5節)中的哪些語句需要修改，使其能夠累加16位元字元陣列？創建這樣一個ArraySum版本並測試它。</strong>  </p>
<p><strong>解題思考</strong><br>需要修改的部分：</p>
<ol>
<li>從陣列讀取值的指令需要從DWORD改為WORD</li>
<li>因為處理的是16位元數，可能需要使用符號或無符號擴展</li>
</ol>
<p><strong>答案</strong><br>需要修改的語句是讀取陣列元素的那一行，從使用DWORD改為WORD，並使用MOVZX指令進行無符號擴展。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">ArraySum PROC</span><br><span class="line">    push ebp</span><br><span class="line">    mov ebp, esp</span><br><span class="line">    mov esi, [ebp+8]       ; 指向陣列</span><br><span class="line">    mov ecx, [ebp+12]      ; 計數值</span><br><span class="line">    mov eax, 0             ; 總和 = 0</span><br><span class="line">    </span><br><span class="line">L1: cmp ecx, 0             ; 計數 &gt; 0?</span><br><span class="line">    jle L2                 ; 否: 退出</span><br><span class="line">    movzx ebx, WORD PTR [esi]  ; 修改點: 使用WORD而非DWORD，並用MOVZX擴展</span><br><span class="line">    add eax, ebx           ; 將值加到總和中</span><br><span class="line">    add esi, 2             ; 修改點: 指向下一個WORD (2位元組)而非DWORD (4位元組)</span><br><span class="line">    dec ecx                ; 計數減1</span><br><span class="line">    jmp L1</span><br><span class="line">L2: pop ebp</span><br><span class="line">    ret 8                  ; 清除堆疊中的參數</span><br><span class="line">ArraySum ENDP</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="15-What-will-be-the-final-value-in-EAX-after-these-instructions-execute"><a href="#15-What-will-be-the-final-value-in-EAX-after-these-instructions-execute" class="headerlink" title="(15). What will be the final value in EAX after these instructions execute?"></a><strong>(15). What will be the final value in EAX after these instructions execute?</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">push 5</span><br><span class="line">push 6</span><br><span class="line">pop eax</span><br><span class="line">pop eax</span><br></pre></td></tr></table></figure>
<p><strong>翻譯：執行這些指令後，EAX中的最終值是什麼？</strong>  </p>
<p><strong>解題過程</strong>  </p>
<ul>
<li><code>push 5</code> 將5壓入堆疊</li>
<li><code>push 6</code> 將6壓入堆疊 (現在堆疊頂端是6，底下是5)</li>
<li><code>pop eax</code> 將堆疊頂端的6彈出到EAX中</li>
<li><code>pop eax</code> 將堆疊頂端的5彈出到EAX中，覆蓋之前的值</li>
</ul>
<p><strong>答案</strong><br>EAX的最終值是5</p>
<hr>
<h3 id="16-Which-statement-is-true-about-what-will-happen-when-the-example-code-runs"><a href="#16-Which-statement-is-true-about-what-will-happen-when-the-example-code-runs" class="headerlink" title="(16). Which statement is true about what will happen when the example code runs?"></a><strong>(16). Which statement is true about what will happen when the example code runs?</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1: main PROC</span><br><span class="line">2: push 10</span><br><span class="line">3: push 20</span><br><span class="line">4: call Ex2Sub</span><br><span class="line">5: pop eax</span><br><span class="line">6: INVOKE ExitProcess,0</span><br><span class="line">7: main ENDP</span><br><span class="line">8:</span><br><span class="line">9: Ex2Sub PROC</span><br><span class="line">10: pop eax</span><br><span class="line">11: ret</span><br><span class="line">12: Ex2Sub ENDP</span><br></pre></td></tr></table></figure>
<p><strong>翻譯：關於範例程式執行時會發生什麼，哪個陳述是正確的？</strong>  </p>
<p><strong>解題過程</strong>  </p>
<ul>
<li>第2行: <code>push 10</code> 壓入值10</li>
<li>第3行: <code>push 20</code> 壓入值20</li>
<li>第4行: <code>call Ex2Sub</code> 壓入返回地址(第5行的地址)，然後跳轉到Ex2Sub</li>
<li>第10行: <code>pop eax</code> 將返回地址從堆疊彈出到EAX (而不是保留在堆疊中)</li>
<li>第11行: <code>ret</code> 嘗試從堆疊彈出返回地址，但返回地址已經不在堆疊頂端</li>
<li>程式會嘗試返回到錯誤的位置並導致執行錯誤</li>
</ul>
<p><strong>答案</strong><br>b. The program will halt with a runtime error on Line 10</p>
<hr>
<h3 id="17-Which-statement-is-true-about-what-will-happen-when-the-example-code-runs"><a href="#17-Which-statement-is-true-about-what-will-happen-when-the-example-code-runs" class="headerlink" title="(17). Which statement is true about what will happen when the example code runs?"></a><strong>(17). Which statement is true about what will happen when the example code runs?</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">1: main PROC</span><br><span class="line">2: mov eax,30</span><br><span class="line">3: push eax</span><br><span class="line">4: push 40</span><br><span class="line">5: call Ex3Sub</span><br><span class="line">6: INVOKE ExitProcess,0</span><br><span class="line">7: main ENDP</span><br><span class="line">8:</span><br><span class="line">9: Ex3Sub PROC</span><br><span class="line">10: pusha</span><br><span class="line">11: mov eax,80</span><br><span class="line">12: popa</span><br><span class="line">13: ret</span><br><span class="line">14: Ex3Sub ENDP</span><br></pre></td></tr></table></figure>
<p><strong>翻譯：關於範例程式執行時會發生什麼，哪個陳述是正確的？</strong>  </p>
<p><strong>解題過程</strong>  </p>
<ul>
<li>第2行: <code>mov eax,30</code> 將EAX設為30</li>
<li>第3行: <code>push eax</code> 壓入EAX的值(30)</li>
<li>第4行: <code>push 40</code> 壓入值40</li>
<li>第5行: <code>call Ex3Sub</code> 壓入返回地址，跳轉到Ex3Sub</li>
<li>第10行: <code>pusha</code> 壓入所有暫存器值，包括當前的EAX值</li>
<li>第11行: <code>mov eax,80</code> 將EAX設為80</li>
<li>第12行: <code>popa</code> 恢復所有暫存器的值，包括將EAX恢復到之前的值</li>
<li>第13行: <code>ret</code> 返回到main中</li>
</ul>
<p><strong>答案</strong><br>c. EAX will equal 30 on line 6</p>
<hr>
<h3 id="18-Which-statement-is-true-about-what-will-happen-when-the-example-code-runs"><a href="#18-Which-statement-is-true-about-what-will-happen-when-the-example-code-runs" class="headerlink" title="(18). Which statement is true about what will happen when the example code runs?"></a><strong>(18). Which statement is true about what will happen when the example code runs?</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1: main PROC</span><br><span class="line">2: mov eax,40</span><br><span class="line">3: push offset Here</span><br><span class="line">4: jmp Ex4Sub</span><br><span class="line">5: Here:</span><br><span class="line">6: mov eax,30</span><br><span class="line">7: INVOKE ExitProcess,0</span><br><span class="line">8: main ENDP</span><br><span class="line">9:</span><br><span class="line">10: Ex4Sub PROC</span><br><span class="line">11: ret</span><br><span class="line">12: Ex4Sub ENDP</span><br></pre></td></tr></table></figure>
<p><strong>翻譯：關於範例程式執行時會發生什麼，哪個陳述是正確的？</strong>  </p>
<p><strong>解題過程</strong>  </p>
<ul>
<li>第2行: <code>mov eax,40</code> 將EAX設為40</li>
<li>第3行: <code>push offset Here</code> 壓入Here標籤的地址</li>
<li>第4行: <code>jmp Ex4Sub</code> 跳轉到Ex4Sub</li>
<li>第11行: <code>ret</code> 從堆疊中彈出地址(Here的地址)並跳轉到那裡</li>
<li>第6行: <code>mov eax,30</code> 將EAX設為30</li>
<li>第7行: 結束程式</li>
</ul>
<p><strong>答案</strong><br>a. EAX will equal 30 on line 7</p>
<hr>
<h3 id="19-Which-statement-is-true-about-what-will-happen-when-the-example-code-runs"><a href="#19-Which-statement-is-true-about-what-will-happen-when-the-example-code-runs" class="headerlink" title="(19). Which statement is true about what will happen when the example code runs?"></a><strong>(19). Which statement is true about what will happen when the example code runs?</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">1: main PROC</span><br><span class="line">2: mov edx,0</span><br><span class="line">3: mov eax,40</span><br><span class="line">4: push eax</span><br><span class="line">5: call Ex5Sub</span><br><span class="line">6: INVOKE ExitProcess,0</span><br><span class="line">7: main ENDP</span><br><span class="line">8:</span><br><span class="line">9: Ex5Sub PROC</span><br><span class="line">10: pop eax</span><br><span class="line">11: pop edx</span><br><span class="line">12: push eax</span><br><span class="line">13: ret</span><br><span class="line">14: Ex5Sub ENDP</span><br></pre></td></tr></table></figure>
<p><strong>翻譯：關於範例程式執行時會發生什麼，哪個陳述是正確的？</strong>  </p>
<p><strong>解題過程</strong>  </p>
<ul>
<li>第2行: <code>mov edx,0</code> 將EDX設為0</li>
<li>第3行: <code>mov eax,40</code> 將EAX設為40</li>
<li>第4行: <code>push eax</code> 壓入EAX的值(40)</li>
<li>第5行: <code>call Ex5Sub</code> 壓入返回地址，跳轉到Ex5Sub</li>
<li>第10行: <code>pop eax</code> 將返回地址彈出到EAX</li>
<li>第11行: <code>pop edx</code> 嘗試將堆疊上的下一個值(40)彈出到EDX</li>
<li>第12行: <code>push eax</code> 壓入之前保存的返回地址</li>
<li>第13行: <code>ret</code> 返回到main中</li>
</ul>
<p><strong>答案</strong><br>a. EDX will equal 40 on line 6</p>
<hr>
<h3 id="20-What-values-will-be-written-to-the-array-when-the-following-code-executes"><a href="#20-What-values-will-be-written-to-the-array-when-the-following-code-executes" class="headerlink" title="(20). What values will be written to the array when the following code executes?"></a><strong>(20). What values will be written to the array when the following code executes?</strong></h3><p><strong>翻譯：當下列程式執行時，哪些值會被寫入陣列？</strong>  </p>
<p><strong>解題過程</strong><br>追蹤程式執行：</p>
<ol>
<li>main開始，EAX&#x3D;10，ESI&#x3D;0</li>
<li>呼叫proc_1</li>
<li>proc_1呼叫proc_2</li>
<li>proc_2呼叫proc_3</li>
<li>proc_3將array[0]&#x3D;10，返回</li>
<li>proc_2執行：ESI&#x3D;4，EAX&#x3D;20，array[4]&#x3D;20，返回</li>
<li>proc_1執行：ESI&#x3D;8，EAX&#x3D;30，array[8]&#x3D;30，返回</li>
<li>main繼續：ESI&#x3D;12，EAX&#x3D;40，array[12]&#x3D;40</li>
</ol>
<p><strong>答案</strong><br>array[0]&#x3D;10, array[4]&#x3D;20, array[8]&#x3D;30, array[12]&#x3D;40</p>
<h2 id="5-8-2-演算法實戰-Algorithm-Workbench"><a href="#5-8-2-演算法實戰-Algorithm-Workbench" class="headerlink" title="5.8.2 演算法實戰 (Algorithm Workbench)"></a><strong>5.8.2 演算法實戰 (Algorithm Workbench)</strong></h2><h3 id="2-Suppose-you-wanted-a-subroutine-to-return-to-an-address-that-was-3-bytes-higher-in-memory-than-the-return-address-currently-on-the-stack-Write-a-sequence-of-instructions-that-would-be-inserted-just-before-the-subroutine’s-RET-instruction-that-accomplish-this-task"><a href="#2-Suppose-you-wanted-a-subroutine-to-return-to-an-address-that-was-3-bytes-higher-in-memory-than-the-return-address-currently-on-the-stack-Write-a-sequence-of-instructions-that-would-be-inserted-just-before-the-subroutine’s-RET-instruction-that-accomplish-this-task" class="headerlink" title="(2). Suppose you wanted a subroutine to return to an address that was 3 bytes higher in memory than the return address currently on the stack. Write a sequence of instructions that would be inserted just before the subroutine’s RET instruction that accomplish this task."></a><strong>(2). Suppose you wanted a subroutine to return to an address that was 3 bytes higher in memory than the return address currently on the stack. Write a sequence of instructions that would be inserted just before the subroutine’s RET instruction that accomplish this task.</strong></h3><p><strong>翻譯：假設你希望子程序返回到比當前堆疊上的返回地址高3個位元組的地址。寫一個指令序列，插入在子程序的RET指令之前，完成這個任務。</strong>  </p>
<p><strong>答案</strong>  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pop eax            ; 將返回地址彈出到EAX</span><br><span class="line">add eax, 3         ; 將地址加3</span><br><span class="line">push eax           ; 將修改後的地址壓回堆疊</span><br><span class="line">ret                ; 正常返回，使用修改後的地址</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="4-Write-a-sequence-of-statements-using-indexed-addressing-that-copies-an-element-in-a-doubleword-array-to-the-previous-position-in-the-same-array"><a href="#4-Write-a-sequence-of-statements-using-indexed-addressing-that-copies-an-element-in-a-doubleword-array-to-the-previous-position-in-the-same-array" class="headerlink" title="(4). Write a sequence of statements using indexed addressing that copies an element in a doubleword array to the previous position in the same array."></a><strong>(4). Write a sequence of statements using indexed addressing that copies an element in a doubleword array to the previous position in the same array.</strong></h3><p><strong>翻譯：使用索引定址方式寫一組指令，將雙字元陣列中的一個元素複製到同一陣列中的前一個位置。</strong>  </p>
<p><strong>答案</strong>  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">; 假設ESI指向當前元素的位置</span><br><span class="line">mov eax, [esi]     ; 將當前元素加載到EAX</span><br><span class="line">mov [esi-4], eax   ; 將值複製到前一個位置(減4位元組)</span><br></pre></td></tr></table></figure>
<p>或者使用陣列索引：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">; 假設EDI是陣列的基址，ECX是當前索引</span><br><span class="line">mov eax, [edi+ecx*4]       ; 獲取當前元素</span><br><span class="line">mov [edi+(ecx-1)*4], eax   ; 複製到前一個位置</span><br></pre></td></tr></table></figure>

<h1 id="考試"><a href="#考試" class="headerlink" title="考試"></a>考試</h1><blockquote>
<p> x86處理器組合語言習題翻譯與解答</p>
</blockquote>
<h2 id="第一章：基本概念"><a href="#第一章：基本概念" class="headerlink" title="第一章：基本概念"></a>第一章：基本概念</h2><h3 id="01-In-an-8-bit-binary-number-which-is-the-most-significant-bit-MSB"><a href="#01-In-an-8-bit-binary-number-which-is-the-most-significant-bit-MSB" class="headerlink" title="01. In an 8-bit binary number, which is the most significant bit (MSB)?"></a><strong>01. In an 8-bit binary number, which is the most significant bit (MSB)?</strong></h3><p><strong>翻譯：</strong> 在8位元二進制數中，哪一位是最高有效位(MSB)？</p>
<p><strong>解題過程：</strong><br>最高有效位是二進制數中具有最大位權重的位元，在8位元數中，這是最左邊的位元。</p>
<p><strong>答案：</strong> 最高有效位（編號最高的位元）</p>
<hr>
<h3 id="03-What-is-the-sum-of-each-pair-of-binary-integers"><a href="#03-What-is-the-sum-of-each-pair-of-binary-integers" class="headerlink" title="03. What is the sum of each pair of binary integers?"></a><strong>03. What is the sum of each pair of binary integers?</strong></h3><p>a. 10101111 + 11011011<br>b. 10010111 + 11111111<br>c. 01110101 + 10101100</p>
<p><strong>翻譯：</strong> 下列各對二進制整數的總和是多少？</p>
<p><strong>解題過程：</strong><br>需要按照二進制加法規則，從右到左逐位相加，並處理進位。</p>
<p><strong>答案：</strong> </p>
<ul>
<li>(a) 110001010</li>
<li>(b) 110010110</li>
<li>(c) 100100001</li>
</ul>
<hr>
<h3 id="05-How-many-bits-are-used-by-each-of-the-following-data-types"><a href="#05-How-many-bits-are-used-by-each-of-the-following-data-types" class="headerlink" title="05. How many bits are used by each of the following data types?"></a><strong>05. How many bits are used by each of the following data types?</strong></h3><p>a. word<br>b. doubleword<br>c. quadword<br>d. double quadword</p>
<p><strong>翻譯：</strong> 以下各資料類型使用多少位元？</p>
<p><strong>解題過程：</strong><br>這些是x86架構中的標準資料類型大小：</p>
<ul>
<li>word: 2 bytes &#x3D; 16 bits</li>
<li>doubleword: 4 bytes &#x3D; 32 bits</li>
<li>quadword: 8 bytes &#x3D; 64 bits</li>
<li>double quadword: 16 bytes &#x3D; 128 bits</li>
</ul>
<p><strong>答案：</strong> </p>
<ul>
<li>(a) 16</li>
<li>(b) 32</li>
<li>(c) 64</li>
<li>(d) 128</li>
</ul>
<hr>
<h3 id="07-What-is-the-hexadecimal-representation-of-each-of-the-following-binary-numbers"><a href="#07-What-is-the-hexadecimal-representation-of-each-of-the-following-binary-numbers" class="headerlink" title="07. What is the hexadecimal representation of each of the following binary numbers?"></a><strong>07. What is the hexadecimal representation of each of the following binary numbers?</strong></h3><p>a. 0011 0101 1101 1010<br>b. 1100 1110 1010 0011<br>c. 1111 1110 1101 1011</p>
<p><strong>翻譯：</strong> 下列各二進制數的十六進制表示是什麼？</p>
<p><strong>解題過程：</strong><br>將二進制數每4位分成一組，然後將每組轉換為對應的十六進制數字。</p>
<p><strong>答案：</strong> </p>
<ul>
<li>(a) 35DA</li>
<li>(b) CEA3</li>
<li>(c) FEDB</li>
</ul>
<hr>
<h3 id="09-What-is-the-unsigned-decimal-representation-of-each-of-the-following-hexadecimal-integers"><a href="#09-What-is-the-unsigned-decimal-representation-of-each-of-the-following-hexadecimal-integers" class="headerlink" title="09. What is the unsigned decimal representation of each of the following hexadecimal integers?"></a><strong>09. What is the unsigned decimal representation of each of the following hexadecimal integers?</strong></h3><p>a. 3A<br>b. 1BF<br>c. 1001</p>
<p><strong>翻譯：</strong> 下列各十六進制整數的無符號十進制表示是多少？</p>
<p><strong>解題過程：</strong><br>將十六進制數轉換為十進制：</p>
<ul>
<li>3A &#x3D; 3×16¹ + 10×16⁰ &#x3D; 48 + 10 &#x3D; 58</li>
<li>1BF &#x3D; 1×16² + 11×16¹ + 15×16⁰ &#x3D; 256 + 176 + 15 &#x3D; 447</li>
<li>1001 &#x3D; 1×16³ + 0×16² + 0×16¹ + 1×16⁰ &#x3D; 4096 + 0 + 0 + 1 &#x3D; 4097</li>
</ul>
<p><strong>答案：</strong> </p>
<ul>
<li>(a) 58</li>
<li>(b) 447</li>
<li>(c) 4097</li>
</ul>
<hr>
<h3 id="11-What-is-the-16-bit-hexadecimal-representation-of-each-of-the-following-signed-decimal-integers"><a href="#11-What-is-the-16-bit-hexadecimal-representation-of-each-of-the-following-signed-decimal-integers" class="headerlink" title="11. What is the 16-bit hexadecimal representation of each of the following signed decimal integers?"></a><strong>11. What is the 16-bit hexadecimal representation of each of the following signed decimal integers?</strong></h3><p>a. -24<br>b. -331</p>
<p><strong>翻譯：</strong> 下列各帶符號十進制整數的16位元十六進制表示是什麼？</p>
<p><strong>解題過程：</strong><br>使用二補數表示法：</p>
<ul>
<li>-24：24的二進制是0000 0000 0001 1000，取反得1111 1111 1110 0111，加1得1111 1111 1110 1000，即FFE8</li>
<li>-331：331的二進制是0000 0001 0100 1011，取反得1111 1110 1011 0100，加1得1111 1110 1011 0101，即FEB5</li>
</ul>
<p><strong>答案：</strong> </p>
<ul>
<li>(a) FFE8</li>
<li>(b) FEB5</li>
</ul>
<hr>
<h3 id="13-The-following-16-bit-hexadecimal-numbers-represent-signed-integers-Convert-each-to-decimal"><a href="#13-The-following-16-bit-hexadecimal-numbers-represent-signed-integers-Convert-each-to-decimal" class="headerlink" title="13. The following 16-bit hexadecimal numbers represent signed integers. Convert each to decimal."></a><strong>13. The following 16-bit hexadecimal numbers represent signed integers. Convert each to decimal.</strong></h3><p>a. 6BF9<br>b. C123</p>
<p><strong>翻譯：</strong> 下列16位元十六進制數表示帶符號整數。將它們轉換為十進制。</p>
<p><strong>解題過程：</strong><br>檢查最高位來判斷正負：</p>
<ul>
<li>6BF9：首位是6，小於8，所以是正數。直接轉換：6BF9 &#x3D; 27641</li>
<li>C123：首位是C (12)，大於等於8，所以是負數。計算其二補數：<ul>
<li>取反：3EDC</li>
<li>加1：3EDD</li>
<li>轉換為十進制：16093</li>
<li>加負號：-16093</li>
</ul>
</li>
</ul>
<p><strong>答案：</strong> </p>
<ul>
<li>(a) 27641</li>
<li>(b) -16093</li>
</ul>
<hr>
<h3 id="15-What-is-the-decimal-representation-of-each-of-the-following-signed-binary-numbers"><a href="#15-What-is-the-decimal-representation-of-each-of-the-following-signed-binary-numbers" class="headerlink" title="15. What is the decimal representation of each of the following signed binary numbers? &lt;6th Edition&gt;"></a><strong>15. What is the decimal representation of each of the following signed binary numbers? &lt;6th Edition&gt;</strong></h3><p>a. 10110101<br>b. 00101010<br>c. 11110000</p>
<p><strong>翻譯：</strong> 下列帶符號二進制數的十進制表示是什麼？&lt;第6版&gt;</p>
<p><strong>解題過程：</strong><br>檢查最高位來判斷正負：</p>
<ul>
<li>10110101：首位是1，所以是負數。計算其二補數：<ul>
<li>取反：01001010</li>
<li>加1：01001011 &#x3D; 75</li>
<li>加負號：-75</li>
</ul>
</li>
<li>00101010：首位是0，所以是正數。直接轉換：00101010 &#x3D; 42</li>
<li>11110000：首位是1，所以是負數。計算其二補數：<ul>
<li>取反：00001111</li>
<li>加1：00010000 &#x3D; 16</li>
<li>加負號：-16</li>
</ul>
</li>
</ul>
<p><strong>答案：</strong> </p>
<ul>
<li>(a) -75</li>
<li>(b) +42</li>
<li>(c) -16</li>
</ul>
<hr>
<p>繼續為您翻譯解答其餘題目：</p>
<h3 id="15-What-is-the-binary-sum-of-the-following-decimal-numbers-Express-the-sum-of-the-following-numbers-in-binary"><a href="#15-What-is-the-binary-sum-of-the-following-decimal-numbers-Express-the-sum-of-the-following-numbers-in-binary" class="headerlink" title="15. What is the binary sum of the following decimal numbers? Express the sum of the following numbers in binary."></a><strong>15. What is the binary sum of the following decimal numbers? Express the sum of the following numbers in binary.</strong></h3><p>a. 15 and 35<br>b. 78 and 678<br>c. 345 and 567</p>
<p><strong>翻譯：</strong> 下列十進制數的二進制總和是多少？用二進制表示以下數字的總和。</p>
<p><strong>解題過程：</strong><br>首先將各數轉換為二進制，然後相加：</p>
<ul>
<li>15 &#x3D; 1111(二進制)，35 &#x3D; 100011(二進制)<br>1111 + 100011 &#x3D; 110010</li>
<li>78 &#x3D; 1001110(二進制)，678 &#x3D; 1010100110(二進制)<br>1001110 + 1010100110 &#x3D; 1011110100</li>
<li>345 &#x3D; 101011001(二進制)，567 &#x3D; 1000110111(二進制)<br>101011001 + 1000110111 &#x3D; 1110010000</li>
</ul>
<p><strong>答案：</strong></p>
<ul>
<li>(a) 1111 + 100011 &#x3D; 110010</li>
<li>(b) 1001110 + 1010100110 &#x3D; 1011110100</li>
<li>(c) 101011001 + 1000110111 &#x3D; 1110010000</li>
</ul>
<hr>
<h3 id="17-What-is-the-8-bit-binary-two’s-complement-representation-of-each-of-the-following-signed-decimal-integers"><a href="#17-What-is-the-8-bit-binary-two’s-complement-representation-of-each-of-the-following-signed-decimal-integers" class="headerlink" title="17. What is the 8-bit binary (two’s-complement) representation of each of the following signed decimal integers?"></a><strong>17. What is the 8-bit binary (two’s-complement) representation of each of the following signed decimal integers?</strong></h3><p>a. -5<br>b. -42<br>c. -16</p>
<p><strong>翻譯：</strong> 下列各帶符號十進制整數的8位元二進制(二補數)表示是什麼？</p>
<p><strong>解題過程：</strong><br>使用二補數表示法：</p>
<ul>
<li>-5：5的二進制是0000 0101，取反得1111 1010，加1得1111 1011</li>
<li>-42：42的二進制是0010 1010，取反得1101 0101，加1得1101 0110</li>
<li>-16：16的二進制是0001 0000，取反得1110 1111，加1得1111 0000</li>
</ul>
<p><strong>答案：</strong></p>
<ul>
<li>(a) 11111011</li>
<li>(b) 11010110</li>
<li>(c) 11110000</li>
</ul>
<hr>
<h3 id="19-The-following-hexadecimal-two’s-complement-numbers-are-signed-integers-please-convert-to-decimal-numbers"><a href="#19-The-following-hexadecimal-two’s-complement-numbers-are-signed-integers-please-convert-to-decimal-numbers" class="headerlink" title="19. The following hexadecimal (two’s complement) numbers are signed integers, please convert to decimal numbers."></a><strong>19. The following hexadecimal (two’s complement) numbers are signed integers, please convert to decimal numbers.</strong></h3><p>a. FEE2h<br>b. F3h</p>
<p><strong>翻譯：</strong> 下列十六進制(二補數)數是帶符號整數，請轉換為十進制數。</p>
<p><strong>解題過程：</strong><br>檢查最高位來判斷正負：</p>
<ul>
<li>FEE2h：首位是F(15)，大於等於8，所以是負數。計算其二補數：<ul>
<li>取反：011D</li>
<li>加1：011E &#x3D; 286</li>
<li>加負號：-286</li>
</ul>
</li>
<li>F3h：首位是F(15)，大於等於8，所以是負數。計算其二補數：<ul>
<li>取反：0C</li>
<li>加1：0D &#x3D; 13</li>
<li>加負號：-13</li>
</ul>
</li>
</ul>
<p><strong>答案：</strong></p>
<ul>
<li>(a) -286</li>
<li>(b) -13</li>
</ul>
<hr>
<h3 id="19-What-is-the-sum-of-each-pair-of-hexadecimal-integers"><a href="#19-What-is-the-sum-of-each-pair-of-hexadecimal-integers" class="headerlink" title="19. What is the sum of each pair of hexadecimal integers?"></a><strong>19. What is the sum of each pair of hexadecimal integers?</strong></h3><p>a. 6B4 + 3FE<br>b. A49 + 6BD</p>
<p><strong>翻譯：</strong> 下列各對十六進制整數的總和是多少？</p>
<p><strong>解題過程：</strong><br>將十六進制數相加：</p>
<ul>
<li>6B4 + 3FE：<ul>
<li>4 + E &#x3D; 12 &#x3D; C (進位1)</li>
<li>B + F + 1 &#x3D; 11 + 15 + 1 &#x3D; 27 &#x3D; 1B (進位1)</li>
<li>6 + 3 + 1 &#x3D; 10 &#x3D; A</li>
<li>結果為AB2</li>
</ul>
</li>
<li>A49 + 6BD：<ul>
<li>9 + D &#x3D; 16 &#x3D; 10 (進位1)</li>
<li>4 + B + 1 &#x3D; 4 + 11 + 1 &#x3D; 16 &#x3D; 0 (進位1)</li>
<li>A + 6 + 1 &#x3D; 10 + 6 + 1 &#x3D; 17 &#x3D; 11</li>
<li>結果為1106</li>
</ul>
</li>
</ul>
<p><strong>答案：</strong></p>
<ul>
<li>(a) AB2</li>
<li>(b) 1106</li>
</ul>
<hr>
<h3 id="21-What-are-the-hexadecimal-and-decimal-representations-of-the-ASCII-character-capital-B"><a href="#21-What-are-the-hexadecimal-and-decimal-representations-of-the-ASCII-character-capital-B" class="headerlink" title="21. What are the hexadecimal and decimal representations of the ASCII character capital B?"></a><strong>21. What are the hexadecimal and decimal representations of the ASCII character capital B?</strong></h3><p><strong>翻譯：</strong> ASCII字符大寫B的十六進制和十進制表示是什麼？</p>
<p><strong>解題過程：</strong><br>在ASCII碼表中，大寫字母B對應的值是66十進制，或42十六進制。</p>
<p><strong>答案：</strong> 42h 和 66d</p>
<hr>
<h3 id="21-What-are-the-hexadecimal-and-decimal-representations-of-the-ASCII-characters-and"><a href="#21-What-are-the-hexadecimal-and-decimal-representations-of-the-ASCII-characters-and" class="headerlink" title="21. What are the hexadecimal and decimal representations of the ASCII characters &amp; and $?"></a><strong>21. What are the hexadecimal and decimal representations of the ASCII characters &amp; and $?</strong></h3><p><strong>翻譯：</strong> ASCII字符&amp;和$的十六進制和十進制表示是什麼？</p>
<p><strong>解題過程：</strong><br>在ASCII碼表中：</p>
<ul>
<li>&amp;對應38十進制，或26十六進制</li>
<li>$對應36十進制，或24十六進制</li>
</ul>
<p><strong>答案：</strong> &amp; &#x3D; 26H(38d); $ &#x3D; 24H(36d)</p>
<hr>
<h3 id="23-Challenge-What-is-the-largest-decimal-value-you-can-represent-using-a-129-bit-unsigned-integer"><a href="#23-Challenge-What-is-the-largest-decimal-value-you-can-represent-using-a-129-bit-unsigned-integer" class="headerlink" title="23. Challenge: What is the largest decimal value you can represent, using a 129-bit unsigned integer?"></a><strong>23. Challenge: What is the largest decimal value you can represent, using a 129-bit unsigned integer?</strong></h3><p><strong>翻譯：</strong> 挑戰：使用129位元無符號整數，你可以表示的最大十進制值是多少？</p>
<p><strong>解題過程：</strong><br>129位元無符號整數的最大值是2^129 - 1。</p>
<p><strong>答案：</strong> 2^129 - 1，或約6.8056473384187692692674921486353 × 10^38</p>
<hr>
<h3 id="24-Challenge-What-is-the-largest-decimal-value-you-can-represent-using-a-86-bit-signed-integer"><a href="#24-Challenge-What-is-the-largest-decimal-value-you-can-represent-using-a-86-bit-signed-integer" class="headerlink" title="24. Challenge: What is the largest decimal value you can represent, using a 86-bit signed integer?"></a><strong>24. Challenge: What is the largest decimal value you can represent, using a 86-bit signed integer?</strong></h3><p><strong>翻譯：</strong> 挑戰：使用86位元帶符號整數，你可以表示的最大十進制值是多少？</p>
<p><strong>解題過程：</strong><br>n位元帶符號整數的最大值是2^(n-1) - 1。對於86位元，最大值是2^85 - 1。</p>
<p><strong>答案：</strong> 2^85 - 1</p>
<hr>
<h3 id="25-Create-a-truth-table-to-show-all-possible-inputs-and-outputs-for-the-Boolean-function-described-by-A∨B-¬A-∧-¬B"><a href="#25-Create-a-truth-table-to-show-all-possible-inputs-and-outputs-for-the-Boolean-function-described-by-A∨B-¬A-∧-¬B" class="headerlink" title="25. Create a truth table to show all possible inputs and outputs for the Boolean function described by -(A∨B) &amp; (¬A ∧ ¬B)."></a><strong>25. Create a truth table to show all possible inputs and outputs for the Boolean function described by -(A∨B) &amp; (¬A ∧ ¬B).</strong></h3><p><strong>翻譯：</strong> 建立一個真值表，顯示布林函數-(A∨B) &amp; (¬A ∧ ¬B)的所有可能輸入和輸出。</p>
<p><strong>解題過程：</strong><br>分析函數-(A∨B) &amp; (¬A ∧ ¬B)：</p>
<ul>
<li>-(A∨B)是指NOT(A OR B)，等同於¬A ∧ ¬B (德摩根定律)</li>
<li>(¬A ∧ ¬B)是指NOT A AND NOT B</li>
<li>整個表達式可以簡化為(¬A ∧ ¬B) &amp; (¬A ∧ ¬B)，即(¬A ∧ ¬B)</li>
</ul>
<p><strong>答案：</strong><br>建立真值表：</p>
<table>
<thead>
<tr>
<th>A</th>
<th>B</th>
<th>A ∨ B</th>
<th>-(A ∨ B)</th>
<th>¬A</th>
<th>¬B</th>
<th>¬A ∧ ¬B</th>
<th>-(A∨B) &amp; (¬A ∧ ¬B)</th>
</tr>
</thead>
<tbody><tr>
<td>F</td>
<td>F</td>
<td>F</td>
<td>T</td>
<td>T</td>
<td>T</td>
<td>T</td>
<td>T</td>
</tr>
<tr>
<td>F</td>
<td>T</td>
<td>T</td>
<td>F</td>
<td>T</td>
<td>F</td>
<td>F</td>
<td>F</td>
</tr>
<tr>
<td>T</td>
<td>F</td>
<td>T</td>
<td>F</td>
<td>F</td>
<td>T</td>
<td>F</td>
<td>F</td>
</tr>
<tr>
<td>T</td>
<td>T</td>
<td>T</td>
<td>F</td>
<td>F</td>
<td>F</td>
<td>F</td>
<td>F</td>
</tr>
</tbody></table>
<hr>
<h3 id="26-How-would-you-describe-the-rightmost-column-of-this-table-in-relation-to-the-table-from-question-number-25"><a href="#26-How-would-you-describe-the-rightmost-column-of-this-table-in-relation-to-the-table-from-question-number-25" class="headerlink" title="26. How would you describe the rightmost column of this table in relation to the table from question number 25?"></a><strong>26. How would you describe the rightmost column of this table in relation to the table from question number 25?</strong></h3><p><strong>翻譯：</strong> 你如何描述這個表格的最右欄與問題25中表格的關係？</p>
<p><strong>解題過程：</strong><br>觀察問題25的真值表，發現-(A∨B) &amp; (¬A ∧ ¬B)的結果列與¬A ∧ ¬B的結果列完全相同，這說明這兩個表達式在邏輯上是等價的。</p>
<p><strong>答案：</strong><br>最右欄的結果與¬A ∧ ¬B相同，表明整個表達式-(A∨B) &amp; (¬A ∧ ¬B)可以簡化為¬A ∧ ¬B。</p>
<hr>
<h3 id="27-If-a-Boolean-function-has-four-inputs-how-many-rows-are-required-for-its-truth-table"><a href="#27-If-a-Boolean-function-has-four-inputs-how-many-rows-are-required-for-its-truth-table" class="headerlink" title="27. If a Boolean function has four inputs, how many rows are required for its truth table?"></a><strong>27. If a Boolean function has four inputs, how many rows are required for its truth table?</strong></h3><p><strong>翻譯：</strong> 如果一個布林函數有四個輸入，其真值表需要多少行？</p>
<p><strong>解題過程：</strong><br>一個有n個輸入的布林函數，其真值表需要2^n行。</p>
<p><strong>答案：</strong> 需要2^4 (16)行。</p>
<hr>
<h3 id="28-Please-make-a-truth-table-with-three-inputs-and-one-output-based-on-the-following-logical-operators"><a href="#28-Please-make-a-truth-table-with-three-inputs-and-one-output-based-on-the-following-logical-operators" class="headerlink" title="28. Please make a truth table with three inputs and one output based on the following logical operators."></a><strong>28. Please make a truth table with three inputs and one output based on the following logical operators.</strong></h3><p>a. AND<br>b. XOR<br>c. NAND<br>Consider that A, B and C are the inputs, and Y is the output.</p>
<p><strong>翻譯：</strong> 請根據以下邏輯運算符製作一個有三個輸入和一個輸出的真值表。<br>a. AND<br>b. XOR<br>c. NAND<br>考慮A、B和C是輸入，Y是輸出。</p>
<p><strong>解題過程：</strong><br>為每種邏輯運算符創建真值表：<br>a. AND：只有所有輸入都為1時，輸出才為1<br>b. XOR：輸入中有奇數個1時，輸出為1<br>c. NAND：AND的結果取反，即除非所有輸入都為1，否則輸出為1</p>
<p><strong>答案：</strong><br>a. AND真值表：</p>
<table>
<thead>
<tr>
<th>A</th>
<th>B</th>
<th>C</th>
<th>Y (A AND B AND C)</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
</tbody></table>
<p>b. XOR真值表：</p>
<table>
<thead>
<tr>
<th>A</th>
<th>B</th>
<th>C</th>
<th>Y (A XOR B XOR C)</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
</tbody></table>
<p>c. NAND真值表：</p>
<table>
<thead>
<tr>
<th>A</th>
<th>B</th>
<th>C</th>
<th>Y (NOT(A AND B AND C))</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>1</td>
<td>0</td>
</tr>
</tbody></table>
<hr>
<h2 id="第二章：x86處理器架構"><a href="#第二章：x86處理器架構" class="headerlink" title="第二章：x86處理器架構"></a>第二章：x86處理器架構</h2><h3 id="01-What-special-purpose-does-the-ECX-register-serve-p-2-11"><a href="#01-What-special-purpose-does-the-ECX-register-serve-p-2-11" class="headerlink" title="01. What special purpose does the ECX register serve? (p. 2-11)"></a><strong>01. What special purpose does the ECX register serve? (p. 2-11)</strong></h3><p><strong>翻譯：</strong> ECX暫存器有什麼特殊用途？(p. 2-11)</p>
<p><strong>解題過程：</strong><br>在x86架構中，ECX暫存器經常被用作迴圈計數器，特別是在使用LOOP指令時。</p>
<p><strong>答案：</strong><br>迴圈計數器：在電腦程式設計中，迴圈計數器是控制迴圈迭代次數的變數(一種電腦程式語言結構)。</p>
<hr>
<h3 id="02-Describe-VRAM-p-2-16"><a href="#02-Describe-VRAM-p-2-16" class="headerlink" title="02. Describe VRAM. (p. 2-16)"></a><strong>02. Describe VRAM. (p. 2-16)</strong></h3><p><strong>翻譯：</strong> 描述VRAM。(p. 2-16)</p>
<p><strong>解題過程：</strong><br>VRAM（Video RAM）是一種專門用於儲存顯示器影像資料的記憶體。</p>
<p><strong>答案：</strong><br>Video RAM（影像RAM）<br>VRAM（影像RAM）指的是專門用於儲存電腦顯示器影像資料的任何類型隨機存取記憶體(RAM)。</p>
<hr>
<h3 id="03-Is-it-likely-that-the-BIOS-for-a-computer-running-MS-Windows-would-be-different-from-that-used-by-a-computer-running-Linux-p-2-19"><a href="#03-Is-it-likely-that-the-BIOS-for-a-computer-running-MS-Windows-would-be-different-from-that-used-by-a-computer-running-Linux-p-2-19" class="headerlink" title="03. Is it likely that the BIOS for a computer running MS-Windows would be different from that used by a computer running Linux? (p. 2-19)"></a><strong>03. Is it likely that the BIOS for a computer running MS-Windows would be different from that used by a computer running Linux? (p. 2-19)</strong></h3><p><strong>翻譯：</strong> 執行MS-Windows的電腦與執行Linux的電腦所使用的BIOS很可能不同嗎？(p. 2-19)</p>
<p><strong>解題過程：</strong><br>BIOS（基本輸入&#x2F;輸出系統）是與硬體直接交互的低層級軟體，其功能與作業系統無關。無論電腦運行哪種作業系統，只要基礎硬體相同，就可以使用相同的BIOS。</p>
<p><strong>答案：</strong><br>相同的BIOS可以用於兩種作業系統。</p>
<hr>
<h3 id="B-2-8-Short-Answer"><a href="#B-2-8-Short-Answer" class="headerlink" title="B. 2.8 Short Answer"></a><strong>B. 2.8 Short Answer</strong></h3><h3 id="01-In-32-bit-mode-aside-from-the-stack-pointer-ESP-what-other-register-points-to-variables-on-the-stack"><a href="#01-In-32-bit-mode-aside-from-the-stack-pointer-ESP-what-other-register-points-to-variables-on-the-stack" class="headerlink" title="01. In 32-bit mode, aside from the stack pointer (ESP), what other register points to variables on the stack?"></a><strong>01. In 32-bit mode, aside from the stack pointer (ESP), what other register points to variables on the stack?</strong></h3><p><strong>翻譯：</strong> 在32位元模式下，除了堆疊指標(ESP)外，還有哪個暫存器指向堆疊上的變數？</p>
<p><strong>解題過程：</strong><br>在x86架構中，基底指標暫存器(EBP)通常用於存取堆疊框架中的局部變數和參數。</p>
<p><strong>答案：</strong><br>EBP &lt; 當前堆疊框架的基底指標。當函數被呼叫時，會在堆疊上保留一些空間用於局部變數，這些變數通過EBP來引用。&gt;</p>
<hr>
<h3 id="03-What-flags-will-be-set-when-56h-and-121h-are-added"><a href="#03-What-flags-will-be-set-when-56h-and-121h-are-added" class="headerlink" title="03. What flags will be set when 56h and 121h are added."></a><strong>03. What flags will be set when 56h and 121h are added.</strong></h3><p><strong>翻譯：</strong> 當56h和121h相加時，哪些旗標會被設置？</p>
<p><strong>解題過程：</strong><br>計算56h + 121h &#x3D; 177h<br>對於16位元加法，這個結果不會設置任何旗標，因為結果沒有進位、溢位等特殊情況。</p>
<p><strong>答案：</strong><br>對於16位元加法，沒有旗標被設置。</p>
<hr>
<h3 id="03-Which-flag-is-set-when-the-result-of-an-unsigned-arithmetic-operation-is-too-large-to-fit-into-the-destination"><a href="#03-Which-flag-is-set-when-the-result-of-an-unsigned-arithmetic-operation-is-too-large-to-fit-into-the-destination" class="headerlink" title="03. Which flag is set when the result of an unsigned arithmetic operation is too large to fit into the destination?"></a><strong>03. Which flag is set when the result of an unsigned arithmetic operation is too large to fit into the destination?</strong></h3><p><strong>翻譯：</strong> 當無符號算術運算的結果太大而無法放入目標位置時，哪個旗標會被設置？</p>
<p><strong>解題過程：</strong><br>當無符號數運算結果超出目標暫存器容量時，會設置進位旗標(Carry Flag)。</p>
<p><strong>答案：</strong><br>進位旗標(Carry flag)&lt;P.2-9&gt;</p>
<hr>
<h3 id="04-Which-flag-is-set-when-the-result-of-a-signed-arithmetic-operation-is-either-too-large-or-too-small-to-fit-into-the-destination"><a href="#04-Which-flag-is-set-when-the-result-of-a-signed-arithmetic-operation-is-either-too-large-or-too-small-to-fit-into-the-destination" class="headerlink" title="04. Which flag is set when the result of a signed arithmetic operation is either too large or too small to fit into the destination?"></a><strong>04. Which flag is set when the result of a signed arithmetic operation is either too large or too small to fit into the destination?</strong></h3><p><strong>翻譯：</strong> 當有符號算術運算的結果太大或太小而無法放入目標位置時，哪個旗標會被設置？</p>
<p><strong>解題過程：</strong><br>當有符號數運算結果超出目標暫存器容量時，會設置溢位旗標(Overflow Flag)。</p>
<p><strong>答案：</strong><br>溢位旗標(Overflow flag)&lt;P.2-9&gt;</p>
<hr>
<h3 id="05-True-False-When-a-register-operand-size-is-32-bits-and-the-REX-prefix-is-used-the-R8D-register-is-available-for-programs-to-use"><a href="#05-True-False-When-a-register-operand-size-is-32-bits-and-the-REX-prefix-is-used-the-R8D-register-is-available-for-programs-to-use" class="headerlink" title="05. (True&#x2F;False): When a register operand size is 32 bits and the REX prefix is used, the R8D register is available for programs to use."></a><strong>05. (True&#x2F;False): When a register operand size is 32 bits and the REX prefix is used, the R8D register is available for programs to use.</strong></h3><p><strong>翻譯：</strong> (判斷題)：當暫存器操作數大小為32位元且使用REX前綴時，R8D暫存器可供程式使用。</p>
<p><strong>解題過程：</strong><br>REX前綴是在x64架構中使用的，它允許存取額外的暫存器，包括R8D-R15D。</p>
<p><strong>答案：</strong><br>True &lt;p.2-13&gt;</p>
<hr>
<h3 id="07-Which-part-of-the-CPU-performs-floating-point-arithmetic"><a href="#07-Which-part-of-the-CPU-performs-floating-point-arithmetic" class="headerlink" title="07. Which part of the CPU performs floating-point arithmetic?"></a><strong>07. Which part of the CPU performs floating-point arithmetic?</strong></h3><p><strong>翻譯：</strong> CPU的哪個部分執行浮點算術運算？</p>
<p><strong>解題過程：</strong><br>在現代處理器中，浮點運算是由浮點單元(Floating-Point Unit, FPU)處理的。</p>
<p><strong>答案：</strong><br>浮點單元(Floating-point unit)</p>
<hr>
<h3 id="08-On-a-32-bit-processor-how-many-bits-are-contained-in-each-floating-point-data-register"><a href="#08-On-a-32-bit-processor-how-many-bits-are-contained-in-each-floating-point-data-register" class="headerlink" title="08. On a 32-bit processor, how many bits are contained in each floating-point data register?"></a><strong>08. On a 32-bit processor, how many bits are contained in each floating-point data register?</strong></h3><p><strong>翻譯：</strong> 在32位元處理器上，每個浮點資料暫存器包含多少位元？</p>
<p><strong>解題過程：</strong><br>在x86架構中，雖然是32位元處理器，但浮點寄存器使用80位元來提供更高的精度。</p>
<p><strong>答案：</strong><br>80位元</p>
<hr>
<h3 id="09-True-or-False-Only-in-the-lowest-byte-the-parity-flag-will-be-set"><a href="#09-True-or-False-Only-in-the-lowest-byte-the-parity-flag-will-be-set" class="headerlink" title="09. (True or False): Only in the lowest byte, the parity flag will be set."></a><strong>09. (True or False): Only in the lowest byte, the parity flag will be set.</strong></h3><p><strong>翻譯：</strong> (判斷題)：只有在最低字節中，同位旗標才會被設置。</p>
<p><strong>解題過程：</strong><br>在x86架構中，同位旗標(Parity Flag)只反映最低字節中1的個數是否為偶數。</p>
<p><strong>答案：</strong><br>True</p>
<hr>
<h3 id="11-True-False-The-Itanium-instruction-set-is-completely-different-from-the-x86-instruction-set"><a href="#11-True-False-The-Itanium-instruction-set-is-completely-different-from-the-x86-instruction-set" class="headerlink" title="11. (True&#x2F;False): The Itanium instruction set is completely different from the x86 instruction set."></a><strong>11. (True&#x2F;False): The Itanium instruction set is completely different from the x86 instruction set.</strong></h3><p><strong>翻譯：</strong> (判斷題)：Itanium指令集與x86指令集完全不同。</p>
<p><strong>解題過程：</strong><br>Itanium使用的是EPIC(明確並行指令計算)架構，其指令集與x86指令集確實完全不同。</p>
<p><strong>答案：</strong><br>True</p>
<hr>
<h3 id="13-True-False-The-64-bit-RDI-register-is-available-when-the-REX-prefix-is-used"><a href="#13-True-False-The-64-bit-RDI-register-is-available-when-the-REX-prefix-is-used" class="headerlink" title="13. (True&#x2F;False): The 64-bit RDI register is available when the REX prefix is used."></a><strong>13. (True&#x2F;False): The 64-bit RDI register is available when the REX prefix is used.</strong></h3><p><strong>翻譯：</strong> (判斷題)：使用REX前綴時，64位元RDI暫存器可用。</p>
<p><strong>解題過程：</strong><br>在x64模式下，使用REX前綴時可以存取64位元暫存器，包括RDI。</p>
<p><strong>答案：</strong><br>True</p>
<hr>
<h3 id="15-True-False-The-x86-64-processors-have-4-more-general-purpose-registers-than-the-x86-processors"><a href="#15-True-False-The-x86-64-processors-have-4-more-general-purpose-registers-than-the-x86-processors" class="headerlink" title="15. (True&#x2F;False): The x86-64 processors have 4 more general-purpose registers than the x86 processors."></a><strong>15. (True&#x2F;False): The x86-64 processors have 4 more general-purpose registers than the x86 processors.</strong></h3><p><strong>翻譯：</strong> (判斷題)：x86-64處理器比x86處理器多4個通用暫存器。</p>
<p><strong>解題過程：</strong><br>實際上，x86-64處理器比x86處理器多8個通用暫存器(R8-R15)，而不是4個。</p>
<p><strong>答案：</strong><br>False<br>因為x86-64處理器比x86處理器多八個通用暫存器，分別是R8D、R9D、R10D、R11D、R12D、R13D、R14D和R15D。</p>
<hr>
<h3 id="17-True-False-DRAM-can-only-be-erased-using-ultraviolet-light"><a href="#17-True-False-DRAM-can-only-be-erased-using-ultraviolet-light" class="headerlink" title="17. (True&#x2F;False): DRAM can only be erased using ultraviolet light."></a><strong>17. (True&#x2F;False): DRAM can only be erased using ultraviolet light.</strong></h3><p><strong>翻譯：</strong> (判斷題)：DRAM只能使用紫外線清除。</p>
<p><strong>解題過程：</strong><br>DRAM(動態隨機存取記憶體)不需要紫外線清除。需要用紫外線清除的是EPROM(可擦除可程式唯讀記憶體)。</p>
<p><strong>答案：</strong><br>False<br>DRAM不能用紫外線清除。用紫外線清除的是可擦除唯讀記憶體。</p>
<hr>
<h3 id="19-True-or-False-Entity-mode-of-operation-is-no-longer-used-on-64-bit-x86-64-processors"><a href="#19-True-or-False-Entity-mode-of-operation-is-no-longer-used-on-64-bit-x86-64-processors" class="headerlink" title="19. (True or False): Entity mode of operation is no longer used on 64-bit x86-64 processors."></a><strong>19. (True or False): Entity mode of operation is no longer used on 64-bit x86-64 processors.</strong></h3><p><strong>翻譯：</strong> (判斷題)：實體模式操作在64位元x86-64處理器上不再使用。</p>
<p><strong>解題過程：</strong><br>x86-64處理器不再使用實體模式(Entity mode)操作。</p>
<p><strong>答案：</strong><br>True</p>
<hr>
<h3 id="21-True-or-False-A-chipset-is-a-group-of-chips-that-controls-the-display-output-of-a-computer-system"><a href="#21-True-or-False-A-chipset-is-a-group-of-chips-that-controls-the-display-output-of-a-computer-system" class="headerlink" title="21. (True or False): A chipset is a group of chips that controls the display output of a computer system."></a><strong>21. (True or False): A chipset is a group of chips that controls the display output of a computer system.</strong></h3><p><strong>翻譯：</strong> (判斷題)：晶片組是控制電腦系統顯示輸出的一組晶片。</p>
<p><strong>解題過程：</strong><br>晶片組實際上是控制處理器、記憶體與外設之間資料流的一組電子元件，並非專門控制顯示輸出。</p>
<p><strong>答案：</strong><br>False<br>晶片組是一組位於一個或多個集成電路上的電子元件，管理處理器、記憶體和外設之間的資料流。</p>
<hr>
<h3 id="22-The-8259A-is-a-that-handles-external-interrupts-from-hardware-devices"><a href="#22-The-8259A-is-a-that-handles-external-interrupts-from-hardware-devices" class="headerlink" title="22. The 8259A is a _________ that handles external interrupts from hardware devices."></a><strong>22. The 8259A is a _________ that handles external interrupts from hardware devices.</strong></h3><p>(A) Loader (B) Fetch operands (C) Register (D) Controller (E) Accumulator 。</p>
<p><strong>翻譯：</strong> 8259A是一個_________，處理來自硬體裝置的外部中斷。<br>(A) 載入器 (B) 提取操作數 (C) 暫存器 (D) 控制器 (E) 累加器。</p>
<p><strong>解題過程：</strong><br>8259A是一個可程式中斷控制器(PIC)，用於管理來自外部裝置的中斷請求。</p>
<p><strong>答案：</strong><br>(D)</p>
<hr>
<h3 id="23-True-False-The-acronym-PCI-stands-for-programmable-component-interface"><a href="#23-True-False-The-acronym-PCI-stands-for-programmable-component-interface" class="headerlink" title="23. (True&#x2F;False): The acronym PCI stands for programmable component interface."></a><strong>23. (True&#x2F;False): The acronym PCI stands for programmable component interface.</strong></h3><p><strong>翻譯：</strong> (判斷題)：PCI縮寫代表可程式元件介面(programmable component interface)。</p>
<p><strong>解題過程：</strong><br>PCI實際上代表外設元件互連(Peripheral Component Interconnect)，而非可程式元件介面。</p>
<p><strong>答案：</strong><br>(False) 因為PCI代表外設元件互連(Peripheral Component Interconnect)。</p>
<hr>
<h3 id="25-At-which-level-s-can-an-Assembly-language-manipulate-input-output"><a href="#25-At-which-level-s-can-an-Assembly-language-manipulate-input-output" class="headerlink" title="25. At which level(s) can an Assembly language manipulate input &#x2F; output?"></a><strong>25. At which level(s) can an Assembly language manipulate input &#x2F; output?</strong></h3><p><strong>翻譯：</strong> 組合語言可以在哪個層級操作輸入&#x2F;輸出？</p>
<p><strong>解題過程：</strong><br>組合語言可以在多個層級操作I&#x2F;O：直接操作硬體、透過BIOS功能、透過作業系統API。</p>
<p><strong>答案：</strong><br>硬體、BIOS和作業系統(OS)</p>
<hr>
<h2 id="第三章：組合語言基礎"><a href="#第三章：組合語言基礎" class="headerlink" title="第三章：組合語言基礎"></a>第三章：組合語言基礎</h2><h3 id="01-Provide-examples-of-three-different-instruction-mnemonics"><a href="#01-Provide-examples-of-three-different-instruction-mnemonics" class="headerlink" title="01. Provide examples of three different instruction mnemonics."></a><strong>01. Provide examples of three different instruction mnemonics.</strong></h3><p><strong>翻譯：</strong> 提供三種不同指令助記符的例子。</p>
<p><strong>解題過程：</strong><br>在x86組合語言中，有許多不同的指令助記符，例如數據移動指令(MOV)、算術指令(ADD, SUB)等。</p>
<p><strong>答案：</strong><br>ADD, SUB, MOV</p>
<hr>
<h3 id="03-How-do-you-reserve-space-for-the-stack-in-a-program"><a href="#03-How-do-you-reserve-space-for-the-stack-in-a-program" class="headerlink" title="03. How do you reserve space for the stack in a program?"></a><strong>03. How do you reserve space for the stack in a program?</strong></h3><p><strong>翻譯：</strong> 如何在程式中為堆疊保留空間？</p>
<p><strong>解題過程：</strong><br>在組合語言中，通常通過從堆疊指標暫存器(ESP或RSP)中減去所需的值來為堆疊保留空間。</p>
<p><strong>答案：</strong><br>通過從堆疊指標暫存器中減去一個值。</p>
<hr>
<h3 id="05-Explain-the-difference-between-big-endian-and-little-endian-Also-look-up-the-origins-of-this-term-on-the-Web"><a href="#05-Explain-the-difference-between-big-endian-and-little-endian-Also-look-up-the-origins-of-this-term-on-the-Web" class="headerlink" title="05. Explain the difference between big endian and little endian. Also, look up the origins of this term on the Web."></a><strong>05. Explain the difference between big endian and little endian. Also, look up the origins of this term on the Web.</strong></h3><p><strong>翻譯：</strong> 解釋大端序與小端序的區別。同時，在網路上查詢這個術語的起源。</p>
<p><strong>解題過程：</strong><br>大端序和小端序是指位元組在記憶體中的存儲順序：</p>
<ul>
<li>小端序：最低有效位在位置0，即數字的右側。</li>
<li>大端序：最高有效位在位置0，與小端序相反。</li>
</ul>
<p><strong>答案：</strong><br>小端序將最低有效位放在位置0，即數字的右側。大端序則相反。</p>
<hr>
<h3 id="07-How-is-a-source-file-different-from-a-listing-file"><a href="#07-How-is-a-source-file-different-from-a-listing-file" class="headerlink" title="07. How is a source file different from a listing file?"></a><strong>07. How is a source file different from a listing file?</strong></h3><p><strong>翻譯：</strong> 源文件與列表文件有何不同？</p>
<p><strong>解題過程：</strong><br>源文件是提供給組譯器的輸入文件，包含原始的組合語言代碼。列表文件是組譯器生成的輸出文件，包含原始代碼、機器碼以及其他信息。</p>
<p><strong>答案：</strong><br>源文件作為輸入提供給組譯器。列表文件含有不會被組譯的附加文本。它是由組譯器創建的文件。</p>
<hr>
<h3 id="08-How-are-data-labels-and-code-labels-different"><a href="#08-How-are-data-labels-and-code-labels-different" class="headerlink" title="08. How are data labels and code labels different?"></a><strong>08. How are data labels and code labels different?</strong></h3><p><strong>翻譯：</strong> 數據標籤和代碼標籤有何不同？</p>
<p><strong>解題過程：</strong><br>數據標籤和代碼標籤在組合語言中用於不同目的：</p>
<ul>
<li>數據標籤：在數據段中，作為變量的偏移量。</li>
<li>代碼標籤：在代碼段中，作為控制轉移指令的目標偏移量。</li>
</ul>
<p><strong>答案：</strong><br>數據標籤存在於數據段中，作為變量的偏移量。代碼標籤在代碼段中，是控制轉移指令的偏移量。</p>
<hr>
<h3 id="13-Name-the-four-basic-parts-of-an-assembly-language-instruction-1"><a href="#13-Name-the-four-basic-parts-of-an-assembly-language-instruction-1" class="headerlink" title="13. Name the four basic parts of an assembly language instruction."></a><strong>13. Name the four basic parts of an assembly language instruction.</strong></h3><p><strong>翻譯：</strong> 列出組合語言指令的四個基本部分。</p>
<p><strong>解題過程：</strong><br>組合語言指令通常包含四個基本部分：標籤(可選)、助記符(必需)、操作數(視指令而定)和註釋(可選)。</p>
<p><strong>答案：</strong><br>標籤、助記符、操作數、註釋</p>
<hr>
<h3 id="14-What’s-the-different-between-Instruction-and-Directive"><a href="#14-What’s-the-different-between-Instruction-and-Directive" class="headerlink" title="14. What’s the different between Instruction and Directive?"></a><strong>14. What’s the different between Instruction and Directive?</strong></h3><p><strong>翻譯：</strong> 指令和指示詞有什麼區別？</p>
<p><strong>解題過程：</strong><br>指令和指示詞在組合語言中有不同的作用：</p>
<ul>
<li>指令：可執行的語句，轉換為機器碼。</li>
<li>指示詞：非執行性語句，為組譯器提供信息。</li>
</ul>
<p><strong>答案：</strong><br>指示詞是非執行性語句，而指令是可執行語句。指示詞是為組譯器提供幫助的，也是組譯器提供的幫助。</p>
<hr>
<h3 id="17-Why-is-it-not-a-good-idea-to-use-numeric-addresses-when-writing-instructions-that-access-variables"><a href="#17-Why-is-it-not-a-good-idea-to-use-numeric-addresses-when-writing-instructions-that-access-variables" class="headerlink" title="17. Why is it not a good idea to use numeric addresses when writing instructions that access variables?"></a><strong>17. Why is it not a good idea to use numeric addresses when writing instructions that access variables?</strong></h3><p><strong>翻譯：</strong> 為什麼在編寫訪問變量的指令時不建議使用數值地址？</p>
<p><strong>解題過程：</strong><br>使用數值地址(偏移量)有以下問題：</p>
<ol>
<li>如果在現有變量之前插入新變量，所有硬編碼的地址都需要更新。</li>
<li>代碼難以閱讀和維護。</li>
<li>容易出錯。</li>
</ol>
<p><strong>答案：</strong><br>不使用變量的數值地址(偏移量)是因為如果在現有變量之前插入新變量，地址會發生變化。</p>
<hr>
<h3 id="18-What-type-of-argument-must-be-passed-to-the-ExitProcess-procedure"><a href="#18-What-type-of-argument-must-be-passed-to-the-ExitProcess-procedure" class="headerlink" title="18. What type of argument must be passed to the ExitProcess procedure?"></a><strong>18. What type of argument must be passed to the ExitProcess procedure?</strong></h3><p><strong>翻譯：</strong> 必須傳遞給ExitProcess過程什麼類型的參數？</p>
<p><strong>解題過程：</strong><br>ExitProcess過程需要一個狀態碼作為參數，通常是一個整數，表示程序的退出狀態（成功或失敗）。</p>
<p><strong>答案：</strong><br>程式設計中的exit process過程需要一個狀態碼作為參數，以指示成功或失敗。值為0表示成功…</p>
<hr>
<h3 id="21-What-is-the-purpose-of-the-PROTO-directive"><a href="#21-What-is-the-purpose-of-the-PROTO-directive" class="headerlink" title="21. What is the purpose of the PROTO directive?"></a><strong>21. What is the purpose of the PROTO directive?</strong></h3><p><strong>翻譯：</strong> PROTO指示詞的目的是什麼？</p>
<p><strong>解題過程：</strong><br>PROTO指示詞用於宣告當前程式中調用的過程的原型，類似於C語言中的函數原型宣告。</p>
<p><strong>答案：</strong><br>PROTO宣告當前程序調用的過程的名稱。<br>PROTO指示詞：我們知道過程在被INVOKE指示詞調用之前必須被定義。否則，組譯器會給出未定義符號錯誤。您可以使用PROTO指示詞編寫過程原型，以及使用INVOKE指示詞調用外部例程。</p>
<hr>
<h3 id="B-3-9-2-Algorithm-Workbench"><a href="#B-3-9-2-Algorithm-Workbench" class="headerlink" title="B.3.9.2 Algorithm Workbench"></a><strong>B.3.9.2 Algorithm Workbench</strong></h3><h3 id="01-Define-four-symbolic-constants-that-represent-integer-25-in-decimal-binary-octal-and-hexadecimal-formats"><a href="#01-Define-four-symbolic-constants-that-represent-integer-25-in-decimal-binary-octal-and-hexadecimal-formats" class="headerlink" title="01. Define four symbolic constants that represent integer 25 in decimal, binary, octal, and hexadecimal formats."></a><strong>01. Define four symbolic constants that represent integer 25 in decimal, binary, octal, and hexadecimal formats.</strong></h3><p><strong>翻譯：</strong> 定義四個符號常量，分別以十進制、二進制、八進制和十六進制格式表示整數25。</p>
<p><strong>解題過程：</strong><br>使用不同的數字格式定義整數25：</p>
<ul>
<li>十進制：25</li>
<li>二進制：11001b (25的二進制表示)</li>
<li>八進制：31o (25的八進制表示)</li>
<li>十六進制：19h (25的十六進制表示)</li>
</ul>
<p><strong>答案：</strong><br>代碼示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">one = 25</span><br><span class="line">two = 11001b</span><br><span class="line">three = 31o</span><br><span class="line">four = 19h</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="03-Create-a-data-definition-for-a-doubleword-that-stored-it-in-memory-in-big-endian-format"><a href="#03-Create-a-data-definition-for-a-doubleword-that-stored-it-in-memory-in-big-endian-format" class="headerlink" title="03. Create a data definition for a doubleword that stored it in memory in big endian format."></a><strong>03. Create a data definition for a doubleword that stored it in memory in big endian format.</strong></h3><p><strong>翻譯：</strong> 創建一個數據定義，在記憶體中以大端格式存儲一個雙字。</p>
<p><strong>解題過程：</strong><br>在x86架構(使用小端序)中存儲大端格式的值，需要顛倒字節順序。例如，要以大端格式存儲值01020304h，需要將字節順序反轉為04030201h。</p>
<p><strong>答案：</strong><br>&lt;p.3-29&gt;<br>存儲值01020304h</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">myVal LABEL DWORD</span><br><span class="line">BYTE 04h,03h,02h,01h</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="05-Write-a-program-that-contains-two-instructions-1-add-the-number-5-to-the-EAX-register-and-2-add-5-to-the-EDX-register-Generate-a-listing-file-and-examine-the-machine-code-generated-by-the-assembler-What-differences-if-any-did-you-find-between-the-two-instructions"><a href="#05-Write-a-program-that-contains-two-instructions-1-add-the-number-5-to-the-EAX-register-and-2-add-5-to-the-EDX-register-Generate-a-listing-file-and-examine-the-machine-code-generated-by-the-assembler-What-differences-if-any-did-you-find-between-the-two-instructions" class="headerlink" title="05. Write a program that contains two instructions: (1) add the number 5 to the EAX register, and (2) add 5 to the EDX register. Generate a listing file and examine the machine code generated by the assembler. What differences, if any, did you find between the two instructions?"></a><strong>05. Write a program that contains two instructions: (1) add the number 5 to the EAX register, and (2) add 5 to the EDX register. Generate a listing file and examine the machine code generated by the assembler. What differences, if any, did you find between the two instructions?</strong></h3><p><strong>翻譯：</strong> 編寫一個含有兩條指令的程序：(1)將數字5加到EAX暫存器，(2)將5加到EDX暫存器。生成列表文件並檢查組譯器生成的機器碼。您發現這兩條指令之間有何不同（如果有的話）？</p>
<p><strong>解題過程：</strong><br>這兩條指令的功能類似，但由於它們使用不同的暫存器，因此生成的機器碼不同。EAX暫存器有特殊的短操作碼形式。</p>
<p><strong>答案：</strong><br>代碼示例。這兩條指令有不同的操作碼。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">add eax,5</span><br><span class="line">add edx,5</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="07-Declare-an-array-of-120-uninitialized-unsigned-doubleword-values"><a href="#07-Declare-an-array-of-120-uninitialized-unsigned-doubleword-values" class="headerlink" title="07. Declare an array of 120 uninitialized unsigned doubleword values."></a><strong>07. Declare an array of 120 uninitialized unsigned doubleword values.</strong></h3><p><strong>翻譯：</strong> 宣告一個包含120個未初始化的無符號雙字值的陣列。</p>
<p><strong>解題過程：</strong><br>使用DWORD數據類型和DUP運算符來宣告未初始化的陣列。</p>
<p><strong>答案：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myArray DWORD 120 DUP(?)</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="08-Declare-an-array-of-byte-and-initialize-it-to-the-first-5-letters-of-the-alphabet"><a href="#08-Declare-an-array-of-byte-and-initialize-it-to-the-first-5-letters-of-the-alphabet" class="headerlink" title="08. Declare an array of byte and initialize it to the first 5 letters of the alphabet."></a><strong>08. Declare an array of byte and initialize it to the first 5 letters of the alphabet.</strong></h3><p><strong>翻譯：</strong> 宣告一個字節陣列並將其初始化為字母表的前5個字母。</p>
<p><strong>解題過程：</strong><br>使用BYTE數據類型和字符串初始化：</p>
<p><strong>答案：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">firstFive BYTE &quot;ABCDE&quot;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="10-Declare-an-unsigned-16-bit-integer-variable-named-wArray-that-uses-three-initializers"><a href="#10-Declare-an-unsigned-16-bit-integer-variable-named-wArray-that-uses-three-initializers" class="headerlink" title="10. Declare an unsigned 16-bit integer variable named wArray that uses three initializers."></a><strong>10. Declare an unsigned 16-bit integer variable named wArray that uses three initializers.</strong></h3><p><strong>翻譯：</strong> 宣告一個名為wArray的無符號16位整數變量，使用三個初始化器。</p>
<p><strong>解題過程：</strong><br>使用WORD數據類型(16位)並指定三個初始值。</p>
<p><strong>答案：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wArray WORD 1000h, 2000h, 3000h</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="12-Declare-an-uninitialized-array-of-50-signed-doublewords-named-dArray"><a href="#12-Declare-an-uninitialized-array-of-50-signed-doublewords-named-dArray" class="headerlink" title="12. Declare an uninitialized array of 50 signed doublewords named dArray."></a><strong>12. Declare an uninitialized array of 50 signed doublewords named dArray.</strong></h3><p><strong>翻譯：</strong> 宣告一個名為dArray的未初始化的50個有符號雙字陣列。</p>
<p><strong>解題過程：</strong><br>使用DWORD數據類型和DUP運算符。</p>
<p><strong>答案：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dArray DWORD 50 DUP(?)</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="14-Declare-an-array-of-20-unsigned-bytes-named-bArray-and-initialize-all-elements-to-zero"><a href="#14-Declare-an-array-of-20-unsigned-bytes-named-bArray-and-initialize-all-elements-to-zero" class="headerlink" title="14. Declare an array of 20 unsigned bytes named bArray and initialize all elements to zero."></a><strong>14. Declare an array of 20 unsigned bytes named bArray and initialize all elements to zero.</strong></h3><p><strong>翻譯：</strong> 宣告一個名為bArray的20個無符號字節陣列，並將所有元素初始化為零。</p>
<p><strong>解題過程：</strong><br>使用BYTE數據類型和DUP運算符，並將每個元素初始化為0。</p>
<p><strong>答案：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bArray BYTE 20 DUP(0)</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="15-Use-the-DUP-directive-to-allocate-space-for-five-double-words-and-two-bytes-in-a-data-segment-Then-fill-15-spaces-with-7-spaces-after-with-and-the-rest-with-an-uppercase-M"><a href="#15-Use-the-DUP-directive-to-allocate-space-for-five-double-words-and-two-bytes-in-a-data-segment-Then-fill-15-spaces-with-7-spaces-after-with-and-the-rest-with-an-uppercase-M" class="headerlink" title="15. Use the DUP directive to allocate space for five double-words and two bytes in a data segment. Then fill 15 spaces with &amp;, 7 spaces after &amp; with %, and the rest with an uppercase M."></a><strong>15. Use the DUP directive to allocate space for five double-words and two bytes in a data segment. Then fill 15 spaces with &amp;, 7 spaces after &amp; with %, and the rest with an uppercase M.</strong></h3><p><strong>翻譯：</strong> 使用DUP指示詞在數據段中為五個雙字和兩個字節分配空間。然後用&amp;填充15個空格，在&amp;之後用%填充7個空格，剩下的用大寫M填充。</p>
<p><strong>解題過程：</strong><br>逐步宣告不同的數據區域：</p>
<p><strong>答案：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.DATA</span><br><span class="line">NUMS DWORD 5 DUP(?)</span><br><span class="line">NUMS1 BYTE 2 DUP(?)</span><br><span class="line">CHARS BYTE 15 DUP(&#x27;&amp;&#x27;)</span><br><span class="line">CHARS1 BYTE 7 DUP(&#x27;%&#x27;)</span><br><span class="line">CHARS BYTE &#x27;M&#x27;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="第四章：數據傳輸、尋址和算術"><a href="#第四章：數據傳輸、尋址和算術" class="headerlink" title="第四章：數據傳輸、尋址和算術"></a>第四章：數據傳輸、尋址和算術</h2><h3 id="4-9-複習問題與習題"><a href="#4-9-複習問題與習題" class="headerlink" title="4.9 複習問題與習題"></a><strong>4.9 複習問題與習題</strong></h3><h3 id="A-4-9-1-簡答題"><a href="#A-4-9-1-簡答題" class="headerlink" title="A: 4.9.1 簡答題"></a><strong>A: 4.9.1 簡答題</strong></h3><h3 id="01-What-will-be-the-value-in-EDX-after-each-of-the-lines-marked-a-and-b-execute"><a href="#01-What-will-be-the-value-in-EDX-after-each-of-the-lines-marked-a-and-b-execute" class="headerlink" title="01. What will be the value in EDX after each of the lines marked (a) and (b) execute?"></a><strong>01. What will be the value in EDX after each of the lines marked (a) and (b) execute?</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.data</span><br><span class="line">one WORD 8002h</span><br><span class="line">two WORD 4321h</span><br><span class="line">.code</span><br><span class="line">mov edx,21348041h</span><br><span class="line">movsx edx,one   ; (a)</span><br><span class="line">movsx edx,two   ; (b)</span><br></pre></td></tr></table></figure>

<p><strong>翻譯：</strong> 在標記為(a)和(b)的行執行後，EDX中的值是多少？</p>
<p><strong>解題過程：</strong><br>(a) MOVSX指令將源操作數符號擴展到目標操作數。8002h的最高位是1，表示它是負數。因此符號擴展後會在高位填充1，變成FFFF8002h。<br>(b) 4321h的最高位是0，表示它是正數。符號擴展後高位填充0，變成00004321h。</p>
<p><strong>答案：</strong><br>(a) edx &#x3D; FFFF8002h<br>(b) edx &#x3D; 00004321h</p>
<hr>
<h3 id="03-What-will-be-the-value-in-EAX-after-the-following-lines-execute"><a href="#03-What-will-be-the-value-in-EAX-after-the-following-lines-execute" class="headerlink" title="03. What will be the value in EAX after the following lines execute?"></a><strong>03. What will be the value in EAX after the following lines execute?</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov eax,30020000h</span><br><span class="line">dec ax</span><br></pre></td></tr></table></figure>

<p><strong>翻譯：</strong> 以下行執行後，EAX中的值是多少？</p>
<p><strong>解題過程：</strong><br>DEC AX只減少EAX的低16位。30020000h的低16位是0000h，減1後變成FFFFh，而高16位不變。</p>
<p><strong>答案：</strong><br>eax &#x3D; 3002FFFFh</p>
<hr>
<h3 id="05-What-will-be-the-value-of-the-Parity-flag-after-the-following-lines-execute"><a href="#05-What-will-be-the-value-of-the-Parity-flag-after-the-following-lines-execute" class="headerlink" title="05. What will be the value of the Parity flag after the following lines execute?"></a><strong>05. What will be the value of the Parity flag after the following lines execute?</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov al,1</span><br><span class="line">add al,3</span><br></pre></td></tr></table></figure>

<p><strong>翻譯：</strong> 以下行執行後，同位旗標的值是多少？</p>
<p><strong>解題過程：</strong><br>1 + 3 &#x3D; 4，二進制表示為00000100。其中1的個數為1個(奇數)，所以同位旗標為0(表示奇數)。但題目答案顯示為”偶校驗(1)”，這應該是指同位旗標設為1表示偶數。</p>
<p><strong>答案：</strong><br>偶校驗(1)</p>
<hr>
<h3 id="07-In-the-following-code-the-value-in-AL-is-intended-to-be-a-signed-byte-Explain-how-the-Overflow-flag-helps-or-does-not-help-you-to-determine-whether-the-final-value-in-AL-falls-within-a-valid-signed-range"><a href="#07-In-the-following-code-the-value-in-AL-is-intended-to-be-a-signed-byte-Explain-how-the-Overflow-flag-helps-or-does-not-help-you-to-determine-whether-the-final-value-in-AL-falls-within-a-valid-signed-range" class="headerlink" title="07. In the following code, the value in AL is intended to be a signed byte. Explain how the Overflow flag helps, or does not help you, to determine whether the final value in AL falls within a valid signed range."></a><strong>07. In the following code, the value in AL is intended to be a signed byte. Explain how the Overflow flag helps, or does not help you, to determine whether the final value in AL falls within a valid signed range.</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov al,-1</span><br><span class="line">add al,130</span><br></pre></td></tr></table></figure>

<p><strong>翻譯：</strong> 在以下代碼中，AL中的值被視為有符號字節。解釋溢位旗標如何幫助或不幫助您確定AL中的最終值是否在有效的有符號範圍內。</p>
<p><strong>解題過程：</strong><br>有符號字節的範圍是-128到+127。計算-1 + 130 &#x3D; 129，超出了有符號字節的正數範圍。這會導致溢位，設置溢位旗標。</p>
<p><strong>答案：</strong><br>-1 + 130 &#x3D; 129，超出了有符號字節的正數範圍。因此，溢位旗標會被設置。</p>
<hr>
<h3 id="09-What-value-will-RAX-contain-after-the-following-instructions-execute"><a href="#09-What-value-will-RAX-contain-after-the-following-instructions-execute" class="headerlink" title="09. What value will RAX contain after the following instructions execute?"></a><strong>09. What value will RAX contain after the following instructions execute?</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.data</span><br><span class="line">dwordVal DWORD 84326732h</span><br><span class="line">.code</span><br><span class="line">mov rax,0FFFFFFFF00000000h</span><br><span class="line">mov rax,dwordVal</span><br></pre></td></tr></table></figure>

<p><strong>翻譯：</strong> 執行以下指令後，RAX中的值是多少？</p>
<p><strong>解題過程：</strong><br>在64位模式下，當32位值被移動到64位寄存器時，高32位會被設置為1或0，取決於源操作數的符號位。dwordVal的最高位是1，所以高32位會填充1。</p>
<p><strong>答案：</strong><br>rax &#x3D; FFFFFFFF84326732h &lt;參考: 書-p.4-9&gt;</p>
<hr>
<h3 id="10-What-value-will-EAX-contain-after-the-following-instructions-execute"><a href="#10-What-value-will-EAX-contain-after-the-following-instructions-execute" class="headerlink" title="10. What value will EAX contain after the following instructions execute?"></a><strong>10. What value will EAX contain after the following instructions execute?</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.data</span><br><span class="line">dVal DWORD 12345678h</span><br><span class="line">.code</span><br><span class="line">mov ax,3        ;ax=0003h</span><br><span class="line">mov WORD PTR dVal+2,ax  ;[dVal+2]= 0003h</span><br><span class="line">mov eax,dVal</span><br></pre></td></tr></table></figure>

<p><strong>翻譯：</strong> 執行以下指令後，EAX中的值是多少？</p>
<p><strong>解題過程：</strong><br>首先將值3(0003h)移動到AX。然後將AX的值(0003h)存儲到dVal+2的位置，即覆蓋dVal的高16位。dVal原本是12345678h，修改後變成00035678h。最後將dVal的值移動到EAX。</p>
<p><strong>答案：</strong><br>eax &#x3D; 00035678h</p>
<hr>
<h3 id="11-What-will-EAX-contain-after-the-following-instructions-execute-1"><a href="#11-What-will-EAX-contain-after-the-following-instructions-execute-1" class="headerlink" title="11. What will EAX contain after the following instructions execute?"></a><strong>11. What will EAX contain after the following instructions execute?</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.data</span><br><span class="line">dVal DWORD ?</span><br><span class="line">.code</span><br><span class="line">Main Proc</span><br><span class="line">mov dVal,12345678h</span><br><span class="line">mov ax,WORD PTR dVal+2   ; ax=1234h</span><br><span class="line">add ax,3                 ; ax=1237</span><br><span class="line">mov WORD PTR dVal,ax     ; [dVal]= 1237</span><br><span class="line">mov eax,dVal             ; eax = 12341237h</span><br></pre></td></tr></table></figure>

<p><strong>翻譯：</strong> 執行以下指令後，EAX中的值是多少？</p>
<p><strong>解題過程：</strong></p>
<ol>
<li>將12345678h存儲到dVal</li>
<li>將dVal+2的內容(1234h)移動到AX</li>
<li>將AX增加3，變成1237h</li>
<li>將AX的值(1237h)存儲到dVal的低16位，原本dVal為12345678h，現在變成12341237h</li>
<li>將dVal的值移動到EAX</li>
</ol>
<p><strong>答案：</strong><br>eax &#x3D; 12341237h</p>
<hr>
<h3 id="使用以下變數定義來回答問題16-19："><a href="#使用以下變數定義來回答問題16-19：" class="headerlink" title="使用以下變數定義來回答問題16-19："></a><strong>使用以下變數定義來回答問題16-19：</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.data</span><br><span class="line">var1 SBYTE -4,-2,3,1</span><br><span class="line">var2 WORD 1000h,2000h,3000h,4000h</span><br><span class="line">var3 SWORD -16,-42</span><br><span class="line">var4 DWORD 1,2,3,4,5</span><br></pre></td></tr></table></figure>

<h3 id="16-For-each-of-the-following-statements-state-whether-or-not-the-instruction-is-valid"><a href="#16-For-each-of-the-following-statements-state-whether-or-not-the-instruction-is-valid" class="headerlink" title="16. For each of the following statements, state whether or not the instruction is valid:"></a><strong>16. For each of the following statements, state whether or not the instruction is valid:</strong></h3><p>a. mov ax,var1?<br>b. mov ax,var2<br>c. mov eax,var3<br>d. mov var2,var3<br>e. movzx ax,var2<br>f. movzx var2,al<br>g. mov ds,ax<br>h. mov ds,1000h</p>
<p><strong>翻譯：</strong> 對於以下每個語句，說明指令是否有效：</p>
<p><strong>解題過程：</strong><br>檢查每條指令的有效性：<br>a. 無效，AX是16位，不能直接從8位數組加載<br>b. 有效，將var2的第一個WORD值加載到AX<br>c. 無效，不能將16位值(-16)直接加載到32位寄存器<br>d. 無效，不能在記憶體間直接移動數據<br>e. 無效，MOVZX需要目標操作數大於源操作數<br>f. 無效，MOVZX的第一個操作數必須是寄存器<br>g. 有效，允許將AX的值加載到DS段寄存器<br>h. 無效，不能將立即數直接移動到段寄存器</p>
<p><strong>答案：</strong><br>(a) 無效，(b) 有效，(c) 無效，(d) 無效，(e) 無效，(f) 無效，(g) 有效，(h) 無效</p>
<hr>
<h3 id="17-What-will-be-the-hexadecimal-value-of-the-destination-operand-after-each-of-the-following-instructions-execute-in-sequence"><a href="#17-What-will-be-the-hexadecimal-value-of-the-destination-operand-after-each-of-the-following-instructions-execute-in-sequence" class="headerlink" title="17. What will be the hexadecimal value of the destination operand after each of the following instructions execute in sequence?"></a><strong>17. What will be the hexadecimal value of the destination operand after each of the following instructions execute in sequence?</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov al,var1   ; a.</span><br><span class="line">mov ah,[var1+3]  ; b.</span><br></pre></td></tr></table></figure>

<p><strong>翻譯：</strong> 按順序執行以下每條指令後，目標操作數的十六進制值是多少？</p>
<p><strong>解題過程：</strong><br>a. var1是SBYTE -4，十六進制為FCh<br>b. [var1+3]是var1的第四個元素，值為1，十六進制為01h</p>
<p><strong>答案：</strong><br>(a) FCh (b) 01h</p>
<hr>
<h3 id="18-What-will-be-the-value-of-the-destination-operand-after-each-of-the-following-instructions-execute-in-sequence"><a href="#18-What-will-be-the-value-of-the-destination-operand-after-each-of-the-following-instructions-execute-in-sequence" class="headerlink" title="18. What will be the value of the destination operand after each of the following instructions execute in sequence?"></a><strong>18. What will be the value of the destination operand after each of the following instructions execute in sequence?</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mov ax,var2        ; a.</span><br><span class="line">mov ax,[var2+4]    ; b.</span><br><span class="line">mov ax,var3        ; c.</span><br><span class="line">mov ax,[var3-2]    ; d.</span><br><span class="line">mov ax,[var3-4]    ; e.</span><br></pre></td></tr></table></figure>

<p><strong>翻譯：</strong> 按順序執行以下每條指令後，目標操作數的值是多少？</p>
<p><strong>解題過程：</strong><br>a. var2的第一個元素是1000h<br>b. [var2+4]是var2的第三個元素，值為3000h<br>c. var3的第一個元素是-16，十六進制為FFF0h<br>d. [var3-2]指向var3之前2個字節的位置，但由於數據對齊，可能指向var3的第一個元素，值為FFF0h<br>e. [var3-4]指向var3之前4個字節的位置，值為FFD6h</p>
<p><strong>答案：</strong><br>(a) 1000h, (b) 3000h, (c) FFF0h, (d) FFF0h, (e) FFD6</p>
<hr>
<h3 id="19-What-will-be-the-value-of-the-destination-operand-after-each-of-the-following-instructions-execute-in-sequence"><a href="#19-What-will-be-the-value-of-the-destination-operand-after-each-of-the-following-instructions-execute-in-sequence" class="headerlink" title="19. What will be the value of the destination operand after each of the following instructions execute in sequence?"></a><strong>19. What will be the value of the destination operand after each of the following instructions execute in sequence?</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov edx,var4     ; a.</span><br><span class="line">movzx edx,var2   ; b.</span><br><span class="line">mov edx,[var4+4] ; c.</span><br><span class="line">movsx edx,var1   ; d.</span><br></pre></td></tr></table></figure>

<p><strong>翻譯：</strong> 按順序執行以下每條指令後，目標操作數的值是多少？</p>
<p><strong>解題過程：</strong><br>a. var4的第一個元素是1，十六進制為00000001h<br>b. var2的第一個元素是1000h，無符號擴展後為00001000h<br>c. [var4+4]是var4的第二個元素，值為2，十六進制為00000002h<br>d. var1的第一個元素是-4，十六進制為FCh，有符號擴展後為FFFFFFFCh</p>
<p><strong>答案：</strong><br>(a) 00000001h, (b) 00001000h, (c) 00000002h, (d) FFFFFFFCh</p>
<hr>
<h3 id="B-4-9-2-算法工作台"><a href="#B-4-9-2-算法工作台" class="headerlink" title="B.4.9.2 算法工作台"></a><strong>B.4.9.2 算法工作台</strong></h3><h3 id="01-Write-a-sequence-of-MOV-instructions-that-will-exchange-the-upper-and-lower-words-in-a-doubleword-variable-named-three"><a href="#01-Write-a-sequence-of-MOV-instructions-that-will-exchange-the-upper-and-lower-words-in-a-doubleword-variable-named-three" class="headerlink" title="01. Write a sequence of MOV instructions that will exchange the upper and lower words in a doubleword variable named three."></a><strong>01. Write a sequence of MOV instructions that will exchange the upper and lower words in a doubleword variable named three.</strong></h3><p><strong>翻譯：</strong> 編寫一系列MOV指令，交換名為three的雙字變數中的高位字和低位字。</p>
<p><strong>解題過程：</strong><br>需要使用臨時寄存器存儲值，並利用PTR運算符來訪問doubleword的不同部分。</p>
<p><strong>答案：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov ax,word ptr three</span><br><span class="line">mov bx,word ptr three+2</span><br><span class="line">mov three,bx</span><br><span class="line">mov word ptr three+2,ax</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="02-Use-the-XCHG-instruction-to-rearrange-the-values-in-the-four-eight-bit-temporary-registers-no-more-than-three-times-from-A-B-C-D-to-B-C-A-D"><a href="#02-Use-the-XCHG-instruction-to-rearrange-the-values-in-the-four-eight-bit-temporary-registers-no-more-than-three-times-from-A-B-C-D-to-B-C-A-D" class="headerlink" title="02. Use the XCHG instruction to rearrange the values in the four eight-bit temporary registers no more than three times, from A, B, C, D to B, C, A, D."></a><strong>02. Use the XCHG instruction to rearrange the values in the four eight-bit temporary registers no more than three times, from A, B, C, D to B, C, A, D.</strong></h3><p><strong>翻譯：</strong> 使用XCHG指令最多三次，將四個8位臨時寄存器中的值從A, B, C, D重新排列為B, C, A, D。</p>
<p><strong>解題過程：</strong><br>將AL中的值與BL交換，然後與CL交換，AL現在包含C的值。將AL與DL交換，AL現在包含D的值。</p>
<p><strong>答案：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xchg al,bl   ; 交換A和B: B, A, C, D</span><br><span class="line">xchg al,cl   ; 交換A和C: B, C, A, D</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="03-Transmitted-messages-often-include-a-parity-bit-whose-value-is-combined-with-a-data-byte-to-produce-an-even-number-of-1-bits-Suppose-a-message-byte-in-the-AL-register-contains-01110101-Show-how-you-could-use-the-Parity-flag-combined-with-an-arithmetic-instruction-to-determine-if-this-message-byte-has-even-or-odd-parity"><a href="#03-Transmitted-messages-often-include-a-parity-bit-whose-value-is-combined-with-a-data-byte-to-produce-an-even-number-of-1-bits-Suppose-a-message-byte-in-the-AL-register-contains-01110101-Show-how-you-could-use-the-Parity-flag-combined-with-an-arithmetic-instruction-to-determine-if-this-message-byte-has-even-or-odd-parity" class="headerlink" title="03. Transmitted messages often include a parity bit whose value is combined with a data byte to produce an even number of 1 bits. Suppose a message byte in the AL register contains 01110101. Show how you could use the Parity flag combined with an arithmetic instruction to determine if this message byte has even or odd parity."></a><strong>03. Transmitted messages often include a parity bit whose value is combined with a data byte to produce an even number of 1 bits. Suppose a message byte in the AL register contains 01110101. Show how you could use the Parity flag combined with an arithmetic instruction to determine if this message byte has even or odd parity.</strong></h3><p><strong>翻譯：</strong> 傳輸的消息通常包含一個奇偶校驗位，其值與數據字節結合以產生偶數個1位。假設AL寄存器中的消息字節包含01110101。說明如何使用奇偶校驗標誌結合算術指令來確定此消息字節具有偶校驗還是奇校驗。</p>
<p><strong>解題過程：</strong><br>可以使用ADD指令與0相加，這不會改變AL的值，但會根據AL中1的個數設置奇偶校驗標誌。</p>
<p><strong>答案：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov al,01110101</span><br><span class="line">add al,0    ; PF = 0 (奇數)</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="05-Write-a-sequence-of-two-instructions-that-use-addition-to-set-the-Zero-and-Carry-flags-at-the-same-time"><a href="#05-Write-a-sequence-of-two-instructions-that-use-addition-to-set-the-Zero-and-Carry-flags-at-the-same-time" class="headerlink" title="05. Write a sequence of two instructions that use addition to set the Zero and Carry flags at the same time."></a><strong>05. Write a sequence of two instructions that use addition to set the Zero and Carry flags at the same time.</strong></h3><p><strong>翻譯：</strong> 編寫使用加法同時設置零標誌和進位標誌的兩條指令序列。</p>
<p><strong>解題過程：</strong><br>當AL包含0FFh時，加1會產生進位，並且結果為0，同時設置零標誌和進位標誌。</p>
<p><strong>答案：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov al,0FFh</span><br><span class="line">add al,1     ; 設置零和進位標誌</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="07-Implement-the-following-arithmetic-expression-in-assembly-language-EAX-–val2-7-–-val3-val1-Assume-that-val1-val2-and-val3-are-32-bit-integer-variables"><a href="#07-Implement-the-following-arithmetic-expression-in-assembly-language-EAX-–val2-7-–-val3-val1-Assume-that-val1-val2-and-val3-are-32-bit-integer-variables" class="headerlink" title="07. Implement the following arithmetic expression in assembly language: EAX &#x3D; –val2 + 7 – val3 + val1. Assume that val1, val2, and val3 are 32-bit integer variables."></a><strong>07. Implement the following arithmetic expression in assembly language: EAX &#x3D; –val2 + 7 – val3 + val1. Assume that val1, val2, and val3 are 32-bit integer variables.</strong></h3><p><strong>翻譯：</strong> 在組合語言中實現以下算術表達式：EAX &#x3D; –val2 + 7 – val3 + val1。假設val1, val2和val3是32位整數變數。</p>
<p><strong>解題過程：</strong><br>使用MOV, NEG, ADD和SUB指令組合實現表達式。</p>
<p><strong>答案：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mov eax,val2</span><br><span class="line">neg eax      ; -val2</span><br><span class="line">add eax,7    ; -val2 + 7</span><br><span class="line">sub eax,val3 ; -val2 + 7 - val3</span><br><span class="line">add eax,val1 ; -val2 + 7 - val3 + val1</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="數據定義（用於問題12-18）："><a href="#數據定義（用於問題12-18）：" class="headerlink" title="數據定義（用於問題12-18）："></a><strong>數據定義（用於問題12-18）：</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.data</span><br><span class="line">myBytes BYTE 10h,20h,30h,40h</span><br><span class="line">myWords WORD 3 DUP(?),2000h</span><br><span class="line">myString BYTE &quot;ABCDE&quot;</span><br></pre></td></tr></table></figure>

<h3 id="12-Insert-a-directive-in-the-given-data-that-aligns-myBytes-to-an-even-numbered-address-1"><a href="#12-Insert-a-directive-in-the-given-data-that-aligns-myBytes-to-an-even-numbered-address-1" class="headerlink" title="12. Insert a directive in the given data that aligns myBytes to an even-numbered address."></a><strong>12. Insert a directive in the given data that aligns myBytes to an even-numbered address.</strong></h3><p><strong>翻譯：</strong> 在給定的數據中插入一個指示詞，將myBytes對齊到偶數地址。</p>
<p><strong>解題過程：</strong><br>使用ALIGN指示詞來確保myBytes從偶數地址開始。</p>
<p><strong>答案：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.data</span><br><span class="line">ALIGN 2</span><br><span class="line">myBytes BYTE 10h, 20h, 30h, 40h</span><br><span class="line">etc.</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="13-What-will-be-the-value-of-EAX-after-each-of-the-following-instructions-execute-1"><a href="#13-What-will-be-the-value-of-EAX-after-each-of-the-following-instructions-execute-1" class="headerlink" title="13. What will be the value of EAX after each of the following instructions execute?"></a><strong>13. What will be the value of EAX after each of the following instructions execute?</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mov eax,TYPE myBytes    ; a.</span><br><span class="line">mov eax,LENGTHOF myBytes ; b.</span><br><span class="line">mov eax,SIZEOF myBytes   ; c.</span><br><span class="line">mov eax,TYPE myWords     ; d.</span><br><span class="line">mov eax,LENGTHOF myWords ; e.</span><br><span class="line">mov eax,SIZEOF myWords   ; f.</span><br><span class="line">mov eax,SIZEOF myString  ; g.</span><br></pre></td></tr></table></figure>

<p><strong>翻譯：</strong> 執行以下每條指令後，EAX的值是多少？</p>
<p><strong>解題過程：</strong><br>TYPE：返回變數的字節大小<br>LENGTHOF：返回數組中的元素數<br>SIZEOF：返回變數的總字節大小（TYPE * LENGTHOF）</p>
<p><strong>答案：</strong><br>(a) 1 (b) 4 (c) 4 (d) 2 (e) 4 (f) 8 (g) 5</p>
<hr>
<h3 id="14-Write-a-single-instruction-that-moves-the-first-two-bytes-in-myBytes-to-the-DX-register-The-resulting-value-will-be-2010h-1"><a href="#14-Write-a-single-instruction-that-moves-the-first-two-bytes-in-myBytes-to-the-DX-register-The-resulting-value-will-be-2010h-1" class="headerlink" title="14. Write a single instruction that moves the first two bytes in myBytes to the DX register. The resulting value will be 2010h."></a><strong>14. Write a single instruction that moves the first two bytes in myBytes to the DX register. The resulting value will be 2010h.</strong></h3><p><strong>翻譯：</strong> 編寫一條指令，將myBytes中的前兩個字節移動到DX寄存器。結果值將是2010h。</p>
<p><strong>解題過程：</strong><br>使用WORD PTR運算符來將前兩個字節視為一個字，然後移動到DX。注意小端序：第一個字節10h將是低字節，第二個字節20h將是高字節。</p>
<p><strong>答案：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov dx, WORD PTR myBytes</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="15-Write-an-instruction-that-moves-the-second-byte-in-myWords-to-the-AL-register-1"><a href="#15-Write-an-instruction-that-moves-the-second-byte-in-myWords-to-the-AL-register-1" class="headerlink" title="15. Write an instruction that moves the second byte in myWords to the AL register."></a><strong>15. Write an instruction that moves the second byte in myWords to the AL register.</strong></h3><p><strong>翻譯：</strong> 編寫一條指令，將myWords中的第二個字節移動到AL寄存器。</p>
<p><strong>解題過程：</strong><br>myWords是WORD類型（2字節），第二個字節的偏移量是1。使用BYTE PTR訪問這個字節。</p>
<p><strong>答案：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov al, BYTE PTR myWords+1</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="16-Write-an-instruction-that-moves-all-four-bytes-in-myBytes-to-the-EAX-register-1"><a href="#16-Write-an-instruction-that-moves-all-four-bytes-in-myBytes-to-the-EAX-register-1" class="headerlink" title="16. Write an instruction that moves all four bytes in myBytes to the EAX register."></a><strong>16. Write an instruction that moves all four bytes in myBytes to the EAX register.</strong></h3><p><strong>翻譯：</strong> 編寫一條指令，將myBytes中的所有四個字節移動到EAX寄存器。</p>
<p><strong>解題過程：</strong><br>使用DWORD PTR運算符將整個myBytes視為一個雙字。</p>
<p><strong>答案：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov eax, DWORD PTR myBytes</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="17-Insert-a-LABEL-directive-in-the-given-data-that-permits-myWords-to-be-moved-directly-to-a-32-bit-register-1"><a href="#17-Insert-a-LABEL-directive-in-the-given-data-that-permits-myWords-to-be-moved-directly-to-a-32-bit-register-1" class="headerlink" title="17. Insert a LABEL directive in the given data that permits myWords to be moved directly to a 32-bit register."></a><strong>17. Insert a LABEL directive in the given data that permits myWords to be moved directly to a 32-bit register.</strong></h3><p><strong>翻譯：</strong> 在給定的數據中插入一個LABEL指示詞，允許myWords直接移動到32位寄存器。</p>
<p><strong>解題過程：</strong><br>使用LABEL指示詞為myWords創建一個DWORD別名。</p>
<p><strong>答案：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">myWordsD LABEL DWORD</span><br><span class="line">myWords WORD 3 DUP(?),2000h</span><br><span class="line">.code</span><br><span class="line">mov eax,myWordsD</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="18-Insert-a-LABEL-directive-in-the-given-data-that-permits-myBytes-to-be-moved-directly-to-a-16-bit-register-1"><a href="#18-Insert-a-LABEL-directive-in-the-given-data-that-permits-myBytes-to-be-moved-directly-to-a-16-bit-register-1" class="headerlink" title="18. Insert a LABEL directive in the given data that permits myBytes to be moved directly to a 16-bit register."></a><strong>18. Insert a LABEL directive in the given data that permits myBytes to be moved directly to a 16-bit register.</strong></h3><p><strong>翻譯：</strong> 在給定的數據中插入一個LABEL指示詞，允許myBytes直接移動到16位寄存器。</p>
<p><strong>解題過程：</strong><br>使用LABEL指示詞為myBytes創建一個WORD別名。</p>
<p><strong>答案：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">myBytesW LABEL WORD</span><br><span class="line">myBytes BYTE 10h,20h,30h,40h</span><br><span class="line">.code</span><br><span class="line">mov ax,myBytesW</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="第五章：過程"><a href="#第五章：過程" class="headerlink" title="第五章：過程"></a>第五章：過程</h2><h3 id="5-8-1-簡答題"><a href="#5-8-1-簡答題" class="headerlink" title="5.8.1 簡答題"></a><strong>5.8.1 簡答題</strong></h3><h3 id="01-Which-instruction-pushes-all-of-the-32-bit-general-purpose-registers-on-the-stack"><a href="#01-Which-instruction-pushes-all-of-the-32-bit-general-purpose-registers-on-the-stack" class="headerlink" title="01. Which instruction pushes all of the 32-bit general-purpose registers on the stack?"></a><strong>01. Which instruction pushes all of the 32-bit general-purpose registers on the stack?</strong></h3><p><strong>翻譯：</strong> 哪條指令將所有32位通用寄存器壓入堆疊？</p>
<p><strong>解題過程：</strong><br>PUSHA指令將所有32位通用寄存器（EAX, ECX, EDX, EBX, ESP, EBP, ESI, EDI）按固定順序壓入堆疊。</p>
<p><strong>答案：</strong><br>pusha</p>
<hr>
<h3 id="03-Which-instruction-pops-the-stack-into-the-EFLAGS-register"><a href="#03-Which-instruction-pops-the-stack-into-the-EFLAGS-register" class="headerlink" title="03. Which instruction pops the stack into the EFLAGS register?"></a><strong>03. Which instruction pops the stack into the EFLAGS register?</strong></h3><p><strong>翻譯：</strong> 哪條指令將堆疊中的值彈出到EFLAGS寄存器？</p>
<p><strong>解題過程：</strong><br>POPF指令將堆疊頂部的值彈出並加載到EFLAGS寄存器中。</p>
<p><strong>答案：</strong><br>popf</p>
<hr>
<h3 id="05-Challenge-Suppose-there-were-no-PUSH-instruction-Write-a-sequence-of-two-other-instructions-that-would-accomplish-the-same-as-push-eax"><a href="#05-Challenge-Suppose-there-were-no-PUSH-instruction-Write-a-sequence-of-two-other-instructions-that-would-accomplish-the-same-as-push-eax" class="headerlink" title="05. Challenge: Suppose there were no PUSH instruction. Write a sequence of two other instructions that would accomplish the same as push eax."></a><strong>05. Challenge: Suppose there were no PUSH instruction. Write a sequence of two other instructions that would accomplish the same as push eax.</strong></h3><p><strong>翻譯：</strong> 挑戰：假設沒有PUSH指令。寫一個由兩條其他指令組成的序列，實現與push eax相同的功能。</p>
<p><strong>解題過程：</strong><br>要模擬PUSH指令的功能，需要：</p>
<ol>
<li>先減少堆疊指針（為數據騰出空間）</li>
<li>然後將數據存儲到堆疊上</li>
</ol>
<p><strong>答案：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sub esp,4       ; 為雙字騰出空間</span><br><span class="line">mov [esp],eax   ; 將EAX的值存儲到堆疊頂部</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="07-True-False-Nested-procedure-calls-are-not-permitted-by-the-Microsoft-assembler-unless-the-NESTED-operator-is-used-in-the-procedure-definition"><a href="#07-True-False-Nested-procedure-calls-are-not-permitted-by-the-Microsoft-assembler-unless-the-NESTED-operator-is-used-in-the-procedure-definition" class="headerlink" title="07. (True&#x2F;False): Nested procedure calls are not permitted by the Microsoft assembler unless the NESTED operator is used in the procedure definition."></a><strong>07. (True&#x2F;False): Nested procedure calls are not permitted by the Microsoft assembler unless the NESTED operator is used in the procedure definition.</strong></h3><p><strong>翻譯：</strong> (判斷題)：除非在過程定義中使用NESTED運算符，否則Microsoft組譯器不允許嵌套過程調用。</p>
<p><strong>解題過程：</strong><br>Microsoft組譯器確實允許嵌套過程調用，而無需特殊運算符。事實上，沒有NESTED這樣的運算符。</p>
<p><strong>答案：</strong><br>False（沒有NESTED運算符）。參考 P.5-10~5-11<br>嵌套循環在C、C#、C++、Java、Python等語言中都是允許的。</p>
<hr>
<h3 id="09-True-False-The-ESI-and-EDI-registers-cannot-be-used-when-passing-32-bit-parameters-to-procedures"><a href="#09-True-False-The-ESI-and-EDI-registers-cannot-be-used-when-passing-32-bit-parameters-to-procedures" class="headerlink" title="09. (True&#x2F;False): The ESI and EDI registers cannot be used when passing 32-bit parameters to procedures."></a><strong>09. (True&#x2F;False): The ESI and EDI registers cannot be used when passing 32-bit parameters to procedures.</strong></h3><p><strong>翻譯：</strong> (判斷題)：在向過程傳遞32位參數時不能使用ESI和EDI寄存器。</p>
<p><strong>解題過程：</strong><br>這個說法是錯誤的。ESI和EDI寄存器可以用於向過程傳遞參數，儘管它們通常用於字符串操作。</p>
<p><strong>答案：</strong><br>False<br>像MOVSB和MOVSW這樣的操作碼可以高效地將ESI指向的記憶體數據複製到EDI指向的記憶體。因此，</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mov esi, source_address</span><br><span class="line">mov edi, destination_address</span><br><span class="line">mov ecx, byte_count</span><br><span class="line">cld</span><br><span class="line">rep movsb ; 快速！</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="11-True-False-The-USES-operator-lets-you-name-all-registers-that-are-modified-within-a-procedure"><a href="#11-True-False-The-USES-operator-lets-you-name-all-registers-that-are-modified-within-a-procedure" class="headerlink" title="11. (True&#x2F;False): The USES operator lets you name all registers that are modified within a procedure."></a><strong>11. (True&#x2F;False): The USES operator lets you name all registers that are modified within a procedure.</strong></h3><p><strong>翻譯：</strong> (判斷題)：USES運算符允許您命名過程中修改的所有寄存器。</p>
<p><strong>解題過程：</strong><br>USES運算符確實允許您列出在過程中修改的寄存器，以便過程自動保存和恢復這些寄存器的值。</p>
<p><strong>答案：</strong><br>True</p>
<hr>
<h3 id="12-True-False-The-USES-operator-only-generates-PUSH-instructions-so-you-must-code-POP-instructions-yourself-1"><a href="#12-True-False-The-USES-operator-only-generates-PUSH-instructions-so-you-must-code-POP-instructions-yourself-1" class="headerlink" title="12. (True&#x2F;False): The USES operator only generates PUSH instructions, so you must code POP instructions yourself."></a><strong>12. (True&#x2F;False): The USES operator only generates PUSH instructions, so you must code POP instructions yourself.</strong></h3><p><strong>翻譯：</strong> (判斷題)：USES運算符只生成PUSH指令，所以您必須自己編寫POP指令。</p>
<p><strong>解題過程：</strong><br>這個說法是錯誤的。USES運算符不僅生成PUSH指令，還會自動在過程返回前生成對應的POP指令。</p>
<p><strong>答案：</strong><br>USES運算符允許您命名過程中修改的所有寄存器。此外，結合PROC指令的USES運算符可以列出過程修改的所有寄存器。</p>
<hr>
<h3 id="13-True-False-The-register-list-in-the-USES-directive-must-use-commas-to-separate-the-register-names"><a href="#13-True-False-The-register-list-in-the-USES-directive-must-use-commas-to-separate-the-register-names" class="headerlink" title="13. (True&#x2F;False): The register list in the USES directive must use commas to separate the register names."></a><strong>13. (True&#x2F;False): The register list in the USES directive must use commas to separate the register names.</strong></h3><p><strong>翻譯：</strong> (判斷題)：USES指令中的寄存器列表必須使用逗號分隔寄存器名稱。</p>
<p><strong>解題過程：</strong><br>在MASM中，USES指令的寄存器列表通常用空格分隔，而不是逗號。</p>
<p><strong>答案：</strong><br>參考 P.5-14~5-15</p>
<hr>
<h3 id="15-What-will-be-the-final-value-in-EAX-after-these-instructions-execute-1"><a href="#15-What-will-be-the-final-value-in-EAX-after-these-instructions-execute-1" class="headerlink" title="15. What will be the final value in EAX after these instructions execute?"></a><strong>15. What will be the final value in EAX after these instructions execute?</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">push 5</span><br><span class="line">push 6</span><br><span class="line">pop eax</span><br><span class="line">pop eax</span><br></pre></td></tr></table></figure>

<p><strong>翻譯：</strong> 執行這些指令後，EAX中的最終值是多少？</p>
<p><strong>解題過程：</strong></p>
<ol>
<li>push 5 - 將5壓入堆疊</li>
<li>push 6 - 將6壓入堆疊（堆疊現在從頂部到底部是：6, 5）</li>
<li>pop eax - 將6彈出到EAX</li>
<li>pop eax - 將5彈出到EAX（覆蓋先前的值）</li>
</ol>
<p><strong>答案：</strong><br>EAX &#x3D; 5</p>
<hr>
<h3 id="16-Which-statement-is-true-about-what-will-happen-when-the-example-code-runs-1"><a href="#16-Which-statement-is-true-about-what-will-happen-when-the-example-code-runs-1" class="headerlink" title="16. Which statement is true about what will happen when the example code runs?"></a><strong>16. Which statement is true about what will happen when the example code runs?</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1: main PROC</span><br><span class="line">2: push 10</span><br><span class="line">3: push 20</span><br><span class="line">4: call Ex2Sub</span><br><span class="line">5: pop eax</span><br><span class="line">6: INVOKE ExitProcess,0</span><br><span class="line">7: main ENDP</span><br><span class="line">8:</span><br><span class="line">9: Ex2Sub PROC</span><br><span class="line">10: pop eax</span><br><span class="line">11: ret</span><br><span class="line">12: Ex2Sub ENDP</span><br></pre></td></tr></table></figure>
<p>a. EAX will equal 10 on line 6<br>b. The program will halt with a runtime error on Line 10<br>c. EAX will equal 20 on line 6<br>d. The program will halt with a runtime error on Line 11</p>
<p><strong>翻譯：</strong> 當示例代碼運行時，哪個陳述是正確的？</p>
<p><strong>解題過程：</strong><br>分析代碼執行流程：</p>
<ol>
<li>main過程將10和20壓入堆疊</li>
<li>調用Ex2Sub過程</li>
<li>Ex2Sub執行POP EAX，彈出返回地址（而不是20）</li>
<li>當執行RET時，程序會嘗試返回到不正確的地址，導致運行時錯誤</li>
</ol>
<p><strong>答案：</strong><br>(d)</p>
<hr>
<h3 id="17-Which-statement-is-true-about-what-will-happen-when-the-example-code-runs-1"><a href="#17-Which-statement-is-true-about-what-will-happen-when-the-example-code-runs-1" class="headerlink" title="17. Which statement is true about what will happen when the example code runs?"></a><strong>17. Which statement is true about what will happen when the example code runs?</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">1: main PROC</span><br><span class="line">2: mov eax,30</span><br><span class="line">3: push eax</span><br><span class="line">4: push 40</span><br><span class="line">5: call Ex3Sub</span><br><span class="line">6: INVOKE ExitProcess,0</span><br><span class="line">7: main ENDP</span><br><span class="line">8:</span><br><span class="line">9: Ex3Sub PROC</span><br><span class="line">10: pusha</span><br><span class="line">11: mov eax,80</span><br><span class="line">12: popa</span><br><span class="line">13: ret</span><br><span class="line">14: Ex3Sub ENDP</span><br></pre></td></tr></table></figure>
<p>a. EAX will equal 40 on line 6<br>b. The program will halt with a runtime error on Line 6<br>c. EAX will equal 30 on line 6<br>d. The program will halt with a runtime error on Line 13</p>
<p><strong>翻譯：</strong> 當示例代碼運行時，哪個陳述是正確的？</p>
<p><strong>解題過程：</strong><br>分析代碼執行流程：</p>
<ol>
<li>main過程將EAX設為30，然後將30和40壓入堆疊</li>
<li>調用Ex3Sub過程</li>
<li>Ex3Sub使用PUSHA保存所有寄存器的值</li>
<li>將EAX設為80</li>
<li>使用POPA恢復所有寄存器的原始值，包括EAX&#x3D;30</li>
<li>返回main過程，此時EAX&#x3D;30</li>
</ol>
<p><strong>答案：</strong><br>(c)</p>
<hr>
<h3 id="18-Which-statement-is-true-about-what-will-happen-when-the-example-code-runs-1"><a href="#18-Which-statement-is-true-about-what-will-happen-when-the-example-code-runs-1" class="headerlink" title="18. Which statement is true about what will happen when the example code runs?"></a><strong>18. Which statement is true about what will happen when the example code runs?</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1: main PROC</span><br><span class="line">2: mov eax,40</span><br><span class="line">3: push offset Here</span><br><span class="line">4: jmp Ex4Sub</span><br><span class="line">5: Here:</span><br><span class="line">6: mov eax,30</span><br><span class="line">7: INVOKE ExitProcess,0</span><br><span class="line">8: main ENDP</span><br><span class="line">9:</span><br><span class="line">10: Ex4Sub PROC</span><br><span class="line">11: ret</span><br><span class="line">12: Ex4Sub ENDP</span><br></pre></td></tr></table></figure>
<p>a. EAX will equal 30 on line 7<br>b. The program will halt with a runtime error on Line 4<br>c. EAX will equal 30 on line 6<br>d. The program will halt with a runtime error on Line 11</p>
<p><strong>翻譯：</strong> 當示例代碼運行時，哪個陳述是正確的？</p>
<p><strong>解題過程：</strong><br>分析代碼執行流程：</p>
<ol>
<li>main過程將EAX設為40</li>
<li>將Here標籤的地址壓入堆疊</li>
<li>跳轉到Ex4Sub過程</li>
<li>Ex4Sub執行RET，返回到堆疊中保存的地址（Here標籤）</li>
<li>執行MOV EAX,30</li>
<li>到達ExitProcess調用</li>
</ol>
<p><strong>答案：</strong><br>(c)</p>
<hr>
<h3 id="19-Which-statement-is-true-about-what-will-happen-when-the-example-code-runs-1"><a href="#19-Which-statement-is-true-about-what-will-happen-when-the-example-code-runs-1" class="headerlink" title="19. Which statement is true about what will happen when the example code runs?"></a><strong>19. Which statement is true about what will happen when the example code runs?</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">1: main PROC</span><br><span class="line">2: mov edx,0</span><br><span class="line">3: mov eax,40</span><br><span class="line">4: push eax</span><br><span class="line">5: call Ex5Sub</span><br><span class="line">6: INVOKE ExitProcess,0</span><br><span class="line">7: main ENDP</span><br><span class="line">8:</span><br><span class="line">9: Ex5Sub PROC</span><br><span class="line">10: pop eax</span><br><span class="line">11: pop edx</span><br><span class="line">12: push eax</span><br><span class="line">13: ret</span><br><span class="line">14: Ex5Sub ENDP</span><br></pre></td></tr></table></figure>
<p>a. EDX will equal 40 on line 6<br>b. The program will halt with a runtime error on Line 13<br>c. EDX will equal 0 on line 6<br>d. The program will halt with a runtime error on Line 11</p>
<p><strong>翻譯：</strong> 當示例代碼運行時，哪個陳述是正確的？</p>
<p><strong>解題過程：</strong><br>分析代碼執行流程：</p>
<ol>
<li>main過程將EDX設為0，EAX設為40，並將40壓入堆疊</li>
<li>調用Ex5Sub過程</li>
<li>Ex5Sub執行pop eax，彈出返回地址</li>
<li>執行pop edx，但堆疊中沒有足夠的值可彈出（40已被彈出到EAX），這將導致堆疊下溢錯誤</li>
</ol>
<p><strong>答案：</strong><br>(a)</p>
<hr>
<h3 id="20-What-values-will-be-written-to-the-array-when-the-following-code-executes-1"><a href="#20-What-values-will-be-written-to-the-array-when-the-following-code-executes-1" class="headerlink" title="20. What values will be written to the array when the following code executes?"></a><strong>20. What values will be written to the array when the following code executes?</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">.data</span><br><span class="line">array DWORD 4 DUP(0)</span><br><span class="line">.code</span><br><span class="line">main PROC</span><br><span class="line">mov eax,10</span><br><span class="line">mov esi,0</span><br><span class="line">call proc_1</span><br><span class="line">add esi,4</span><br><span class="line">add eax,10</span><br><span class="line">mov array[esi],eax</span><br><span class="line">INVOKE ExitProcess,0</span><br><span class="line">main ENDP</span><br><span class="line">proc_1 PROC</span><br><span class="line">call proc_2</span><br><span class="line">add esi,4</span><br><span class="line">add eax,10</span><br><span class="line">mov array[esi],eax</span><br><span class="line">ret</span><br><span class="line">proc_1 ENDP</span><br><span class="line">proc_2 PROC</span><br><span class="line">call proc_3</span><br><span class="line">add esi,4</span><br><span class="line">add eax,10</span><br><span class="line">mov array[esi],eax</span><br><span class="line">ret</span><br><span class="line">proc_2 ENDP</span><br><span class="line">proc_3 PROC</span><br><span class="line">mov array[esi],eax</span><br><span class="line">ret</span><br><span class="line">proc_3 ENDP</span><br></pre></td></tr></table></figure>

<p><strong>翻譯：</strong> 當以下代碼執行時，什麼值將被寫入陣列？</p>
<p><strong>解題過程：</strong><br>跟踪代碼執行並跟踪ESI和EAX的值變化：</p>
<ol>
<li>初始：EAX&#x3D;10, ESI&#x3D;0</li>
<li>調用proc_1，proc_1調用proc_2，proc_2調用proc_3</li>
<li>proc_3：array[0]&#x3D;10，返回proc_2</li>
<li>proc_2：ESI&#x3D;4, EAX&#x3D;20, array[4]&#x3D;20，返回proc_1</li>
<li>proc_1：ESI&#x3D;8, EAX&#x3D;30, array[8]&#x3D;30，返回main</li>
<li>main：ESI&#x3D;12, EAX&#x3D;40, array[12]&#x3D;40</li>
</ol>
<p><strong>答案：</strong><br>陣列將包含10, 20, 30, 40</p>
<hr>
<h3 id="5-8-2-算法工作台"><a href="#5-8-2-算法工作台" class="headerlink" title="5.8.2 算法工作台"></a><strong>5.8.2 算法工作台</strong></h3><h3 id="01-Write-a-sequence-of-statements-that-use-only-PUSH-and-POP-instructions-to-exchange-the-values-in-the-EAX-and-EBX-registers-or-RAX-and-RBX-in-64-bit-mode"><a href="#01-Write-a-sequence-of-statements-that-use-only-PUSH-and-POP-instructions-to-exchange-the-values-in-the-EAX-and-EBX-registers-or-RAX-and-RBX-in-64-bit-mode" class="headerlink" title="01. Write a sequence of statements that use only PUSH and POP instructions to exchange the values in the EAX and EBX registers (or RAX and RBX in 64-bit mode)."></a><strong>01. Write a sequence of statements that use only PUSH and POP instructions to exchange the values in the EAX and EBX registers (or RAX and RBX in 64-bit mode).</strong></h3><p><strong>翻譯：</strong> 寫一個只使用PUSH和POP指令的語句序列，用於交換EAX和EBX寄存器（或64位模式下的RAX和RBX）中的值。</p>
<p><strong>解題過程：</strong><br>使用堆疊作為臨時存儲空間來交換寄存器值：</p>
<p><strong>答案：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">push ebx      ; 保存EBX</span><br><span class="line">push eax      ; 保存EAX</span><br><span class="line">pop ebx       ; 將EAX的值彈出到EBX</span><br><span class="line">pop eax       ; 將EBX的值彈出到EAX</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="03-Functions-in-high-level-languages-often-declare-local-variables-just-below-the-return-address-on-the-stack-Write-an-instruction-that-you-could-put-at-the-beginning-of-an-assembly-language-subroutine-that-would-reserve-space-for-two-integer-doubleword-variables-Then-assign-the-values-1000h-and-2000h-to-the-two-local-variables"><a href="#03-Functions-in-high-level-languages-often-declare-local-variables-just-below-the-return-address-on-the-stack-Write-an-instruction-that-you-could-put-at-the-beginning-of-an-assembly-language-subroutine-that-would-reserve-space-for-two-integer-doubleword-variables-Then-assign-the-values-1000h-and-2000h-to-the-two-local-variables" class="headerlink" title="03. Functions in high-level languages often declare local variables just below the return address on the stack. Write an instruction that you could put at the beginning of an assembly language subroutine that would reserve space for two integer doubleword variables. Then, assign the values 1000h and 2000h to the two local variables."></a><strong>03. Functions in high-level languages often declare local variables just below the return address on the stack. Write an instruction that you could put at the beginning of an assembly language subroutine that would reserve space for two integer doubleword variables. Then, assign the values 1000h and 2000h to the two local variables.</strong></h3><p><strong>翻譯：</strong> 高級語言中的函數通常在堆疊上的返回地址下方聲明局部變數。寫一條指令，你可以將其放在組合語言子程序的開始處，為兩個整數雙字變數保留空間。然後，將值1000h和2000h分配給這兩個局部變數。</p>
<p><strong>解題過程：</strong><br>在堆疊上保留8個字節（兩個雙字），然後將值存儲到這些位置：</p>
<p><strong>答案：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sub esp,8     ; 為兩個變數保留空間</span><br><span class="line">mov [esp],1000h</span><br><span class="line">mov [esp+4],2000h</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="05-Write-a-sequence-of-statements-that-display-a-subroutine-return-address-Be-sure-that-whatever-modifications-you-make-to-the-stack-do-not-prevent-the-subroutine-from-returning-to-its-caller"><a href="#05-Write-a-sequence-of-statements-that-display-a-subroutine-return-address-Be-sure-that-whatever-modifications-you-make-to-the-stack-do-not-prevent-the-subroutine-from-returning-to-its-caller" class="headerlink" title="05. Write a sequence of statements that display a subroutine return address. Be sure that whatever modifications you make to the stack do not prevent the subroutine from returning to its caller."></a><strong>05. Write a sequence of statements that display a subroutine return address. Be sure that whatever modifications you make to the stack do not prevent the subroutine from returning to its caller.</strong></h3><p><strong>翻譯：</strong> 寫一個語句序列來顯示子程序的返回地址。確保您對堆疊所做的任何修改不會阻止子程序返回到其調用者。</p>
<p><strong>解題過程：</strong><br>查看堆疊頂部的返回地址，但不修改它：</p>
<p><strong>答案：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov eax,[esp]       ; 將返回地址加載到EAX</span><br><span class="line">call WriteHex       ; 顯示它（假設WriteHex是一個顯示十六進制值的過程）</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="第六章：條件處理"><a href="#第六章：條件處理" class="headerlink" title="第六章：條件處理"></a>第六章：條件處理</h2><h3 id="6-10-1-簡答題"><a href="#6-10-1-簡答題" class="headerlink" title="6.10.1 簡答題"></a><strong>6.10.1 簡答題</strong></h3><h3 id="02-What-will-be-the-value-of-BX-after-the-following-instructions-execute"><a href="#02-What-will-be-the-value-of-BX-after-the-following-instructions-execute" class="headerlink" title="02. What will be the value of BX after the following instructions execute?"></a><strong>02. What will be the value of BX after the following instructions execute?</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov bx,91BAh</span><br><span class="line">and bx,92h</span><br></pre></td></tr></table></figure>

<p><strong>翻譯：</strong> 執行以下指令後，BX的值是多少？</p>
<p><strong>解題過程：</strong><br>執行位與運算：<br>91BAh &#x3D; 1001 0001 1011 1010<br>  92h &#x3D; 0000 0000 1001 0010<br>AND   &#x3D; 0000 0000 1001 0010 &#x3D; 92h</p>
<p><strong>答案：</strong><br>BX &#x3D; 092h</p>
<hr>
<h3 id="04-What-will-be-the-value-of-BX-after-the-following-instructions-execute"><a href="#04-What-will-be-the-value-of-BX-after-the-following-instructions-execute" class="headerlink" title="04. What will be the value of BX after the following instructions execute?"></a><strong>04. What will be the value of BX after the following instructions execute?</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov bx,029D6h</span><br><span class="line">xor bx,8181h</span><br></pre></td></tr></table></figure>

<p><strong>翻譯：</strong> 執行以下指令後，BX的值是多少？</p>
<p><strong>解題過程：</strong><br>執行位異或運算：<br>029D6h &#x3D; 0000 0010 1001 1101 0110<br>8181h  &#x3D; 1000 0001 1000 0001<br>XOR    &#x3D; 1000 0011 0001 1100 0111 &#x3D; A857h</p>
<p><strong>答案：</strong><br>BX &#x3D; A857h</p>
<hr>
<h3 id="06-What-will-be-the-value-of-RBX-after-the-following-instructions-execute"><a href="#06-What-will-be-the-value-of-RBX-after-the-following-instructions-execute" class="headerlink" title="06. What will be the value of RBX after the following instructions execute?"></a><strong>06. What will be the value of RBX after the following instructions execute?</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov rbx,0AFAF649Bh</span><br><span class="line">xor rbx,0FFFFFFFFh</span><br></pre></td></tr></table></figure>

<p><strong>翻譯：</strong> 執行以下指令後，RBX的值是多少？</p>
<p><strong>解題過程：</strong><br>執行位異或運算，注意這是64位操作：<br>0AFAF649Bh XOR 0FFFFFFFFh &#x3D; 50509B64h<br>由於RBX是64位寄存器，高32位將保持為0。</p>
<p><strong>答案：</strong><br>RBX &#x3D; 0000000050509B64h</p>
<hr>
<h3 id="08-In-the-following-instruction-sequence-show-the-resulting-value-of-AL-where-indicated-in-hexadecimal"><a href="#08-In-the-following-instruction-sequence-show-the-resulting-value-of-AL-where-indicated-in-hexadecimal" class="headerlink" title="08. In the following instruction sequence, show the resulting value of AL where indicated, in hexadecimal:"></a><strong>08. In the following instruction sequence, show the resulting value of AL where indicated, in hexadecimal:</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mov al,7Ah</span><br><span class="line">not al      ; a.</span><br><span class="line">mov al,3Dh</span><br><span class="line">and al,74h  ; b.</span><br><span class="line">mov al,9Bh</span><br><span class="line">or al,35h   ; c.</span><br><span class="line">mov al,72h</span><br><span class="line">xor al,0DCh ; d.</span><br></pre></td></tr></table></figure>

<p><strong>翻譯：</strong> 在以下指令序列中，以十六進制顯示指定位置的AL的結果值：</p>
<p><strong>解題過程：</strong><br>a. 7Ah &#x3D; 0111 1010，NOT操作後 &#x3D; 1000 0101 &#x3D; 85h<br>b. 3Dh &#x3D; 0011 1101，74h &#x3D; 0111 0100，AND後 &#x3D; 0011 0100 &#x3D; 34h<br>c. 9Bh &#x3D; 1001 1011，35h &#x3D; 0011 0101，OR後 &#x3D; 1011 1111 &#x3D; BFh<br>d. 72h &#x3D; 0111 0010，DCh &#x3D; 1101 1100，XOR後 &#x3D; 1010 1110 &#x3D; AEh</p>
<p><strong>答案：</strong><br>AL &#x3D; 85h, 34h, BFh, AEh</p>
<hr>
<h3 id="10-Which-conditional-jump-instruction-executes-a-branch-based-on-the-contents-of-ECX"><a href="#10-Which-conditional-jump-instruction-executes-a-branch-based-on-the-contents-of-ECX" class="headerlink" title="10. Which conditional jump instruction executes a branch based on the contents of ECX?"></a><strong>10. Which conditional jump instruction executes a branch based on the contents of ECX?</strong></h3><p><strong>翻譯：</strong> 哪條條件跳轉指令基於ECX的內容執行分支？</p>
<p><strong>解題過程：</strong><br>JECXZ指令在ECX為零時跳轉。</p>
<p><strong>答案：</strong><br>JECX</p>
<hr>
<h3 id="12-What-will-be-the-final-value-in-EDX-after-this-code-executes"><a href="#12-What-will-be-the-final-value-in-EDX-after-this-code-executes" class="headerlink" title="12. What will be the final value in EDX after this code executes?"></a><strong>12. What will be the final value in EDX after this code executes?</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mov edx,1</span><br><span class="line">mov eax,7FFFh</span><br><span class="line">cmp eax,8000h</span><br><span class="line">jl L1</span><br><span class="line">mov edx,0</span><br><span class="line">L1:</span><br></pre></td></tr></table></figure>

<p><strong>翻譯：</strong> 此代碼執行後，EDX中的最終值是多少？</p>
<p><strong>解題過程：</strong><br>比較7FFFh和8000h：7FFFh &lt; 8000h，因此條件跳轉會發生，EDX保持為1。</p>
<p><strong>答案：</strong><br>EDX &#x3D; 1</p>
<hr>
<h3 id="14-What-will-be-the-final-value-in-EDX-after-this-code-executes"><a href="#14-What-will-be-the-final-value-in-EDX-after-this-code-executes" class="headerlink" title="14. What will be the final value in EDX after this code executes?"></a><strong>14. What will be the final value in EDX after this code executes?</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mov edx,1</span><br><span class="line">mov eax,7FFFh</span><br><span class="line">cmp eax,0FFFF8000h</span><br><span class="line">jl L2</span><br><span class="line">mov edx,0</span><br><span class="line">L2:</span><br></pre></td></tr></table></figure>

<p><strong>翻譯：</strong> 此代碼執行後，EDX中的最終值是多少？</p>
<p><strong>解題過程：</strong><br>7FFFh是正數，0FFFF8000h是帶符號負數，正數總是大於負數，所以條件不成立，EDX將設為0。</p>
<p><strong>答案：</strong><br>EDX &#x3D; 0</p>
<hr>
<h3 id="16-True-False-The-following-code-will-jump-to-the-label-named-Target"><a href="#16-True-False-The-following-code-will-jump-to-the-label-named-Target" class="headerlink" title="16. (True&#x2F;False): The following code will jump to the label named Target."></a><strong>16. (True&#x2F;False): The following code will jump to the label named Target.</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov eax,-42</span><br><span class="line">cmp eax,26</span><br><span class="line">ja Target</span><br></pre></td></tr></table></figure>

<p><strong>翻譯：</strong> (判斷題)：以下代碼將跳轉到名為Target的標籤。</p>
<p><strong>解題過程：</strong><br>JA是”高於”跳轉（無符號比較）。-42在二進制表示中是一個非常大的無符號數，因此它大於26，條件成立。</p>
<p><strong>答案：</strong><br>True</p>
<hr>
<h3 id="18-What-will-be-the-value-of-RBX-after-the-following-instructions-execute"><a href="#18-What-will-be-the-value-of-RBX-after-the-following-instructions-execute" class="headerlink" title="18. What will be the value of RBX after the following instructions execute?"></a><strong>18. What will be the value of RBX after the following instructions execute?</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov rbx,0FFFFFFFFFFFFFFFFh</span><br><span class="line">and rbx,808080h</span><br></pre></td></tr></table></figure>

<p><strong>翻譯：</strong> 執行以下指令後，RBX的值是多少？</p>
<p><strong>解題過程：</strong><br>執行位與運算：全1與808080h進行AND操作，結果只保留808080h中的1位。</p>
<p><strong>答案：</strong><br>0000000000808080h</p>
<hr>
<h3 id="19-What-will-be-the-value-of-RBX-after-the-following-instructions-execute"><a href="#19-What-will-be-the-value-of-RBX-after-the-following-instructions-execute" class="headerlink" title="19. What will be the value of RBX after the following instructions execute?"></a><strong>19. What will be the value of RBX after the following instructions execute?</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov rbx,0FFFFFFFFFFFFFFFFh</span><br><span class="line">and rbx,80808080h</span><br></pre></td></tr></table></figure>

<p><strong>翻譯：</strong> 執行以下指令後，RBX的值是多少？</p>
<p><strong>解題過程：</strong><br>與上一題類似，但使用不同的掩碼。注意在64位操作中的符號擴展。</p>
<p><strong>答案：</strong><br>FFFFFFFF80808080h</p>
<hr>
<h3 id="6-10-2-算法工作台"><a href="#6-10-2-算法工作台" class="headerlink" title="6.10.2 算法工作台"></a><strong>6.10.2 算法工作台</strong></h3><h3 id="02-Write-instructions-that-calculate-the-parity-of-a-32-bit-memory-operand-Hint-Use-the-formula-presented-earlier-in-this-section-B0-XOR-B1-XOR-B2-XOR-B3"><a href="#02-Write-instructions-that-calculate-the-parity-of-a-32-bit-memory-operand-Hint-Use-the-formula-presented-earlier-in-this-section-B0-XOR-B1-XOR-B2-XOR-B3" class="headerlink" title="02. Write instructions that calculate the parity of a 32-bit memory operand. Hint: Use the formula presented earlier in this section: B0 XOR B1 XOR B2 XOR B3."></a><strong>02. Write instructions that calculate the parity of a 32-bit memory operand. Hint: Use the formula presented earlier in this section: B0 XOR B1 XOR B2 XOR B3.</strong></h3><p><strong>翻譯：</strong> 編寫計算32位內存操作數奇偶性的指令。提示：使用本節前面提出的公式：B0 XOR B1 XOR B2 XOR B3。</p>
<p><strong>解題過程：</strong><br>使用XOR操作計算奇偶性，將一個雙字的所有字節進行XOR操作，結果的奇偶性即為整個雙字的奇偶性。</p>
<p><strong>答案：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.data</span><br><span class="line">memVal DWORD ?</span><br><span class="line">.code</span><br><span class="line">mov al,BYTE PTR memVal</span><br><span class="line">xor al,BYTE PTR memVal+1</span><br><span class="line">xor al,BYTE PTR memVal+2</span><br><span class="line">xor al,BYTE PTR memVal+3</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="04-Write-instructions-that-jump-to-label-L1-when-the-unsigned-integer-in-DX-is-less-than-or-equal-to-the-integer-in-CX"><a href="#04-Write-instructions-that-jump-to-label-L1-when-the-unsigned-integer-in-DX-is-less-than-or-equal-to-the-integer-in-CX" class="headerlink" title="04. Write instructions that jump to label L1 when the unsigned integer in DX is less than or equal to the integer in CX."></a><strong>04. Write instructions that jump to label L1 when the unsigned integer in DX is less than or equal to the integer in CX.</strong></h3><p><strong>翻譯：</strong> 編寫在DX中的無符號整數小於或等於CX中的整數時跳轉到標籤L1的指令。</p>
<p><strong>解題過程：</strong><br>使用JBE（”低於或等於”）指令進行無符號比較。</p>
<p><strong>答案：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cmp dx,cx</span><br><span class="line">jbe L1</span><br><span class="line">L1:</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="06-Write-instructions-that-first-clear-bits-0-and-1-in-AL-Then-if-the-destination-operand-is-equal-to-zero-the-code-should-jump-to-label-L3-Otherwise-it-should-jump-to-label-L4"><a href="#06-Write-instructions-that-first-clear-bits-0-and-1-in-AL-Then-if-the-destination-operand-is-equal-to-zero-the-code-should-jump-to-label-L3-Otherwise-it-should-jump-to-label-L4" class="headerlink" title="06. Write instructions that first clear bits 0 and 1 in AL. Then, if the destination operand is equal to zero, the code should jump to label L3. Otherwise, it should jump to label L4."></a><strong>06. Write instructions that first clear bits 0 and 1 in AL. Then, if the destination operand is equal to zero, the code should jump to label L3. Otherwise, it should jump to label L4.</strong></h3><p><strong>翻譯：</strong> 編寫先清除AL中的位0和位1的指令。然後，如果目標操作數等於零，代碼應跳轉到標籤L3。否則，它應該跳轉到標籤L4。</p>
<p><strong>解題過程：</strong><br>使用AND操作清除位，然後使用JZ指令檢查結果是否為零。</p>
<p><strong>答案：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">and al,11111100b  ; 清除位0和位1</span><br><span class="line">jz L3             ; 如果結果為零跳轉到L3</span><br><span class="line">jmp L4            ; 否則跳轉到L4</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="08-Implement-the-following-pseudocode-in-assembly-language-Use-short-circuit-evaluation-and-assume-that-X-is-a-32-bit-variable"><a href="#08-Implement-the-following-pseudocode-in-assembly-language-Use-short-circuit-evaluation-and-assume-that-X-is-a-32-bit-variable" class="headerlink" title="08. Implement the following pseudocode in assembly language. Use short-circuit evaluation and assume that X is a 32-bit variable."></a><strong>08. Implement the following pseudocode in assembly language. Use short-circuit evaluation and assume that X is a 32-bit variable.</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if( ebx &gt; ecx ) OR ( ebx &gt; val1 )</span><br><span class="line">    X = 1</span><br><span class="line">else</span><br><span class="line">    X = 2</span><br></pre></td></tr></table></figure>

<p><strong>翻譯：</strong> 在組合語言中實現以下偽代碼。使用短路評估，並假設X是一個32位變數。</p>
<p><strong>解題過程：</strong><br>使用條件跳轉實現短路邏輯，如果第一個條件為真，則不檢查第二個條件。</p>
<p><strong>答案：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cmp bx,cx</span><br><span class="line">ja L1</span><br><span class="line">cmp bx,val1</span><br><span class="line">ja L1</span><br><span class="line">mov X,2</span><br><span class="line">jmp next</span><br><span class="line">L1: mov X,1</span><br><span class="line">next:</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="10-Implement-the-following-pseudocode-in-assembly-language-Use-short-circuit-evaluation-and-assume-that-A-B-and-N-are-32-bit-signed-integers"><a href="#10-Implement-the-following-pseudocode-in-assembly-language-Use-short-circuit-evaluation-and-assume-that-A-B-and-N-are-32-bit-signed-integers" class="headerlink" title="10. Implement the following pseudocode in assembly language. Use short-circuit evaluation and assume that A, B, and N are 32-bit signed integers."></a><strong>10. Implement the following pseudocode in assembly language. Use short-circuit evaluation and assume that A, B, and N are 32-bit signed integers.</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">while N &gt; 0</span><br><span class="line">    if N != 3 AND (N &lt; A OR N &gt; B)</span><br><span class="line">        N = N – 2</span><br><span class="line">    else</span><br><span class="line">        N = N – 1</span><br><span class="line">end while</span><br></pre></td></tr></table></figure>

<p><strong>翻譯：</strong> 在組合語言中實現以下偽代碼。使用短路評估，並假設A，B和N是32位帶符號整數。</p>
<p><strong>解題過程：</strong><br>使用條件跳轉實現循環和短路邏輯。</p>
<p><strong>答案：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Exercise10Test proc</span><br><span class="line">; 使用這些寄存器保存邏輯變數：</span><br><span class="line">mov eax,4     ; A</span><br><span class="line">mov ebx,5     ; B</span><br><span class="line">mov edx,10    ; N</span><br><span class="line">whileloop:</span><br><span class="line">cmp edx,0</span><br><span class="line">jle endwhile</span><br><span class="line">cmp edx,3     ; if N != 3</span><br><span class="line">je elselabel  ; 檢查 N &lt; eax OR N &gt; ebx</span><br><span class="line">cmp edx,eax   ; N &lt; A?</span><br><span class="line">jl orlabel    ; 如果為真，跳轉</span><br><span class="line">cmp edx,ebx   ; 或 N &gt; B?</span><br><span class="line">jg orlabel    ; 如果為真，跳轉</span><br><span class="line">jmp elselabel</span><br><span class="line">orlabel:</span><br><span class="line">sub edx,2</span><br><span class="line">jmp whileloop</span><br><span class="line">elselabel:</span><br><span class="line">sub edx,1</span><br><span class="line">jmp whileloop</span><br><span class="line">endwhile:</span><br><span class="line">ret</span><br><span class="line">Exercise10Test endp</span><br></pre></td></tr></table></figure>

<h1 id="考前筆記-x86-組合語言考試重點整理"><a href="#考前筆記-x86-組合語言考試重點整理" class="headerlink" title="考前筆記 x86 組合語言考試重點整理"></a>考前筆記 x86 組合語言考試重點整理</h1><h2 id="第一章：基本概念-Basic-Concepts"><a href="#第一章：基本概念-Basic-Concepts" class="headerlink" title="第一章：基本概念 (Basic Concepts)"></a>第一章：基本概念 (Basic Concepts)</h2><h3 id="重點概念："><a href="#重點概念：" class="headerlink" title="重點概念："></a>重點概念：</h3><ul>
<li><strong>MSB (Most Significant Bit)</strong> - 最高有效位，在 8 位元二進制數中是最左邊的位元</li>
<li><strong>二進制加法</strong> - 需要掌握進位的概念</li>
<li><strong>資料類型的位元數</strong>：<ul>
<li>word: 16 位元</li>
<li>doubleword: 32 位元</li>
<li>quadword: 64 位元</li>
<li>double quadword: 128 位元</li>
</ul>
</li>
<li><strong>進制轉換</strong>：二進制、十六進制、十進制之間的互相轉換</li>
<li><strong>有符號數</strong>：尤其是二的補數表示法 (2’s complement)</li>
<li><strong>布林運算與真值表</strong></li>
</ul>
<h3 id="關鍵詞提示："><a href="#關鍵詞提示：" class="headerlink" title="關鍵詞提示："></a>關鍵詞提示：</h3><ul>
<li>看到 <strong>“which is the most significant bit (MSB)?”</strong> 就選 “the highest numbered bit”</li>
<li>提到 <strong>“How many bits are used by each of the following data types?”</strong> 記住 <strong>word (16)</strong>, <strong>doubleword (32)</strong>, <strong>quadword (64)</strong>, <strong>double quadword (128)</strong></li>
<li>負數的十六進制表示題目如 <strong>“What is the 16-bit hexadecimal representation of each of the following signed decimal integers?”</strong> 通常以 <strong>F</strong> 開頭（比如 -24 是 FFE8）</li>
<li>看到真值表相關題目 <strong>“Create a truth table to show all possible inputs and outputs”</strong>，注意布林運算的基本規則</li>
</ul>
<h2 id="第二章：x86-處理器架構-x86-Processor-Architecture"><a href="#第二章：x86-處理器架構-x86-Processor-Architecture" class="headerlink" title="第二章：x86 處理器架構 (x86 Processor Architecture)"></a>第二章：x86 處理器架構 (x86 Processor Architecture)</h2><h3 id="重點概念：-1"><a href="#重點概念：-1" class="headerlink" title="重點概念："></a>重點概念：</h3><ul>
<li><strong>ECX 暫存器</strong> - 作為迴圈計數器 (loop counter)</li>
<li><strong>VRAM</strong> - 用於儲存圖像資料的 RAM</li>
<li><strong>BIOS</strong> - Windows 和 Linux 可共用同一 BIOS</li>
<li><strong>EBP 暫存器</strong> - 指向堆疊中的變數，是目前堆疊框架的基底指標</li>
<li><strong>狀態旗標 (Flags)</strong>：<ul>
<li>Carry flag - 無符號算術運算結果太大</li>
<li>Overflow flag - 有符號算術運算結果太大或太小</li>
<li>Parity flag - 只在最低位元組設定</li>
</ul>
</li>
<li><strong>REX 前綴</strong> - 使 R8D 暫存器等可用</li>
<li><strong>浮點運算單元</strong> (Floating-point unit) - 執行浮點運算</li>
<li><strong>x86-64 處理器</strong> - 比 x86 多八個通用暫存器</li>
<li><strong>8259A</strong> - 處理硬體的外部中斷控制器</li>
<li><strong>PCI</strong> - Peripheral Component Interconnect</li>
</ul>
<h3 id="關鍵詞提示：-1"><a href="#關鍵詞提示：-1" class="headerlink" title="關鍵詞提示："></a>關鍵詞提示：</h3><ul>
<li>看到 <strong>“What special purpose does the ECX register serve?”</strong> 就選 “loop counter”</li>
<li><strong>“Describe VRAM.”</strong> 相關題目選 “Video RAM” &#x2F; “RAM specifically used to store image data for a computer display”</li>
<li>關於 <strong>“Is it likely that the BIOS for a computer running MS-Windows would be different from that used by a computer running Linux?”</strong>，答案是 “The same BIOS would work for both OS Systems”</li>
<li>看到 <strong>“Which flag is set when the result of an unsigned arithmetic operation is too large to fit into the destination?”</strong> 選 “Carry flag”</li>
<li>看到 <strong>“Which flag is set when the result of a signed arithmetic operation is either too large or too small to fit into the destination?”</strong> 選 “Overflow flag”</li>
<li><strong>“The 8259A is a _________ that handles external interrupts from hardware devices.”</strong> 是 “Controller”</li>
<li><strong>“The acronym PCI stands for programmable component interface.”</strong> 是 False，正確答案是 “Peripheral Component Interconnect”</li>
</ul>
<h2 id="第三章：組合語言基礎-Assembly-Language-Fundamentals"><a href="#第三章：組合語言基礎-Assembly-Language-Fundamentals" class="headerlink" title="第三章：組合語言基礎 (Assembly Language Fundamentals)"></a>第三章：組合語言基礎 (Assembly Language Fundamentals)</h2><h3 id="重點概念：-2"><a href="#重點概念：-2" class="headerlink" title="重點概念："></a>重點概念：</h3><ul>
<li><strong>指令助記符 (mnemonics)</strong> - 常見的有 ADD, SUB, MOV</li>
<li><strong>堆疊空間保留</strong> - 通過從堆疊指標暫存器減去值來保留</li>
<li><strong>大端序與小端序</strong> (big endian vs. little endian)</li>
<li><strong>原始碼檔與列表檔</strong> (source file vs. listing file) 的區別</li>
<li><strong>資料標籤與程式碼標籤</strong> (data labels vs. code labels) 的區別</li>
<li><strong>組合語言指令四個基本部分</strong>：標籤、助記符、運算元、註解</li>
<li><strong>指令與指示詞</strong> (Instruction vs. Directive) 的區別</li>
<li><strong>PROTO 指示詞</strong> - 宣告程序原型</li>
<li><strong>符號常數</strong> - 以不同進制表示整數</li>
</ul>
<h3 id="關鍵詞提示：-2"><a href="#關鍵詞提示：-2" class="headerlink" title="關鍵詞提示："></a>關鍵詞提示：</h3><ul>
<li><strong>“Provide examples of three different instruction mnemonics.”</strong> 選 <strong>ADD, SUB, MOV</strong></li>
<li><strong>“How do you reserve space for the stack in a program?”</strong> 選 <strong>“By subtracting a value from the stack pointer register”</strong></li>
<li><strong>“Explain the difference between big endian and little endian.”</strong> 小端序特點是 <strong>“Little endian places the least significant bit in position 0, on the right side of the number”</strong></li>
<li><strong>“Name the four basic parts of an assembly language instruction.”</strong> 選 <strong>“Label, mnemonic, operand(s), comment”</strong></li>
<li><strong>“What’s the different between Instruction and Directive?”</strong> 區別：<strong>“A directive is a non-executable statement, while an instruction is an executable statement”</strong></li>
<li><strong>“What is the purpose of the PROTO directive?”</strong> 選 <strong>“PROTO declares the name of a procedure that is called by the current program”</strong></li>
</ul>
<h2 id="第四章：資料傳輸、定址與算術-Data-Transfers-Addressing-and-Arithmetic"><a href="#第四章：資料傳輸、定址與算術-Data-Transfers-Addressing-and-Arithmetic" class="headerlink" title="第四章：資料傳輸、定址與算術 (Data Transfers, Addressing, and Arithmetic)"></a>第四章：資料傳輸、定址與算術 (Data Transfers, Addressing, and Arithmetic)</h2><h3 id="重點概念：-3"><a href="#重點概念：-3" class="headerlink" title="重點概念："></a>重點概念：</h3><ul>
<li><strong>MOVSX</strong> 與 <strong>MOVZX</strong> 指令 - 擴展有符號&#x2F;無符號數</li>
<li><strong>DEC</strong> 指令 - 遞減運算</li>
<li><strong>位元轉換</strong> - 尤其是將位元組組合成字組或雙字組</li>
<li><strong>算術運算與旗標</strong></li>
<li><strong>PTR 運算子</strong> - 用於指定記憶體位置的資料類型</li>
<li><strong>WORD PTR</strong> 和 <strong>DWORD PTR</strong> 等的用法</li>
<li><strong>LABEL 指示詞</strong> - 允許以不同資料類型參考同一記憶體位置</li>
<li><strong>ALIGN 指示詞</strong> - 對齊資料到偶數位址</li>
<li><strong>TYPE, LENGTHOF, SIZEOF</strong> 操作符</li>
</ul>
<h3 id="關鍵詞提示：-3"><a href="#關鍵詞提示：-3" class="headerlink" title="關鍵詞提示："></a>關鍵詞提示：</h3><ul>
<li>看到 <strong>“What will be the value in EDX after each of the lines marked (a) and (b) execute?”</strong> 與 <strong>MOVSX</strong> 相關的值變化，注意符號位擴展（負數前面補 F）</li>
<li><strong>“Write a single instruction that moves the first two bytes in myBytes to the DX register.”</strong> 使用 <strong>WORD PTR</strong></li>
<li><strong>“Insert a directive in the given data that aligns myBytes to an even-numbered address.”</strong> 使用 <strong>ALIGN 2</strong></li>
<li><strong>“What will be the value of EAX after each of the following instructions execute?”</strong> 相關使用 <strong>TYPE, LENGTHOF, SIZEOF</strong>:<ul>
<li><strong>TYPE</strong> 返回元素大小（位元組數）</li>
<li><strong>LENGTHOF</strong> 返回元素個數</li>
<li><strong>SIZEOF</strong> 返回總大小（位元組數）</li>
</ul>
</li>
</ul>
<h2 id="第五章：程序-Procedures"><a href="#第五章：程序-Procedures" class="headerlink" title="第五章：程序 (Procedures)"></a>第五章：程序 (Procedures)</h2><h3 id="重點概念：-4"><a href="#重點概念：-4" class="headerlink" title="重點概念："></a>重點概念：</h3><ul>
<li><strong>PUSHA</strong> 指令 - 將所有 32 位元通用暫存器壓入堆疊</li>
<li><strong>POPF</strong> 指令 - 從堆疊彈出到 EFLAGS 暫存器</li>
<li><strong>PUSH&#x2F;POP</strong> 的替代實現</li>
<li><strong>巢狀程序呼叫</strong> - 在組合語言中是允許的</li>
<li><strong>ESI 和 EDI 暫存器</strong> - 可用於傳遞 32 位元參數</li>
<li><strong>USES 運算子</strong> - 列出在程序中修改的所有暫存器</li>
<li><strong>堆疊操作</strong> - 理解 PUSH、POP 與暫存器值的關係</li>
</ul>
<h3 id="關鍵詞提示：-4"><a href="#關鍵詞提示：-4" class="headerlink" title="關鍵詞提示："></a>關鍵詞提示：</h3><ul>
<li><strong>“Which instruction pushes all of the 32-bit general-purpose registers on the stack?”</strong> 選 <strong>PUSHA</strong></li>
<li><strong>“Which instruction pops the stack into the EFLAGS register?”</strong> 選 <strong>POPF</strong></li>
<li><strong>“Nested procedure calls are not permitted by the Microsoft assembler unless the NESTED operator is used in the procedure definition.”</strong> 答案是 <strong>False</strong>（巢狀程序呼叫是允許的）</li>
<li><strong>“The ESI and EDI registers cannot be used when passing 32-bit parameters to procedures.”</strong> 答案是 <strong>False</strong></li>
<li><strong>“The USES operator lets you name all registers that are modified within a procedure.”</strong> 答案是 <strong>True</strong></li>
</ul>
<h2 id="第六章：條件處理-Conditional-Processing"><a href="#第六章：條件處理-Conditional-Processing" class="headerlink" title="第六章：條件處理 (Conditional Processing)"></a>第六章：條件處理 (Conditional Processing)</h2><h3 id="重點概念：-5"><a href="#重點概念：-5" class="headerlink" title="重點概念："></a>重點概念：</h3><ul>
<li><strong>AND, OR, XOR, NOT</strong> 等位元運算指令</li>
<li><strong>條件跳轉指令</strong> - 如 JL（小於時跳轉）、JA（以上時跳轉）</li>
<li><strong>ECX 寄存器相關跳轉</strong> - JECX</li>
<li><strong>有符號與無符號比較</strong> - 影響條件判斷</li>
<li><strong>短路求值</strong> (short-circuit evaluation) - 在布林表達式中的應用</li>
</ul>
<h3 id="關鍵詞提示：-5"><a href="#關鍵詞提示：-5" class="headerlink" title="關鍵詞提示："></a>關鍵詞提示：</h3><ul>
<li><strong>“What will be the value of BX after the following instructions execute?”</strong> 使用布林運算時，記住：<ul>
<li><strong>AND</strong>：兩者皆為 1 才為 1</li>
<li><strong>OR</strong>：有一個為 1 就為 1</li>
<li><strong>XOR</strong>：相異為 1，相同為 0</li>
<li><strong>NOT</strong>：反轉所有位元</li>
</ul>
</li>
<li><strong>“Which conditional jump instruction executes a branch based on the contents of ECX?”</strong> 選 <strong>JECX</strong></li>
<li><strong>“The following code will jump to the label named Target.”</strong> 關於條件跳轉，需理解 JA、JL 等的使用場景</li>
</ul>
<h2 id="術語對照表"><a href="#術語對照表" class="headerlink" title="術語對照表"></a>術語對照表</h2><table>
<thead>
<tr>
<th>英文術語</th>
<th>中文解釋</th>
</tr>
</thead>
<tbody><tr>
<td>Most Significant Bit (MSB)</td>
<td>最高有效位</td>
</tr>
<tr>
<td>Word</td>
<td>字組 (16 位元)</td>
</tr>
<tr>
<td>Doubleword</td>
<td>雙字組 (32 位元)</td>
</tr>
<tr>
<td>Quadword</td>
<td>四字組 (64 位元)</td>
</tr>
<tr>
<td>Two’s complement</td>
<td>二的補數</td>
</tr>
<tr>
<td>Loop counter</td>
<td>迴圈計數器</td>
</tr>
<tr>
<td>Video RAM (VRAM)</td>
<td>視訊記憶體</td>
</tr>
<tr>
<td>Base pointer</td>
<td>基底指標</td>
</tr>
<tr>
<td>Carry flag</td>
<td>進位旗標</td>
</tr>
<tr>
<td>Overflow flag</td>
<td>溢位旗標</td>
</tr>
<tr>
<td>Parity flag</td>
<td>同位旗標</td>
</tr>
<tr>
<td>Peripheral Component Interconnect (PCI)</td>
<td>周邊元件互連</td>
</tr>
<tr>
<td>Mnemonic</td>
<td>助記符</td>
</tr>
<tr>
<td>Big endian</td>
<td>大端序</td>
</tr>
<tr>
<td>Little endian</td>
<td>小端序</td>
</tr>
<tr>
<td>Source file</td>
<td>原始碼檔</td>
</tr>
<tr>
<td>Listing file</td>
<td>列表檔</td>
</tr>
<tr>
<td>Data label</td>
<td>資料標籤</td>
</tr>
<tr>
<td>Code label</td>
<td>程式碼標籤</td>
</tr>
<tr>
<td>Instruction</td>
<td>指令</td>
</tr>
<tr>
<td>Directive</td>
<td>指示詞</td>
</tr>
<tr>
<td>PROTO directive</td>
<td>程序原型指示詞</td>
</tr>
<tr>
<td>PUSHA</td>
<td>壓入所有暫存器</td>
</tr>
<tr>
<td>POPF</td>
<td>彈出到標誌暫存器</td>
</tr>
<tr>
<td>USES operator</td>
<td>使用運算子</td>
</tr>
<tr>
<td>Conditional jump</td>
<td>條件跳轉</td>
</tr>
<tr>
<td>Short-circuit evaluation</td>
<td>短路求值</td>
</tr>
</tbody></table>
<h2 id="應試技巧"><a href="#應試技巧" class="headerlink" title="應試技巧"></a>應試技巧</h2><ol>
<li><p><strong>關注數字轉換</strong>：特別是二進制、十六進制和十進制之間的轉換</p>
</li>
<li><p><strong>暫存器值變化</strong>：遇到問暫存器最終值的題目，仔細追蹤每一步指令的執行</p>
</li>
<li><p><strong>指令配對</strong>：</p>
<ul>
<li><strong>jl&#x2F;jg</strong> - 有符號比較</li>
<li><strong>jb&#x2F;ja</strong> - 無符號比較</li>
<li><strong>mov</strong> - 移動資料</li>
<li><strong>add&#x2F;sub</strong> - 加&#x2F;減</li>
</ul>
</li>
<li><p><strong>看到關鍵字直接選擇</strong>：</p>
<ul>
<li>看到 <strong>loop counter</strong> 選 ECX</li>
<li>看到 <strong>parity</strong> 相關，記住只檢查最低位元組</li>
<li>看到 <strong>stack frame</strong> 選 EBP</li>
</ul>
</li>
<li><p><strong>布林運算配對</strong>：</p>
<ul>
<li><strong>AND</strong>：00 &amp; 00 &#x3D; 00, 11 &amp; 11 &#x3D; 11, 11 &amp; 00 &#x3D; 00</li>
<li><strong>OR</strong>：00 | 00 &#x3D; 00, 00 | 11 &#x3D; 11, 11 | 11 &#x3D; 11</li>
<li><strong>XOR</strong>：00 ^ 00 &#x3D; 00, 11 ^ 11 &#x3D; 00, 11 ^ 00 &#x3D; 11</li>
<li><strong>NOT</strong>：~00 &#x3D; FF, ~FF &#x3D; 00</li>
</ul>
</li>
</ol>
<h1 id="考前筆記"><a href="#考前筆記" class="headerlink" title="考前筆記"></a>考前筆記</h1><h3 id="a-shr-al-1-邏輯右移"><a href="#a-shr-al-1-邏輯右移" class="headerlink" title="(a) shr al,1 - 邏輯右移"></a>(a) shr al,1 - 邏輯右移</h3><p>SHR（Shift Right）是邏輯右移指令，會將所有位元向右移動指定的位數，左邊補0。</p>
<ul>
<li>原始值：11010100 (D4h)</li>
<li>右移1位後：01101010 (6Ah)</li>
<li>最右邊的位元（0）被移出並進入進位旗標</li>
</ul>
<p>邏輯右移相當於無號整數除以2的運算。</p>
<h3 id="b-sar-al-1-算術右移"><a href="#b-sar-al-1-算術右移" class="headerlink" title="(b) sar al,1 - 算術右移"></a>(b) sar al,1 - 算術右移</h3><p>SAR（Shift Arithmetic Right）是算術右移指令，與邏輯右移不同的是，它會保持符號位元（最左邊的位元）。</p>
<ul>
<li>原始值：11010100 (D4h)</li>
<li>算術右移1位後：11101010 (EAh)</li>
<li>注意最左邊仍然是1（保持符號）</li>
</ul>
<p>算術右移用於有號整數的除法運算，可以正確處理負數。</p>
<h3 id="sar-al-4-算術右移4位"><a href="#sar-al-4-算術右移4位" class="headerlink" title="sar al,4 - 算術右移4位"></a>sar al,4 - 算術右移4位</h3><p>同樣是算術右移，但這次移動4位：</p>
<ul>
<li>原始值：11010100 (D4h)</li>
<li>算術右移4位後：11111101 (FDh)</li>
<li>左邊補入4個1（因為原始符號位元是1）</li>
</ul>
<h3 id="rol-al-1-循環左移"><a href="#rol-al-1-循環左移" class="headerlink" title="rol al,1 - 循環左移"></a>rol al,1 - 循環左移</h3><p>ROL（Rotate Left）是循環左移指令，位元不會遺失，而是從左邊移出的位元會回到右邊：</p>
<ul>
<li>原始值：11010100 (D4h)</li>
<li>循環左移1位後：10101001 (A9h)</li>
<li>最左邊的1移到了最右邊</li>
</ul>
<h3 id="ror-al-3-循環右移3位"><a href="#ror-al-3-循環右移3位" class="headerlink" title="ror al,3 - 循環右移3位"></a>ror al,3 - 循環右移3位</h3><p>指令會將所有位元向右移動，但與普通右移不同的是，從右邊移出的位元會循環回到左邊。想像一下這些位元排成一個圓圈，向右旋轉。</p>
<p>原始值：11010100 (D4h)<br>讓我們逐步進行3次右移：</p>
<p>第1次右移：01101010（最右邊的0移到最左邊變成01101010，等等，這不對）</p>
<p>讓我重新仔細計算：</p>
<ul>
<li>原始：11010100</li>
<li>右移3位意味著最右邊的3個位元（100）會移到最左邊</li>
<li>結果：10011010 (9Ah)</li>
</ul>
<h3 id="stc-mov-al-0D4h-rcl-al-1-帶進位的循環左移"><a href="#stc-mov-al-0D4h-rcl-al-1-帶進位的循環左移" class="headerlink" title="stc mov al,0D4h rcl al,1 - 帶進位的循環左移"></a>stc mov al,0D4h rcl al,1 - 帶進位的循環左移</h3><p>進位旗標（Carry Flag）。STC指令會設定進位旗標為1。<br>RCL（Rotate Left through Carry）不僅僅是8位元的循環，而是9位元的循環，包含了進位旗標。</p>
<p>執行順序：</p>
<ul>
<li>STC設定進位旗標 &#x3D; 1</li>
<li>AL &#x3D; 11010100 (D4h)</li>
<li>RCL將9位元（8位元AL + 1位元進位旗標）向左移動1位</li>
</ul>
<p>想像成這樣的9位元序列：1 11010100（進位旗標在最左邊）<br>左移1位後：1 10101001（最左邊的1移到進位旗標位置）<br>AL的值變成：10101001 (A9h) (0A9h)</p>
<h3 id="stc-mov-al-0D4h-rcr-al-3-帶進位的循環右移3位"><a href="#stc-mov-al-0D4h-rcr-al-3-帶進位的循環右移3位" class="headerlink" title="stc mov al,0D4h rcr al,3 - 帶進位的循環右移3位"></a>stc mov al,0D4h rcr al,3 - 帶進位的循環右移3位</h3><p>RCR（Rotate Right through Carry）類似於RCL，但是向右移動並包含進位旗標。</p>
<p>執行順序：</p>
<ul>
<li>STC設定進位旗標 &#x3D; 1</li>
<li>AL &#x3D; 11010100 (D4h)</li>
<li>RCR將9位元向右移動3位</li>
</ul>
<p>這是一個9位元的向右循環：1 11010100<br>右移3位意味著最右邊的3位元會循環到左邊。<br>經過計算後得到AL：00111010 (3Ah)</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://rabbirreaper.github.io">Rabbir_Reaper</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章連結: </span><span class="post-copyright-info"><a href="https://rabbirreaper.github.io/2025/03/17/%E7%B5%84%E5%90%88%E8%AA%9E%E8%A8%80%E8%AA%B2%E7%A8%8B%E4%BD%9C%E6%A5%AD%E7%AD%86%E8%A8%98/">https://rabbirreaper.github.io/2025/03/17/%E7%B5%84%E5%90%88%E8%AA%9E%E8%A8%80%E8%AA%B2%E7%A8%8B%E4%BD%9C%E6%A5%AD%E7%AD%86%E8%A8%98/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版權聲明: </span><span class="post-copyright-info">本部落格所有文章除特別聲明外，均採用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 授權協議。轉載請註明來源 <a href="https://rabbirreaper.github.io" target="_blank">Hexo</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%A4%A7%E5%AD%B8%E7%AD%86%E8%A8%98/">大學筆記</a><a class="post-meta__tags" href="/tags/%E6%B2%92%E7%94%A8%E7%9A%84%E6%9D%B1%E8%A5%BF/">沒用的東西</a></div><div class="post-share"><div class="social-share" data-image="/img/butterfly-icon.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://unpkg.com/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://unpkg.com/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related  no-desc" href="/2025/03/21/python-%E5%9F%BA%E7%A4%8E%E7%B7%B4%E7%BF%92%E9%A1%8C%E7%9B%AE/" title="python 基礎練習題目"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">python 基礎練習題目</div></div></div></a><a class="pagination-related  no-desc" href="/2025/02/21/Q-5-5-Closest-pair/" title="Q-5-5. Closest pair"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">Q-5-5. Closest pair</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相關推薦</span></div><div class="relatedPosts-list"><a class="pagination-related no-desc" href="/2025/04/15/PHP-%E7%AD%86%E8%A8%98/" title="PHP 筆記"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-04-15</div><div class="info-item-2">PHP 筆記</div></div></div></a><a class="pagination-related no-desc" href="/2025/04/17/MIPS-%E6%8C%87%E4%BB%A4%E9%9B%86%E7%AD%86%E8%A8%98/" title="MIPS 指令集筆記"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-04-17</div><div class="info-item-2">MIPS 指令集筆記</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/butterfly-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Rabbir_Reaper</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">82</div></a><a href="/tags/"><div class="headline">標籤</div><div class="length-num">33</div></a><a href="/categories/"><div class="headline">分類</div><div class="length-num">10</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目錄</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BD%9C%E6%A5%AD"><span class="toc-number">1.</span> <span class="toc-text">作業</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2025-03-11-%E4%BD%9C%E6%A5%AD"><span class="toc-number">1.1.</span> <span class="toc-text">2025&#x2F;03&#x2F;11 作業</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-9-1-%E7%B0%A1%E7%AD%94%E9%A1%8C-Short-Answer-Questions"><span class="toc-number">1.1.1.</span> <span class="toc-text">3.9.1 簡答題 (Short Answer Questions)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-What-does-a-debugger-do"><span class="toc-number">1.1.1.1.</span> <span class="toc-text">(1). What does a debugger do?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-What-role-does-linker-and-loader-play-in-file-operation"><span class="toc-number">1.1.1.2.</span> <span class="toc-text">(3). What role does linker and loader play in file operation?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-What-is-the-benefit-of-using-labels-in-assembly-languages"><span class="toc-number">1.1.1.3.</span> <span class="toc-text">(5). What is the benefit of using labels in assembly languages?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-What-is-the-difference-between-a-directive-and-an-instruction"><span class="toc-number">1.1.1.4.</span> <span class="toc-text">(7). What is the difference between a directive and an instruction?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-Show-an-example-of-a-block-comment"><span class="toc-number">1.1.1.5.</span> <span class="toc-text">(8). Show an example of a block comment.</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13-Name-the-four-basic-parts-of-an-assembly-language-instruction"><span class="toc-number">1.1.1.6.</span> <span class="toc-text">(13). Name the four basic parts of an assembly language instruction.</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14-True-False-MOV-is-an-example-of-an-instruction-mnemonic"><span class="toc-number">1.1.1.7.</span> <span class="toc-text">(14). (True&#x2F;False) MOV is an example of an instruction mnemonic.</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#18-Write-a-program-that-copies-the-integer-12-to-AL-the-lowercase-letter-%E2%80%98m%E2%80%99-to-BL-and-the-character-%E2%80%98-%E2%80%99-to-CL-Then-move-them-to-AH-BH-and-CH-respectively"><span class="toc-number">1.1.1.8.</span> <span class="toc-text">(18). Write a program that copies the integer 12 to AL, the lowercase letter ‘m’ to BL, and the character ‘$’ to CL. Then, move them to AH, BH, and CH respectively.</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#21-How-is-a-source-file-different-from-a-listing-file"><span class="toc-number">1.1.1.9.</span> <span class="toc-text">(21). How is a source file different from a listing file?</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-9-2-%E7%AE%97%E6%B3%95%E5%B7%A5%E4%BD%9C%E5%8F%B0-Algorithm-Workbench"><span class="toc-number">1.1.2.</span> <span class="toc-text">3.9.2 算法工作台 (Algorithm Workbench)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-Define-four-symbolic-constants-that-represent-integer-25-in-decimal-binary-octal-and-hexadecimal-formats"><span class="toc-number">1.1.2.1.</span> <span class="toc-text">(1). Define four symbolic constants that represent integer 25 in decimal, binary, octal, and hexadecimal formats.</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-Create-a-data-definition-for-a-doubleword-that-stores-it-in-memory-in-big-endian-format"><span class="toc-number">1.1.2.2.</span> <span class="toc-text">(3). Create a data definition for a doubleword that stores it in memory in big endian format.</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-Write-a-program-that-contains-two-instructions-1-add-the-number-5-to-the-EAX-register-and-2-add-5-to-the-EDX-register-Generate-a-listing-file-and-examine-the-machine-code-generated-by-the-assembler-What-differences-if-any-did-you-find-between-the-two-instructions"><span class="toc-number">1.1.2.3.</span> <span class="toc-text">(5). Write a program that contains two instructions: (1) add the number 5 to the EAX register, and (2) add 5 to the EDX register. Generate a listing file and examine the machine code generated by the assembler. What differences, if any, did you find between the two instructions?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-Declare-an-array-of-120-uninitialized-unsigned-doubleword-values"><span class="toc-number">1.1.2.4.</span> <span class="toc-text">(7). Declare an array of 120 uninitialized unsigned doubleword values.</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-Declare-an-array-of-byte-and-initialize-it-to-the-first-5-letters-of-the-alphabet"><span class="toc-number">1.1.2.5.</span> <span class="toc-text">(8). Declare an array of byte and initialize it to the first 5 letters of the alphabet.</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-Declare-a-32-bit-signed-integer-variable-and-initialize-it-with-the-smallest-possible-negative-decimal-value-Hint-Refer-to-integer-ranges-in-Chapter-1"><span class="toc-number">1.1.2.6.</span> <span class="toc-text">(10). Declare a 32-bit signed integer variable and initialize it with the smallest possible negative decimal value. (Hint: Refer to integer ranges in Chapter 1.)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-Declare-a-string-variable-containing-the-name-of-your-favorite-color-Initialize-it-as-a-null-terminated-string"><span class="toc-number">1.1.2.7.</span> <span class="toc-text">(12). Declare a string variable containing the name of your favorite color. Initialize it as a null-terminated string.</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14-True-False-MOV-is-an-example-of-an-instruction-mnemonic-1"><span class="toc-number">1.1.2.8.</span> <span class="toc-text">(14). (True&#x2F;False) MOV is an example of an instruction mnemonic.</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2025-03-18-%E4%BD%9C%E6%A5%AD"><span class="toc-number">1.2.</span> <span class="toc-text">2025&#x2F;03&#x2F;18 作業</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-9-1-%E7%B0%A1%E7%AD%94%E9%A1%8C-Short-Answer-Questions"><span class="toc-number">1.3.</span> <span class="toc-text">4.9.1 簡答題 (Short Answer Questions)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-What-will-be-the-value-in-EDX-after-each-of-the-lines-marked-a-and-b-execute"><span class="toc-number">1.3.1.</span> <span class="toc-text">(1). What will be the value in EDX after each of the lines marked (a) and (b) execute?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-What-will-be-the-value-in-EAX-after-the-following-lines-execute"><span class="toc-number">1.3.2.</span> <span class="toc-text">(3). What will be the value in EAX after the following lines execute?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-What-will-be-the-value-of-the-Parity-flag-after-the-following-lines-execute"><span class="toc-number">1.3.3.</span> <span class="toc-text">(5). What will be the value of the Parity flag after the following lines execute?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-Explain-how-the-Overflow-flag-helps-or-does-not-help-you-to-determine-whether-the-final-value-in-AL-falls-within-a-valid-signed-range"><span class="toc-number">1.3.4.</span> <span class="toc-text">(7). Explain how the Overflow flag helps, or does not help you, to determine whether the final value in AL falls within a valid signed range.</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-What-value-will-RAX-contain-after-the-following-instructions-execute"><span class="toc-number">1.3.5.</span> <span class="toc-text">(9). What value will RAX contain after the following instructions execute?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-What-will-EAX-contain-after-the-following-instructions-execute"><span class="toc-number">1.3.6.</span> <span class="toc-text">(11). What will EAX contain after the following instructions execute?</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-9-2-%E7%AE%97%E6%B3%95%E5%B7%A5%E4%BD%9C%E5%8F%B0-Algorithm-Workbench"><span class="toc-number">1.4.</span> <span class="toc-text">4.9.2 算法工作台 (Algorithm Workbench)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-Write-a-sequence-of-MOV-instructions-that-will-exchange-the-upper-and-lower-words-in-a-doubleword-variable-named-three"><span class="toc-number">1.4.1.</span> <span class="toc-text">(1). Write a sequence of MOV instructions that will exchange the upper and lower words in a doubleword variable named three.</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-Show-how-you-could-use-the-Parity-flag-combined-with-an-arithmetic-instruction-to-determine-if-a-message-byte-has-even-or-odd-parity"><span class="toc-number">1.4.2.</span> <span class="toc-text">(3). Show how you could use the Parity flag combined with an arithmetic instruction to determine if a message byte has even or odd parity.</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-Write-a-sequence-of-two-instructions-that-use-addition-to-set-the-Zero-and-Carry-flags-at-the-same-time"><span class="toc-number">1.4.3.</span> <span class="toc-text">(5). Write a sequence of two instructions that use addition to set the Zero and Carry flags at the same time.</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-Implement-the-following-arithmetic-expression-in-assembly-language"><span class="toc-number">1.4.4.</span> <span class="toc-text">(7). Implement the following arithmetic expression in assembly language:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-Insert-a-directive-in-the-given-data-that-aligns-myBytes-to-an-even-numbered-address"><span class="toc-number">1.4.5.</span> <span class="toc-text">(12). Insert a directive in the given data that aligns myBytes to an even-numbered address.</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-What-will-be-the-value-of-EAX-after-each-of-the-following-instructions-execute"><span class="toc-number">1.4.6.</span> <span class="toc-text">(13). What will be the value of EAX after each of the following instructions execute?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-Write-a-single-instruction-that-moves-the-first-two-bytes-in-myBytes-to-the-DX-register-The-resulting-value-will-be-2010h"><span class="toc-number">1.4.7.</span> <span class="toc-text">(14). Write a single instruction that moves the first two bytes in myBytes to the DX register. The resulting value will be 2010h.</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-Write-an-instruction-that-moves-the-second-byte-in-myWords-to-the-AL-register"><span class="toc-number">1.4.8.</span> <span class="toc-text">(15). Write an instruction that moves the second byte in myWords to the AL register.</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-Write-an-instruction-that-moves-all-four-bytes-in-myBytes-to-the-EAX-register"><span class="toc-number">1.4.9.</span> <span class="toc-text">(16). Write an instruction that moves all four bytes in myBytes to the EAX register.</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-Insert-a-LABEL-directive-in-the-given-data-that-permits-myWords-to-be-moved-directly-to-a-32-bit-register"><span class="toc-number">1.4.10.</span> <span class="toc-text">(17). Insert a LABEL directive in the given data that permits myWords to be moved directly to a 32-bit register.</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-Insert-a-LABEL-directive-in-the-given-data-that-permits-myBytes-to-be-moved-directly-to-a-16-bit-register"><span class="toc-number">1.4.11.</span> <span class="toc-text">(18). Insert a LABEL directive in the given data that permits myBytes to be moved directly to a 16-bit register.</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-8-1-%E7%B0%A1%E7%AD%94%E9%A1%8C-Short-Answer"><span class="toc-number">1.5.</span> <span class="toc-text">5.8.1 簡答題 (Short Answer)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Which-instruction-pushes-the-32-bit-EFLAGS-register-on-the-stack"><span class="toc-number">1.5.1.</span> <span class="toc-text">(2). Which instruction pushes the 32-bit EFLAGS register on the stack?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-Challenge-Another-assembler-called-NASM-permits-the-PUSH-instruction-to-list-multiple-specific-registers-Why-might-this-approach-be-better-than-the-PUSHAD-instruction-in-MASM"><span class="toc-number">1.5.2.</span> <span class="toc-text">(4). Challenge: Another assembler (called NASM) permits the PUSH instruction to list multiple specific registers. Why might this approach be better than the PUSHAD instruction in MASM?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-True-False-The-RET-instruction-pops-the-top-of-the-stack-into-the-instruction-pointer"><span class="toc-number">1.5.3.</span> <span class="toc-text">(6). (True&#x2F;False): The RET instruction pops the top of the stack into the instruction pointer.</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-True-False-In-protected-mode-each-procedure-call-uses-a-minimum-of-4-bytes-of-stack-space"><span class="toc-number">1.5.4.</span> <span class="toc-text">(8). (True&#x2F;False): In protected mode, each procedure call uses a minimum of 4 bytes of stack space.</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-True-False-The-ArraySum-procedure-Section-5-2-5-receives-a-pointer-to-any-array-of-doublewords"><span class="toc-number">1.5.5.</span> <span class="toc-text">(10). (True&#x2F;False): The ArraySum procedure (Section 5.2.5) receives a pointer to any array of doublewords.</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-True-False-The-USES-operator-only-generates-PUSH-instructions-so-you-must-code-POP-instructions-yourself"><span class="toc-number">1.5.6.</span> <span class="toc-text">(12). (True&#x2F;False): The USES operator only generates PUSH instructions, so you must code POP instructions yourself.</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-Which-statement-s-in-the-ArraySum-procedure-Section-5-2-5-would-have-to-be-modified-so-it-could-accumulate-an-array-of-16-bit-words-Create-such-a-version-of-ArraySum-and-test-it"><span class="toc-number">1.5.7.</span> <span class="toc-text">(14). Which statement(s) in the ArraySum procedure (Section 5.2.5) would have to be modified so it could accumulate an array of 16-bit words? Create such a version of ArraySum and test it.</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-What-will-be-the-final-value-in-EAX-after-these-instructions-execute"><span class="toc-number">1.5.8.</span> <span class="toc-text">(15). What will be the final value in EAX after these instructions execute?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-Which-statement-is-true-about-what-will-happen-when-the-example-code-runs"><span class="toc-number">1.5.9.</span> <span class="toc-text">(16). Which statement is true about what will happen when the example code runs?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-Which-statement-is-true-about-what-will-happen-when-the-example-code-runs"><span class="toc-number">1.5.10.</span> <span class="toc-text">(17). Which statement is true about what will happen when the example code runs?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-Which-statement-is-true-about-what-will-happen-when-the-example-code-runs"><span class="toc-number">1.5.11.</span> <span class="toc-text">(18). Which statement is true about what will happen when the example code runs?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#19-Which-statement-is-true-about-what-will-happen-when-the-example-code-runs"><span class="toc-number">1.5.12.</span> <span class="toc-text">(19). Which statement is true about what will happen when the example code runs?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#20-What-values-will-be-written-to-the-array-when-the-following-code-executes"><span class="toc-number">1.5.13.</span> <span class="toc-text">(20). What values will be written to the array when the following code executes?</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-8-2-%E6%BC%94%E7%AE%97%E6%B3%95%E5%AF%A6%E6%88%B0-Algorithm-Workbench"><span class="toc-number">1.6.</span> <span class="toc-text">5.8.2 演算法實戰 (Algorithm Workbench)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Suppose-you-wanted-a-subroutine-to-return-to-an-address-that-was-3-bytes-higher-in-memory-than-the-return-address-currently-on-the-stack-Write-a-sequence-of-instructions-that-would-be-inserted-just-before-the-subroutine%E2%80%99s-RET-instruction-that-accomplish-this-task"><span class="toc-number">1.6.1.</span> <span class="toc-text">(2). Suppose you wanted a subroutine to return to an address that was 3 bytes higher in memory than the return address currently on the stack. Write a sequence of instructions that would be inserted just before the subroutine’s RET instruction that accomplish this task.</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-Write-a-sequence-of-statements-using-indexed-addressing-that-copies-an-element-in-a-doubleword-array-to-the-previous-position-in-the-same-array"><span class="toc-number">1.6.2.</span> <span class="toc-text">(4). Write a sequence of statements using indexed addressing that copies an element in a doubleword array to the previous position in the same array.</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%80%83%E8%A9%A6"><span class="toc-number">2.</span> <span class="toc-text">考試</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E7%AB%A0%EF%BC%9A%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">2.1.</span> <span class="toc-text">第一章：基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#01-In-an-8-bit-binary-number-which-is-the-most-significant-bit-MSB"><span class="toc-number">2.1.1.</span> <span class="toc-text">01. In an 8-bit binary number, which is the most significant bit (MSB)?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#03-What-is-the-sum-of-each-pair-of-binary-integers"><span class="toc-number">2.1.2.</span> <span class="toc-text">03. What is the sum of each pair of binary integers?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#05-How-many-bits-are-used-by-each-of-the-following-data-types"><span class="toc-number">2.1.3.</span> <span class="toc-text">05. How many bits are used by each of the following data types?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#07-What-is-the-hexadecimal-representation-of-each-of-the-following-binary-numbers"><span class="toc-number">2.1.4.</span> <span class="toc-text">07. What is the hexadecimal representation of each of the following binary numbers?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#09-What-is-the-unsigned-decimal-representation-of-each-of-the-following-hexadecimal-integers"><span class="toc-number">2.1.5.</span> <span class="toc-text">09. What is the unsigned decimal representation of each of the following hexadecimal integers?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-What-is-the-16-bit-hexadecimal-representation-of-each-of-the-following-signed-decimal-integers"><span class="toc-number">2.1.6.</span> <span class="toc-text">11. What is the 16-bit hexadecimal representation of each of the following signed decimal integers?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-The-following-16-bit-hexadecimal-numbers-represent-signed-integers-Convert-each-to-decimal"><span class="toc-number">2.1.7.</span> <span class="toc-text">13. The following 16-bit hexadecimal numbers represent signed integers. Convert each to decimal.</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-What-is-the-decimal-representation-of-each-of-the-following-signed-binary-numbers"><span class="toc-number">2.1.8.</span> <span class="toc-text">15. What is the decimal representation of each of the following signed binary numbers? &lt;6th Edition&gt;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-What-is-the-binary-sum-of-the-following-decimal-numbers-Express-the-sum-of-the-following-numbers-in-binary"><span class="toc-number">2.1.9.</span> <span class="toc-text">15. What is the binary sum of the following decimal numbers? Express the sum of the following numbers in binary.</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-What-is-the-8-bit-binary-two%E2%80%99s-complement-representation-of-each-of-the-following-signed-decimal-integers"><span class="toc-number">2.1.10.</span> <span class="toc-text">17. What is the 8-bit binary (two’s-complement) representation of each of the following signed decimal integers?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#19-The-following-hexadecimal-two%E2%80%99s-complement-numbers-are-signed-integers-please-convert-to-decimal-numbers"><span class="toc-number">2.1.11.</span> <span class="toc-text">19. The following hexadecimal (two’s complement) numbers are signed integers, please convert to decimal numbers.</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#19-What-is-the-sum-of-each-pair-of-hexadecimal-integers"><span class="toc-number">2.1.12.</span> <span class="toc-text">19. What is the sum of each pair of hexadecimal integers?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#21-What-are-the-hexadecimal-and-decimal-representations-of-the-ASCII-character-capital-B"><span class="toc-number">2.1.13.</span> <span class="toc-text">21. What are the hexadecimal and decimal representations of the ASCII character capital B?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#21-What-are-the-hexadecimal-and-decimal-representations-of-the-ASCII-characters-and"><span class="toc-number">2.1.14.</span> <span class="toc-text">21. What are the hexadecimal and decimal representations of the ASCII characters &amp; and $?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#23-Challenge-What-is-the-largest-decimal-value-you-can-represent-using-a-129-bit-unsigned-integer"><span class="toc-number">2.1.15.</span> <span class="toc-text">23. Challenge: What is the largest decimal value you can represent, using a 129-bit unsigned integer?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#24-Challenge-What-is-the-largest-decimal-value-you-can-represent-using-a-86-bit-signed-integer"><span class="toc-number">2.1.16.</span> <span class="toc-text">24. Challenge: What is the largest decimal value you can represent, using a 86-bit signed integer?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#25-Create-a-truth-table-to-show-all-possible-inputs-and-outputs-for-the-Boolean-function-described-by-A%E2%88%A8B-%C2%ACA-%E2%88%A7-%C2%ACB"><span class="toc-number">2.1.17.</span> <span class="toc-text">25. Create a truth table to show all possible inputs and outputs for the Boolean function described by -(A∨B) &amp; (¬A ∧ ¬B).</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#26-How-would-you-describe-the-rightmost-column-of-this-table-in-relation-to-the-table-from-question-number-25"><span class="toc-number">2.1.18.</span> <span class="toc-text">26. How would you describe the rightmost column of this table in relation to the table from question number 25?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#27-If-a-Boolean-function-has-four-inputs-how-many-rows-are-required-for-its-truth-table"><span class="toc-number">2.1.19.</span> <span class="toc-text">27. If a Boolean function has four inputs, how many rows are required for its truth table?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#28-Please-make-a-truth-table-with-three-inputs-and-one-output-based-on-the-following-logical-operators"><span class="toc-number">2.1.20.</span> <span class="toc-text">28. Please make a truth table with three inputs and one output based on the following logical operators.</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E7%AB%A0%EF%BC%9Ax86%E8%99%95%E7%90%86%E5%99%A8%E6%9E%B6%E6%A7%8B"><span class="toc-number">2.2.</span> <span class="toc-text">第二章：x86處理器架構</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#01-What-special-purpose-does-the-ECX-register-serve-p-2-11"><span class="toc-number">2.2.1.</span> <span class="toc-text">01. What special purpose does the ECX register serve? (p. 2-11)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#02-Describe-VRAM-p-2-16"><span class="toc-number">2.2.2.</span> <span class="toc-text">02. Describe VRAM. (p. 2-16)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#03-Is-it-likely-that-the-BIOS-for-a-computer-running-MS-Windows-would-be-different-from-that-used-by-a-computer-running-Linux-p-2-19"><span class="toc-number">2.2.3.</span> <span class="toc-text">03. Is it likely that the BIOS for a computer running MS-Windows would be different from that used by a computer running Linux? (p. 2-19)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#B-2-8-Short-Answer"><span class="toc-number">2.2.4.</span> <span class="toc-text">B. 2.8 Short Answer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#01-In-32-bit-mode-aside-from-the-stack-pointer-ESP-what-other-register-points-to-variables-on-the-stack"><span class="toc-number">2.2.5.</span> <span class="toc-text">01. In 32-bit mode, aside from the stack pointer (ESP), what other register points to variables on the stack?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#03-What-flags-will-be-set-when-56h-and-121h-are-added"><span class="toc-number">2.2.6.</span> <span class="toc-text">03. What flags will be set when 56h and 121h are added.</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#03-Which-flag-is-set-when-the-result-of-an-unsigned-arithmetic-operation-is-too-large-to-fit-into-the-destination"><span class="toc-number">2.2.7.</span> <span class="toc-text">03. Which flag is set when the result of an unsigned arithmetic operation is too large to fit into the destination?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#04-Which-flag-is-set-when-the-result-of-a-signed-arithmetic-operation-is-either-too-large-or-too-small-to-fit-into-the-destination"><span class="toc-number">2.2.8.</span> <span class="toc-text">04. Which flag is set when the result of a signed arithmetic operation is either too large or too small to fit into the destination?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#05-True-False-When-a-register-operand-size-is-32-bits-and-the-REX-prefix-is-used-the-R8D-register-is-available-for-programs-to-use"><span class="toc-number">2.2.9.</span> <span class="toc-text">05. (True&#x2F;False): When a register operand size is 32 bits and the REX prefix is used, the R8D register is available for programs to use.</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#07-Which-part-of-the-CPU-performs-floating-point-arithmetic"><span class="toc-number">2.2.10.</span> <span class="toc-text">07. Which part of the CPU performs floating-point arithmetic?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#08-On-a-32-bit-processor-how-many-bits-are-contained-in-each-floating-point-data-register"><span class="toc-number">2.2.11.</span> <span class="toc-text">08. On a 32-bit processor, how many bits are contained in each floating-point data register?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#09-True-or-False-Only-in-the-lowest-byte-the-parity-flag-will-be-set"><span class="toc-number">2.2.12.</span> <span class="toc-text">09. (True or False): Only in the lowest byte, the parity flag will be set.</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-True-False-The-Itanium-instruction-set-is-completely-different-from-the-x86-instruction-set"><span class="toc-number">2.2.13.</span> <span class="toc-text">11. (True&#x2F;False): The Itanium instruction set is completely different from the x86 instruction set.</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-True-False-The-64-bit-RDI-register-is-available-when-the-REX-prefix-is-used"><span class="toc-number">2.2.14.</span> <span class="toc-text">13. (True&#x2F;False): The 64-bit RDI register is available when the REX prefix is used.</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-True-False-The-x86-64-processors-have-4-more-general-purpose-registers-than-the-x86-processors"><span class="toc-number">2.2.15.</span> <span class="toc-text">15. (True&#x2F;False): The x86-64 processors have 4 more general-purpose registers than the x86 processors.</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-True-False-DRAM-can-only-be-erased-using-ultraviolet-light"><span class="toc-number">2.2.16.</span> <span class="toc-text">17. (True&#x2F;False): DRAM can only be erased using ultraviolet light.</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#19-True-or-False-Entity-mode-of-operation-is-no-longer-used-on-64-bit-x86-64-processors"><span class="toc-number">2.2.17.</span> <span class="toc-text">19. (True or False): Entity mode of operation is no longer used on 64-bit x86-64 processors.</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#21-True-or-False-A-chipset-is-a-group-of-chips-that-controls-the-display-output-of-a-computer-system"><span class="toc-number">2.2.18.</span> <span class="toc-text">21. (True or False): A chipset is a group of chips that controls the display output of a computer system.</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22-The-8259A-is-a-that-handles-external-interrupts-from-hardware-devices"><span class="toc-number">2.2.19.</span> <span class="toc-text">22. The 8259A is a _________ that handles external interrupts from hardware devices.</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#23-True-False-The-acronym-PCI-stands-for-programmable-component-interface"><span class="toc-number">2.2.20.</span> <span class="toc-text">23. (True&#x2F;False): The acronym PCI stands for programmable component interface.</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#25-At-which-level-s-can-an-Assembly-language-manipulate-input-output"><span class="toc-number">2.2.21.</span> <span class="toc-text">25. At which level(s) can an Assembly language manipulate input &#x2F; output?</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E7%AB%A0%EF%BC%9A%E7%B5%84%E5%90%88%E8%AA%9E%E8%A8%80%E5%9F%BA%E7%A4%8E"><span class="toc-number">2.3.</span> <span class="toc-text">第三章：組合語言基礎</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#01-Provide-examples-of-three-different-instruction-mnemonics"><span class="toc-number">2.3.1.</span> <span class="toc-text">01. Provide examples of three different instruction mnemonics.</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#03-How-do-you-reserve-space-for-the-stack-in-a-program"><span class="toc-number">2.3.2.</span> <span class="toc-text">03. How do you reserve space for the stack in a program?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#05-Explain-the-difference-between-big-endian-and-little-endian-Also-look-up-the-origins-of-this-term-on-the-Web"><span class="toc-number">2.3.3.</span> <span class="toc-text">05. Explain the difference between big endian and little endian. Also, look up the origins of this term on the Web.</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#07-How-is-a-source-file-different-from-a-listing-file"><span class="toc-number">2.3.4.</span> <span class="toc-text">07. How is a source file different from a listing file?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#08-How-are-data-labels-and-code-labels-different"><span class="toc-number">2.3.5.</span> <span class="toc-text">08. How are data labels and code labels different?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-Name-the-four-basic-parts-of-an-assembly-language-instruction-1"><span class="toc-number">2.3.6.</span> <span class="toc-text">13. Name the four basic parts of an assembly language instruction.</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-What%E2%80%99s-the-different-between-Instruction-and-Directive"><span class="toc-number">2.3.7.</span> <span class="toc-text">14. What’s the different between Instruction and Directive?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-Why-is-it-not-a-good-idea-to-use-numeric-addresses-when-writing-instructions-that-access-variables"><span class="toc-number">2.3.8.</span> <span class="toc-text">17. Why is it not a good idea to use numeric addresses when writing instructions that access variables?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-What-type-of-argument-must-be-passed-to-the-ExitProcess-procedure"><span class="toc-number">2.3.9.</span> <span class="toc-text">18. What type of argument must be passed to the ExitProcess procedure?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#21-What-is-the-purpose-of-the-PROTO-directive"><span class="toc-number">2.3.10.</span> <span class="toc-text">21. What is the purpose of the PROTO directive?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#B-3-9-2-Algorithm-Workbench"><span class="toc-number">2.3.11.</span> <span class="toc-text">B.3.9.2 Algorithm Workbench</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#01-Define-four-symbolic-constants-that-represent-integer-25-in-decimal-binary-octal-and-hexadecimal-formats"><span class="toc-number">2.3.12.</span> <span class="toc-text">01. Define four symbolic constants that represent integer 25 in decimal, binary, octal, and hexadecimal formats.</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#03-Create-a-data-definition-for-a-doubleword-that-stored-it-in-memory-in-big-endian-format"><span class="toc-number">2.3.13.</span> <span class="toc-text">03. Create a data definition for a doubleword that stored it in memory in big endian format.</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#05-Write-a-program-that-contains-two-instructions-1-add-the-number-5-to-the-EAX-register-and-2-add-5-to-the-EDX-register-Generate-a-listing-file-and-examine-the-machine-code-generated-by-the-assembler-What-differences-if-any-did-you-find-between-the-two-instructions"><span class="toc-number">2.3.14.</span> <span class="toc-text">05. Write a program that contains two instructions: (1) add the number 5 to the EAX register, and (2) add 5 to the EDX register. Generate a listing file and examine the machine code generated by the assembler. What differences, if any, did you find between the two instructions?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#07-Declare-an-array-of-120-uninitialized-unsigned-doubleword-values"><span class="toc-number">2.3.15.</span> <span class="toc-text">07. Declare an array of 120 uninitialized unsigned doubleword values.</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#08-Declare-an-array-of-byte-and-initialize-it-to-the-first-5-letters-of-the-alphabet"><span class="toc-number">2.3.16.</span> <span class="toc-text">08. Declare an array of byte and initialize it to the first 5 letters of the alphabet.</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-Declare-an-unsigned-16-bit-integer-variable-named-wArray-that-uses-three-initializers"><span class="toc-number">2.3.17.</span> <span class="toc-text">10. Declare an unsigned 16-bit integer variable named wArray that uses three initializers.</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-Declare-an-uninitialized-array-of-50-signed-doublewords-named-dArray"><span class="toc-number">2.3.18.</span> <span class="toc-text">12. Declare an uninitialized array of 50 signed doublewords named dArray.</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-Declare-an-array-of-20-unsigned-bytes-named-bArray-and-initialize-all-elements-to-zero"><span class="toc-number">2.3.19.</span> <span class="toc-text">14. Declare an array of 20 unsigned bytes named bArray and initialize all elements to zero.</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-Use-the-DUP-directive-to-allocate-space-for-five-double-words-and-two-bytes-in-a-data-segment-Then-fill-15-spaces-with-7-spaces-after-with-and-the-rest-with-an-uppercase-M"><span class="toc-number">2.3.20.</span> <span class="toc-text">15. Use the DUP directive to allocate space for five double-words and two bytes in a data segment. Then fill 15 spaces with &amp;, 7 spaces after &amp; with %, and the rest with an uppercase M.</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E7%AB%A0%EF%BC%9A%E6%95%B8%E6%93%9A%E5%82%B3%E8%BC%B8%E3%80%81%E5%B0%8B%E5%9D%80%E5%92%8C%E7%AE%97%E8%A1%93"><span class="toc-number">2.4.</span> <span class="toc-text">第四章：數據傳輸、尋址和算術</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-9-%E8%A4%87%E7%BF%92%E5%95%8F%E9%A1%8C%E8%88%87%E7%BF%92%E9%A1%8C"><span class="toc-number">2.4.1.</span> <span class="toc-text">4.9 複習問題與習題</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#A-4-9-1-%E7%B0%A1%E7%AD%94%E9%A1%8C"><span class="toc-number">2.4.2.</span> <span class="toc-text">A: 4.9.1 簡答題</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#01-What-will-be-the-value-in-EDX-after-each-of-the-lines-marked-a-and-b-execute"><span class="toc-number">2.4.3.</span> <span class="toc-text">01. What will be the value in EDX after each of the lines marked (a) and (b) execute?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#03-What-will-be-the-value-in-EAX-after-the-following-lines-execute"><span class="toc-number">2.4.4.</span> <span class="toc-text">03. What will be the value in EAX after the following lines execute?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#05-What-will-be-the-value-of-the-Parity-flag-after-the-following-lines-execute"><span class="toc-number">2.4.5.</span> <span class="toc-text">05. What will be the value of the Parity flag after the following lines execute?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#07-In-the-following-code-the-value-in-AL-is-intended-to-be-a-signed-byte-Explain-how-the-Overflow-flag-helps-or-does-not-help-you-to-determine-whether-the-final-value-in-AL-falls-within-a-valid-signed-range"><span class="toc-number">2.4.6.</span> <span class="toc-text">07. In the following code, the value in AL is intended to be a signed byte. Explain how the Overflow flag helps, or does not help you, to determine whether the final value in AL falls within a valid signed range.</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#09-What-value-will-RAX-contain-after-the-following-instructions-execute"><span class="toc-number">2.4.7.</span> <span class="toc-text">09. What value will RAX contain after the following instructions execute?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-What-value-will-EAX-contain-after-the-following-instructions-execute"><span class="toc-number">2.4.8.</span> <span class="toc-text">10. What value will EAX contain after the following instructions execute?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-What-will-EAX-contain-after-the-following-instructions-execute-1"><span class="toc-number">2.4.9.</span> <span class="toc-text">11. What will EAX contain after the following instructions execute?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E4%BB%A5%E4%B8%8B%E8%AE%8A%E6%95%B8%E5%AE%9A%E7%BE%A9%E4%BE%86%E5%9B%9E%E7%AD%94%E5%95%8F%E9%A1%8C16-19%EF%BC%9A"><span class="toc-number">2.4.10.</span> <span class="toc-text">使用以下變數定義來回答問題16-19：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-For-each-of-the-following-statements-state-whether-or-not-the-instruction-is-valid"><span class="toc-number">2.4.11.</span> <span class="toc-text">16. For each of the following statements, state whether or not the instruction is valid:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-What-will-be-the-hexadecimal-value-of-the-destination-operand-after-each-of-the-following-instructions-execute-in-sequence"><span class="toc-number">2.4.12.</span> <span class="toc-text">17. What will be the hexadecimal value of the destination operand after each of the following instructions execute in sequence?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-What-will-be-the-value-of-the-destination-operand-after-each-of-the-following-instructions-execute-in-sequence"><span class="toc-number">2.4.13.</span> <span class="toc-text">18. What will be the value of the destination operand after each of the following instructions execute in sequence?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#19-What-will-be-the-value-of-the-destination-operand-after-each-of-the-following-instructions-execute-in-sequence"><span class="toc-number">2.4.14.</span> <span class="toc-text">19. What will be the value of the destination operand after each of the following instructions execute in sequence?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#B-4-9-2-%E7%AE%97%E6%B3%95%E5%B7%A5%E4%BD%9C%E5%8F%B0"><span class="toc-number">2.4.15.</span> <span class="toc-text">B.4.9.2 算法工作台</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#01-Write-a-sequence-of-MOV-instructions-that-will-exchange-the-upper-and-lower-words-in-a-doubleword-variable-named-three"><span class="toc-number">2.4.16.</span> <span class="toc-text">01. Write a sequence of MOV instructions that will exchange the upper and lower words in a doubleword variable named three.</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#02-Use-the-XCHG-instruction-to-rearrange-the-values-in-the-four-eight-bit-temporary-registers-no-more-than-three-times-from-A-B-C-D-to-B-C-A-D"><span class="toc-number">2.4.17.</span> <span class="toc-text">02. Use the XCHG instruction to rearrange the values in the four eight-bit temporary registers no more than three times, from A, B, C, D to B, C, A, D.</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#03-Transmitted-messages-often-include-a-parity-bit-whose-value-is-combined-with-a-data-byte-to-produce-an-even-number-of-1-bits-Suppose-a-message-byte-in-the-AL-register-contains-01110101-Show-how-you-could-use-the-Parity-flag-combined-with-an-arithmetic-instruction-to-determine-if-this-message-byte-has-even-or-odd-parity"><span class="toc-number">2.4.18.</span> <span class="toc-text">03. Transmitted messages often include a parity bit whose value is combined with a data byte to produce an even number of 1 bits. Suppose a message byte in the AL register contains 01110101. Show how you could use the Parity flag combined with an arithmetic instruction to determine if this message byte has even or odd parity.</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#05-Write-a-sequence-of-two-instructions-that-use-addition-to-set-the-Zero-and-Carry-flags-at-the-same-time"><span class="toc-number">2.4.19.</span> <span class="toc-text">05. Write a sequence of two instructions that use addition to set the Zero and Carry flags at the same time.</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#07-Implement-the-following-arithmetic-expression-in-assembly-language-EAX-%E2%80%93val2-7-%E2%80%93-val3-val1-Assume-that-val1-val2-and-val3-are-32-bit-integer-variables"><span class="toc-number">2.4.20.</span> <span class="toc-text">07. Implement the following arithmetic expression in assembly language: EAX &#x3D; –val2 + 7 – val3 + val1. Assume that val1, val2, and val3 are 32-bit integer variables.</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B8%E6%93%9A%E5%AE%9A%E7%BE%A9%EF%BC%88%E7%94%A8%E6%96%BC%E5%95%8F%E9%A1%8C12-18%EF%BC%89%EF%BC%9A"><span class="toc-number">2.4.21.</span> <span class="toc-text">數據定義（用於問題12-18）：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-Insert-a-directive-in-the-given-data-that-aligns-myBytes-to-an-even-numbered-address-1"><span class="toc-number">2.4.22.</span> <span class="toc-text">12. Insert a directive in the given data that aligns myBytes to an even-numbered address.</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-What-will-be-the-value-of-EAX-after-each-of-the-following-instructions-execute-1"><span class="toc-number">2.4.23.</span> <span class="toc-text">13. What will be the value of EAX after each of the following instructions execute?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-Write-a-single-instruction-that-moves-the-first-two-bytes-in-myBytes-to-the-DX-register-The-resulting-value-will-be-2010h-1"><span class="toc-number">2.4.24.</span> <span class="toc-text">14. Write a single instruction that moves the first two bytes in myBytes to the DX register. The resulting value will be 2010h.</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-Write-an-instruction-that-moves-the-second-byte-in-myWords-to-the-AL-register-1"><span class="toc-number">2.4.25.</span> <span class="toc-text">15. Write an instruction that moves the second byte in myWords to the AL register.</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-Write-an-instruction-that-moves-all-four-bytes-in-myBytes-to-the-EAX-register-1"><span class="toc-number">2.4.26.</span> <span class="toc-text">16. Write an instruction that moves all four bytes in myBytes to the EAX register.</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-Insert-a-LABEL-directive-in-the-given-data-that-permits-myWords-to-be-moved-directly-to-a-32-bit-register-1"><span class="toc-number">2.4.27.</span> <span class="toc-text">17. Insert a LABEL directive in the given data that permits myWords to be moved directly to a 32-bit register.</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-Insert-a-LABEL-directive-in-the-given-data-that-permits-myBytes-to-be-moved-directly-to-a-16-bit-register-1"><span class="toc-number">2.4.28.</span> <span class="toc-text">18. Insert a LABEL directive in the given data that permits myBytes to be moved directly to a 16-bit register.</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%BA%94%E7%AB%A0%EF%BC%9A%E9%81%8E%E7%A8%8B"><span class="toc-number">2.5.</span> <span class="toc-text">第五章：過程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-8-1-%E7%B0%A1%E7%AD%94%E9%A1%8C"><span class="toc-number">2.5.1.</span> <span class="toc-text">5.8.1 簡答題</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#01-Which-instruction-pushes-all-of-the-32-bit-general-purpose-registers-on-the-stack"><span class="toc-number">2.5.2.</span> <span class="toc-text">01. Which instruction pushes all of the 32-bit general-purpose registers on the stack?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#03-Which-instruction-pops-the-stack-into-the-EFLAGS-register"><span class="toc-number">2.5.3.</span> <span class="toc-text">03. Which instruction pops the stack into the EFLAGS register?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#05-Challenge-Suppose-there-were-no-PUSH-instruction-Write-a-sequence-of-two-other-instructions-that-would-accomplish-the-same-as-push-eax"><span class="toc-number">2.5.4.</span> <span class="toc-text">05. Challenge: Suppose there were no PUSH instruction. Write a sequence of two other instructions that would accomplish the same as push eax.</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#07-True-False-Nested-procedure-calls-are-not-permitted-by-the-Microsoft-assembler-unless-the-NESTED-operator-is-used-in-the-procedure-definition"><span class="toc-number">2.5.5.</span> <span class="toc-text">07. (True&#x2F;False): Nested procedure calls are not permitted by the Microsoft assembler unless the NESTED operator is used in the procedure definition.</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#09-True-False-The-ESI-and-EDI-registers-cannot-be-used-when-passing-32-bit-parameters-to-procedures"><span class="toc-number">2.5.6.</span> <span class="toc-text">09. (True&#x2F;False): The ESI and EDI registers cannot be used when passing 32-bit parameters to procedures.</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-True-False-The-USES-operator-lets-you-name-all-registers-that-are-modified-within-a-procedure"><span class="toc-number">2.5.7.</span> <span class="toc-text">11. (True&#x2F;False): The USES operator lets you name all registers that are modified within a procedure.</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-True-False-The-USES-operator-only-generates-PUSH-instructions-so-you-must-code-POP-instructions-yourself-1"><span class="toc-number">2.5.8.</span> <span class="toc-text">12. (True&#x2F;False): The USES operator only generates PUSH instructions, so you must code POP instructions yourself.</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-True-False-The-register-list-in-the-USES-directive-must-use-commas-to-separate-the-register-names"><span class="toc-number">2.5.9.</span> <span class="toc-text">13. (True&#x2F;False): The register list in the USES directive must use commas to separate the register names.</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-What-will-be-the-final-value-in-EAX-after-these-instructions-execute-1"><span class="toc-number">2.5.10.</span> <span class="toc-text">15. What will be the final value in EAX after these instructions execute?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-Which-statement-is-true-about-what-will-happen-when-the-example-code-runs-1"><span class="toc-number">2.5.11.</span> <span class="toc-text">16. Which statement is true about what will happen when the example code runs?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-Which-statement-is-true-about-what-will-happen-when-the-example-code-runs-1"><span class="toc-number">2.5.12.</span> <span class="toc-text">17. Which statement is true about what will happen when the example code runs?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-Which-statement-is-true-about-what-will-happen-when-the-example-code-runs-1"><span class="toc-number">2.5.13.</span> <span class="toc-text">18. Which statement is true about what will happen when the example code runs?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#19-Which-statement-is-true-about-what-will-happen-when-the-example-code-runs-1"><span class="toc-number">2.5.14.</span> <span class="toc-text">19. Which statement is true about what will happen when the example code runs?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#20-What-values-will-be-written-to-the-array-when-the-following-code-executes-1"><span class="toc-number">2.5.15.</span> <span class="toc-text">20. What values will be written to the array when the following code executes?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-8-2-%E7%AE%97%E6%B3%95%E5%B7%A5%E4%BD%9C%E5%8F%B0"><span class="toc-number">2.5.16.</span> <span class="toc-text">5.8.2 算法工作台</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#01-Write-a-sequence-of-statements-that-use-only-PUSH-and-POP-instructions-to-exchange-the-values-in-the-EAX-and-EBX-registers-or-RAX-and-RBX-in-64-bit-mode"><span class="toc-number">2.5.17.</span> <span class="toc-text">01. Write a sequence of statements that use only PUSH and POP instructions to exchange the values in the EAX and EBX registers (or RAX and RBX in 64-bit mode).</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#03-Functions-in-high-level-languages-often-declare-local-variables-just-below-the-return-address-on-the-stack-Write-an-instruction-that-you-could-put-at-the-beginning-of-an-assembly-language-subroutine-that-would-reserve-space-for-two-integer-doubleword-variables-Then-assign-the-values-1000h-and-2000h-to-the-two-local-variables"><span class="toc-number">2.5.18.</span> <span class="toc-text">03. Functions in high-level languages often declare local variables just below the return address on the stack. Write an instruction that you could put at the beginning of an assembly language subroutine that would reserve space for two integer doubleword variables. Then, assign the values 1000h and 2000h to the two local variables.</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#05-Write-a-sequence-of-statements-that-display-a-subroutine-return-address-Be-sure-that-whatever-modifications-you-make-to-the-stack-do-not-prevent-the-subroutine-from-returning-to-its-caller"><span class="toc-number">2.5.19.</span> <span class="toc-text">05. Write a sequence of statements that display a subroutine return address. Be sure that whatever modifications you make to the stack do not prevent the subroutine from returning to its caller.</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%85%AD%E7%AB%A0%EF%BC%9A%E6%A2%9D%E4%BB%B6%E8%99%95%E7%90%86"><span class="toc-number">2.6.</span> <span class="toc-text">第六章：條件處理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-10-1-%E7%B0%A1%E7%AD%94%E9%A1%8C"><span class="toc-number">2.6.1.</span> <span class="toc-text">6.10.1 簡答題</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#02-What-will-be-the-value-of-BX-after-the-following-instructions-execute"><span class="toc-number">2.6.2.</span> <span class="toc-text">02. What will be the value of BX after the following instructions execute?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#04-What-will-be-the-value-of-BX-after-the-following-instructions-execute"><span class="toc-number">2.6.3.</span> <span class="toc-text">04. What will be the value of BX after the following instructions execute?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#06-What-will-be-the-value-of-RBX-after-the-following-instructions-execute"><span class="toc-number">2.6.4.</span> <span class="toc-text">06. What will be the value of RBX after the following instructions execute?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#08-In-the-following-instruction-sequence-show-the-resulting-value-of-AL-where-indicated-in-hexadecimal"><span class="toc-number">2.6.5.</span> <span class="toc-text">08. In the following instruction sequence, show the resulting value of AL where indicated, in hexadecimal:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-Which-conditional-jump-instruction-executes-a-branch-based-on-the-contents-of-ECX"><span class="toc-number">2.6.6.</span> <span class="toc-text">10. Which conditional jump instruction executes a branch based on the contents of ECX?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-What-will-be-the-final-value-in-EDX-after-this-code-executes"><span class="toc-number">2.6.7.</span> <span class="toc-text">12. What will be the final value in EDX after this code executes?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-What-will-be-the-final-value-in-EDX-after-this-code-executes"><span class="toc-number">2.6.8.</span> <span class="toc-text">14. What will be the final value in EDX after this code executes?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-True-False-The-following-code-will-jump-to-the-label-named-Target"><span class="toc-number">2.6.9.</span> <span class="toc-text">16. (True&#x2F;False): The following code will jump to the label named Target.</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-What-will-be-the-value-of-RBX-after-the-following-instructions-execute"><span class="toc-number">2.6.10.</span> <span class="toc-text">18. What will be the value of RBX after the following instructions execute?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#19-What-will-be-the-value-of-RBX-after-the-following-instructions-execute"><span class="toc-number">2.6.11.</span> <span class="toc-text">19. What will be the value of RBX after the following instructions execute?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-10-2-%E7%AE%97%E6%B3%95%E5%B7%A5%E4%BD%9C%E5%8F%B0"><span class="toc-number">2.6.12.</span> <span class="toc-text">6.10.2 算法工作台</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#02-Write-instructions-that-calculate-the-parity-of-a-32-bit-memory-operand-Hint-Use-the-formula-presented-earlier-in-this-section-B0-XOR-B1-XOR-B2-XOR-B3"><span class="toc-number">2.6.13.</span> <span class="toc-text">02. Write instructions that calculate the parity of a 32-bit memory operand. Hint: Use the formula presented earlier in this section: B0 XOR B1 XOR B2 XOR B3.</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#04-Write-instructions-that-jump-to-label-L1-when-the-unsigned-integer-in-DX-is-less-than-or-equal-to-the-integer-in-CX"><span class="toc-number">2.6.14.</span> <span class="toc-text">04. Write instructions that jump to label L1 when the unsigned integer in DX is less than or equal to the integer in CX.</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#06-Write-instructions-that-first-clear-bits-0-and-1-in-AL-Then-if-the-destination-operand-is-equal-to-zero-the-code-should-jump-to-label-L3-Otherwise-it-should-jump-to-label-L4"><span class="toc-number">2.6.15.</span> <span class="toc-text">06. Write instructions that first clear bits 0 and 1 in AL. Then, if the destination operand is equal to zero, the code should jump to label L3. Otherwise, it should jump to label L4.</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#08-Implement-the-following-pseudocode-in-assembly-language-Use-short-circuit-evaluation-and-assume-that-X-is-a-32-bit-variable"><span class="toc-number">2.6.16.</span> <span class="toc-text">08. Implement the following pseudocode in assembly language. Use short-circuit evaluation and assume that X is a 32-bit variable.</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-Implement-the-following-pseudocode-in-assembly-language-Use-short-circuit-evaluation-and-assume-that-A-B-and-N-are-32-bit-signed-integers"><span class="toc-number">2.6.17.</span> <span class="toc-text">10. Implement the following pseudocode in assembly language. Use short-circuit evaluation and assume that A, B, and N are 32-bit signed integers.</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%80%83%E5%89%8D%E7%AD%86%E8%A8%98-x86-%E7%B5%84%E5%90%88%E8%AA%9E%E8%A8%80%E8%80%83%E8%A9%A6%E9%87%8D%E9%BB%9E%E6%95%B4%E7%90%86"><span class="toc-number">3.</span> <span class="toc-text">考前筆記 x86 組合語言考試重點整理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E7%AB%A0%EF%BC%9A%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-Basic-Concepts"><span class="toc-number">3.1.</span> <span class="toc-text">第一章：基本概念 (Basic Concepts)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E9%BB%9E%E6%A6%82%E5%BF%B5%EF%BC%9A"><span class="toc-number">3.1.1.</span> <span class="toc-text">重點概念：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%9C%E9%8D%B5%E8%A9%9E%E6%8F%90%E7%A4%BA%EF%BC%9A"><span class="toc-number">3.1.2.</span> <span class="toc-text">關鍵詞提示：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E7%AB%A0%EF%BC%9Ax86-%E8%99%95%E7%90%86%E5%99%A8%E6%9E%B6%E6%A7%8B-x86-Processor-Architecture"><span class="toc-number">3.2.</span> <span class="toc-text">第二章：x86 處理器架構 (x86 Processor Architecture)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E9%BB%9E%E6%A6%82%E5%BF%B5%EF%BC%9A-1"><span class="toc-number">3.2.1.</span> <span class="toc-text">重點概念：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%9C%E9%8D%B5%E8%A9%9E%E6%8F%90%E7%A4%BA%EF%BC%9A-1"><span class="toc-number">3.2.2.</span> <span class="toc-text">關鍵詞提示：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E7%AB%A0%EF%BC%9A%E7%B5%84%E5%90%88%E8%AA%9E%E8%A8%80%E5%9F%BA%E7%A4%8E-Assembly-Language-Fundamentals"><span class="toc-number">3.3.</span> <span class="toc-text">第三章：組合語言基礎 (Assembly Language Fundamentals)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E9%BB%9E%E6%A6%82%E5%BF%B5%EF%BC%9A-2"><span class="toc-number">3.3.1.</span> <span class="toc-text">重點概念：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%9C%E9%8D%B5%E8%A9%9E%E6%8F%90%E7%A4%BA%EF%BC%9A-2"><span class="toc-number">3.3.2.</span> <span class="toc-text">關鍵詞提示：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E7%AB%A0%EF%BC%9A%E8%B3%87%E6%96%99%E5%82%B3%E8%BC%B8%E3%80%81%E5%AE%9A%E5%9D%80%E8%88%87%E7%AE%97%E8%A1%93-Data-Transfers-Addressing-and-Arithmetic"><span class="toc-number">3.4.</span> <span class="toc-text">第四章：資料傳輸、定址與算術 (Data Transfers, Addressing, and Arithmetic)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E9%BB%9E%E6%A6%82%E5%BF%B5%EF%BC%9A-3"><span class="toc-number">3.4.1.</span> <span class="toc-text">重點概念：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%9C%E9%8D%B5%E8%A9%9E%E6%8F%90%E7%A4%BA%EF%BC%9A-3"><span class="toc-number">3.4.2.</span> <span class="toc-text">關鍵詞提示：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%BA%94%E7%AB%A0%EF%BC%9A%E7%A8%8B%E5%BA%8F-Procedures"><span class="toc-number">3.5.</span> <span class="toc-text">第五章：程序 (Procedures)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E9%BB%9E%E6%A6%82%E5%BF%B5%EF%BC%9A-4"><span class="toc-number">3.5.1.</span> <span class="toc-text">重點概念：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%9C%E9%8D%B5%E8%A9%9E%E6%8F%90%E7%A4%BA%EF%BC%9A-4"><span class="toc-number">3.5.2.</span> <span class="toc-text">關鍵詞提示：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%85%AD%E7%AB%A0%EF%BC%9A%E6%A2%9D%E4%BB%B6%E8%99%95%E7%90%86-Conditional-Processing"><span class="toc-number">3.6.</span> <span class="toc-text">第六章：條件處理 (Conditional Processing)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E9%BB%9E%E6%A6%82%E5%BF%B5%EF%BC%9A-5"><span class="toc-number">3.6.1.</span> <span class="toc-text">重點概念：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%9C%E9%8D%B5%E8%A9%9E%E6%8F%90%E7%A4%BA%EF%BC%9A-5"><span class="toc-number">3.6.2.</span> <span class="toc-text">關鍵詞提示：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A1%93%E8%AA%9E%E5%B0%8D%E7%85%A7%E8%A1%A8"><span class="toc-number">3.7.</span> <span class="toc-text">術語對照表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%87%89%E8%A9%A6%E6%8A%80%E5%B7%A7"><span class="toc-number">3.8.</span> <span class="toc-text">應試技巧</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%80%83%E5%89%8D%E7%AD%86%E8%A8%98"><span class="toc-number">4.</span> <span class="toc-text">考前筆記</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#a-shr-al-1-%E9%82%8F%E8%BC%AF%E5%8F%B3%E7%A7%BB"><span class="toc-number">4.0.1.</span> <span class="toc-text">(a) shr al,1 - 邏輯右移</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#b-sar-al-1-%E7%AE%97%E8%A1%93%E5%8F%B3%E7%A7%BB"><span class="toc-number">4.0.2.</span> <span class="toc-text">(b) sar al,1 - 算術右移</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sar-al-4-%E7%AE%97%E8%A1%93%E5%8F%B3%E7%A7%BB4%E4%BD%8D"><span class="toc-number">4.0.3.</span> <span class="toc-text">sar al,4 - 算術右移4位</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#rol-al-1-%E5%BE%AA%E7%92%B0%E5%B7%A6%E7%A7%BB"><span class="toc-number">4.0.4.</span> <span class="toc-text">rol al,1 - 循環左移</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ror-al-3-%E5%BE%AA%E7%92%B0%E5%8F%B3%E7%A7%BB3%E4%BD%8D"><span class="toc-number">4.0.5.</span> <span class="toc-text">ror al,3 - 循環右移3位</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#stc-mov-al-0D4h-rcl-al-1-%E5%B8%B6%E9%80%B2%E4%BD%8D%E7%9A%84%E5%BE%AA%E7%92%B0%E5%B7%A6%E7%A7%BB"><span class="toc-number">4.0.6.</span> <span class="toc-text">stc mov al,0D4h rcl al,1 - 帶進位的循環左移</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#stc-mov-al-0D4h-rcr-al-3-%E5%B8%B6%E9%80%B2%E4%BD%8D%E7%9A%84%E5%BE%AA%E7%92%B0%E5%8F%B3%E7%A7%BB3%E4%BD%8D"><span class="toc-number">4.0.7.</span> <span class="toc-text">stc mov al,0D4h rcr al,3 - 帶進位的循環右移3位</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/10/31/251031/" title="251031">251031</a><time datetime="2025-10-30T23:49:20.000Z" title="發表於 2025-10-31 07:49:20">2025-10-31</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/10/29/Hono%E8%AA%9E%E6%B3%95%E7%AD%86%E8%A8%98/" title="Hono 語法筆記 (未完成)">Hono 語法筆記 (未完成)</a><time datetime="2025-10-29T05:31:19.000Z" title="發表於 2025-10-29 13:31:19">2025-10-29</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/24/%E8%B3%87%E6%96%99%E7%B5%90%E6%A7%8B-%E8%A8%88%E7%AE%97%E6%99%82%E9%96%93%E8%A4%87%E9%9B%9C%E5%BA%A6/" title="資料結構-計算時間複雜度 (未完成)">資料結構-計算時間複雜度 (未完成)</a><time datetime="2025-09-24T05:31:00.000Z" title="發表於 2025-09-24 13:31:00">2025-09-24</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/06/18/%E9%AB%98%E7%AD%89%E6%BC%94%E7%AE%97%E6%B3%95%E6%9C%9F%E6%9C%AB%E4%BD%9C%E6%A5%AD/" title="高等演算法期末作業">高等演算法期末作業</a><time datetime="2025-06-18T15:54:10.000Z" title="發表於 2025-06-18 23:54:10">2025-06-18</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/05/23/EEG%E5%88%86%E6%9E%90%E7%AD%86%E8%A8%98/" title="EEG分析筆記">EEG分析筆記</a><time datetime="2025-05-22T22:53:06.000Z" title="發表於 2025-05-23 06:53:06">2025-05-23</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;2019 - 2025 By Rabbir_Reaper</span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="閱讀模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日夜模式切換"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="單欄和雙欄切換"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="設定"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目錄"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到頂端"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = `%%{init:{ 'theme':'${theme}'}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://unpkg.com/mermaid/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script></div><script src="https://unpkg.com/mermaid/dist/mermaid.min.js"></script><script async data-pjax src="https://unpkg.com/busuanzi@2.3.0/bsz.pure.mini.js"></script></div></body></html>